[
  {
    "objectID": "tutorials.html",
    "href": "tutorials.html",
    "title": "Tutorial links",
    "section": "",
    "text": "Image: Tutors by David Power is licensed under CC BY-NC-ND 2.0",
    "crumbs": [
      "Tutorial links"
    ]
  },
  {
    "objectID": "tutorials.html#pre-workshop-tutorials",
    "href": "tutorials.html#pre-workshop-tutorials",
    "title": "Tutorial links",
    "section": "Pre-workshop tutorials",
    "text": "Pre-workshop tutorials\n\nR basics\nChart basics\nData basics",
    "crumbs": [
      "Tutorial links"
    ]
  },
  {
    "objectID": "tutorials.html#workshop-case-study",
    "href": "tutorials.html#workshop-case-study",
    "title": "Tutorial links",
    "section": "Workshop case study",
    "text": "Workshop case study\n\nPart 1: Goals\n\nPart 2: Data\n\nPart 3: Results",
    "crumbs": [
      "Tutorial links"
    ]
  },
  {
    "objectID": "tutorials.html#post-workshop-midfieldr-tutorials",
    "href": "tutorials.html#post-workshop-midfieldr-tutorials",
    "title": "Tutorial links",
    "section": "Post-workshop midfieldr tutorials",
    "text": "Post-workshop midfieldr tutorials\nThe following articles from the midfieldr website provide a deeper dive into the process of working with student-level data.\n\nPlanning\nData sufficiency\nDegree seeking\nPrograms\nBlocs\nFYE proxies\nStarters\nGraduates\nGroupings\nGradation rate\nStickiness\nMultiway data and charts",
    "crumbs": [
      "Tutorial links"
    ]
  },
  {
    "objectID": "tutorials.html#shaping-midfield-data-three-ways",
    "href": "tutorials.html#shaping-midfield-data-three-ways",
    "title": "Tutorial links",
    "section": "Shaping MIDFIELD data three ways",
    "text": "Shaping MIDFIELD data three ways\nA post-workshop set of tutorials to address the needs of users who would prefer to use base R or dplyr syntax in lieu of the data.table syntax that appears everywhere else in midfieldr.\n\nIntroduction\nData selection\nBasic transforms\nAggregating transforms\nMulti-table transforms\nReshaping transforms",
    "crumbs": [
      "Tutorial links"
    ]
  },
  {
    "objectID": "r-basics.html",
    "href": "r-basics.html",
    "title": "R basics",
    "section": "",
    "text": "An introduction to key concepts in R.\nLicense. This material is adapted from Getting started in R: Tinyverse edition by Bashir and Eddelbuettel (2018) which was licensed under CC BY-SA by ilustat. This adaptation and extension, R basics by Richard Layton, is licensed under CC BY-SA 2.0.",
    "crumbs": [
      "Tutorial links",
      "R basics"
    ]
  },
  {
    "objectID": "r-basics.html#preface",
    "href": "r-basics.html#preface",
    "title": "R basics",
    "section": "Preface",
    "text": "Preface\nThis guide gives you a flavor of what R can do for you. To get the most out of this guide, do the examples and exercises as you read along.\nExperiment safely. Be brave and experiment with commands and options as it is an essential part of the learning process. Things can and will go “wrong”, like getting error messages or deleting things that you create. You can recover from most situations using “undo” ctrl Z (MacOS cmd Z) or restarting R with the RStudio menu Session &gt; Restart R.\nBefore starting. Our tutorials assume that you\n\nHave completed the Before you arrive instructions\n\nStart your R session by launching the RStudio project you created, e.g., midfield-institute-2024.Rproj. If you are in your RStudio project, the project name appears in the upper left corner of the RStudio window, e.g.,\n\nAnd based on the work you did in the Before you arrive session, your project directory should have three folders:",
    "crumbs": [
      "Tutorial links",
      "R basics"
    ]
  },
  {
    "objectID": "r-basics.html#getting-started",
    "href": "r-basics.html#getting-started",
    "title": "R basics",
    "section": "Getting started",
    "text": "Getting started\nStarting R and RStudio. R starts automatically when you open RStudio with a screen similar to Figure 1.\n\nSource: view and edit files, e.g., R scripts\n\nConsole: run lines of code interactively\n\nEnvironment: display currently saved R objects\nOutput: files, plots, packages, help\n\n\n\n\n\n\n\n\nFigure 1: RStudio pane layout. See RStudio’s User Guide Pane layout for details on contents and layout editing.\n\n\n\n\nThe console starts with information about the version number, license and contributors. The last line is a prompt (&gt;) that indicates R is ready to do something.\n\n\n\n\n\n\n\nFigure 2: Console at startup\n\n\n\n\nQuitting R and RStudio. When you quit RStudio you will be asked whether to Save workspace? with a yes or no option. If you choose Yes, your current workspace is restored the next time you open RStudio. But as long as you save your script, saving the workspace is unnecessary. I recommend you choose No.\nTo set No as the default option, from the RStudio menu select Tools &gt; Global Options.\n\nUn-check the box Restore .RData into workspace at startup\n\nSet Save workspace to .RData on exit: to “Never”\n\n\n\n\n\n\n\n\nFigure 3: RStudio global options default settings.",
    "crumbs": [
      "Tutorial links",
      "R basics"
    ]
  },
  {
    "objectID": "r-basics.html#r-help",
    "href": "r-basics.html#r-help",
    "title": "R basics",
    "section": "R help",
    "text": "R help\nR’s built-in help system is an essential part of finding solutions to your R programming problems.\nhelp() function. From the R Console you can use the help() function or ?. For example, try the following two commands (which give the same result):\n# view the function help page\nhelp(mean)\n? mean\nIf you are asking for the package help page (assuming you have installed the package), type in the Console,\n# view a package help page\nhelp(package = \"midfieldr\")\nKeyword search. To do a keyword search use the function apropos() with the keyword in double quotes (“keyword”) or single quote (‘keyword’). For example:\n\n# keyword search \napropos(\"mean\")\n#&gt;  [1] \".colMeans\"     \".rowMeans\"     \"colMeans\"      \"kmeans\"       \n#&gt;  [5] \"mean\"          \"mean.Date\"     \"mean.default\"  \"mean.difftime\"\n#&gt;  [9] \"mean.POSIXct\"  \"mean.POSIXlt\"  \"rowMeans\"      \"weighted.mean\"\n\nThe lines of R output are labeled—here with [1], [5] , and [9]. These labels indicate the index or position of the first element in that line within the overall output (here, of length 12). Thus in this output vector, \".colMeans\" has index 1, \"mean\" has index 5, and \"mean.POSIXct\" has index 9.\nHelp examples. Use the example() function to run the examples at the end of the help for a function:\n\n# run the examples at the end of the help page\nexample(mean)\n#&gt; \n#&gt; mean&gt; x &lt;- c(0:10, 50)\n#&gt; \n#&gt; mean&gt; xm &lt;- mean(x)\n#&gt; \n#&gt; mean&gt; c(xm, mean(x, trim = 0.10))\n#&gt; [1] 8.75 5.50\n\nHere, the output of the mean() example has length 2 (8.75 5.50). The label [1] indicates that the number 8.75 has index 1.\nRStudio help. Rstudio provides search box in the Help tab in the Output pane to make your life easier (see Figure 1).\nOnline help. When you search online use [r] in your search terms, for example, “[r] linear regression”. Because we use data.table for data manipulation, I further recommend that you include data.table as a keyword, e.g., “[r][data.table] group and summarize”.\nThere is nearly always more than one solution to your problem—investigate the different options and try to use one whose arguments and logic you can follow. Limiting your browser’s search to the past year can sometimes eliminate out-of-date solutions.\nExercises are written such that the question is displayed under the tab to the left; the answer is displayed by clicking on the tab to the right.\n\n\nExercise 1.1\nAnswer\n\n\n\nTry the following.\n\nhelp(median)\n? sd\n? max\n\n\n\nThe following help pages should appear in the RStudio Help pane.\n\n\n\n\n\n\nWarning. If an R command is not complete then R will show a plus sign (+) prompt on second and subsequent lines until the command syntax is correct.\n+ \nPress the escape key (ESC) to break out.\nHint. To recall a previous command, put your cursor in the Console and use the up arrow key (↑). To go between previously typed commands use the up and down arrow (↓) keys. To modify or correct a command use the left (←) and right arrow (→) keys.",
    "crumbs": [
      "Tutorial links",
      "R basics"
    ]
  },
  {
    "objectID": "r-basics.html#r-scripts",
    "href": "r-basics.html#r-scripts",
    "title": "R basics",
    "section": "R scripts",
    "text": "R scripts\nCreating a script. I recommend that you write your lines of code in a script. Scripts can saved, edited, and run again and again.\n\nUse File &gt; New File &gt; R Script to create a new R script\n\nFile &gt; Save As… to name the file (I suggest 01-r-basics.R), then save it to the scripts directory\nAt the top of the script, add a minimal header, something like:\n\n\n# R basics \n# your name \n# date \n\nThe hash symbol # denotes a comment in R, that is, a line that isn’t run. Comments are annotations to make the source code easier for humans to understand but are ignored by R.\nNext,\n\nUse library() to load packages used in the script.\n\n\n# packages\nlibrary(\"midfieldr\")\n\nNote: In a code chunk like the one above, you can click on the “Copy to clipboard” icon in the upper right corner to enable quick copy and paste from this document to your script.\nRunning a script\n\nRun the script by clicking the Source button. Some participants report that this does not always work. The workaround is to:\nSelect the lines you want to run then ctrl Enter (MacOS cmd Return). Use the keyboard shortcuts ctrl A (MacOS cmd A) to select all lines. (See the appendices for a table of useful keyboard shortcuts.)\n\nIf you see an error like this one,\n    Error in library(\"midfieldr\"): there is no package called 'midfieldr'\nthen you should install the missing package(s) and run the script again. You can review how to install a package here.\nUse your script throughout the tutorial. When a new chunk of code is given,\n\nCopy the line(s) of code into your script, save, and run.\n\nCheck your result by comparing it to the result in the tutorial.\nCheck what you’ve learned using the Your turn exercises.",
    "crumbs": [
      "Tutorial links",
      "R basics"
    ]
  },
  {
    "objectID": "r-basics.html#r-concepts",
    "href": "r-basics.html#r-concepts",
    "title": "R basics",
    "section": "R concepts",
    "text": "R concepts\nObjects. In R speak, scalars, vectors, variables and datasets are called objects. To create objects (things) we use the assignment operator (&lt;-).\nFor example, the object height is assigned a value of 173 as follows,\n\n# assign a value to a named object \nheight &lt;- 173\n\nTyping the name alone prints out its value,\n\n# view\nheight\n#&gt; [1] 173\n\nIn these notes, everything that comes back to us in the Console as the result of running a script is shown prefaced by #&gt;.\nObjects in your R project workspace are listed in the RStudio Environment pane. At this point, we have three objects in the environment.\n\nWarning. R is case sensitive, age and AgE are different:\n\n# illustrating case-sensitivity \nage &lt;- 10\nAgE &lt;- 50\n\n\n# display result\nage\n#&gt; [1] 10\nAgE\n#&gt; [1] 50\n\nNew lines. R commands are usually separated by a new line but they can also be separated by a semicolon (not recommended).\n\n# recommended style\nname &lt;- \"Leo\"\nage  &lt;- 25\ncity &lt;- \"Lisbon\"\n\n# views\nname\n#&gt; [1] \"Leo\"\nage\n#&gt; [1] 25\ncity\n#&gt; [1] \"Lisbon\"\n\n# style not recommended \nname &lt;- \"Leo\"; age &lt;- 25; city &lt;- \"Lisbon\"\n\n# view\nname; age; city\n#&gt; [1] \"Leo\"\n#&gt; [1] 25\n#&gt; [1] \"Lisbon\"\n\nComments. It is useful to put comments in your script—especially useful to the future you looking back at your script after several months.\nR comments start with a hash sign (#). Everything after the hash to the end of the line is ignored by R.\n\n# This comment line is ignored when run.\n\ncity # text after \"#\" is ignored.\n#&gt; [1] \"Lisbon\"",
    "crumbs": [
      "Tutorial links",
      "R basics"
    ]
  },
  {
    "objectID": "r-basics.html#r-as-a-calculator",
    "href": "r-basics.html#r-as-a-calculator",
    "title": "R basics",
    "section": "R as a calculator",
    "text": "R as a calculator\nIn the console You can use R as a calculator by typing in the Console. Try the following:\n\n# type in the console\n2 + 3\n#&gt; [1] 5\n\n(5 * 11) / 4 - 7\n#&gt; [1] 6.75\n\n7^3 # exponent\n#&gt; [1] 343\n\nOther math functions. You can also use standard mathematical functions that are typically found on a scientific calculator.\n\ntrigonometric: sin(), cos(), tan(), etc.\nrounding: abs(), ceiling(), floor(), round(), sign(), signif(), trunc()\n\nlogarithms and exponentials: log(), log10(), log2(), exp()\n\n\n\n# type in the console\n\n# square root\nsqrt(2)\n#&gt; [1] 1.414214\n\n# round down to nearest integer\nfloor(8.6178)\n#&gt; [1] 8\n\n# round to 2 decimal places\nround(8.6178, 2)\n#&gt; [1] 8.62\n\n\n\nExercise 1.2\nAnswer\n\n\n\nWhat do the following pairs of examples do?\n\nceiling(18.33); signif(9488, 2)\nexp(1); log10(1000)\nsign(-2.9); sign(32)\nabs(-27.9); abs(11.9)\n\n\n\n\n19 and 9500\n2.718 and 3\n-1 and 1\n27.9 and 11.9",
    "crumbs": [
      "Tutorial links",
      "R basics"
    ]
  },
  {
    "objectID": "r-basics.html#more-r-concepts",
    "href": "r-basics.html#more-r-concepts",
    "title": "R basics",
    "section": "More R concepts",
    "text": "More R concepts\nFrom this point, please type the R code chunks in your script, save and run, and compare your results to those shown.\nAssignment. You can do some useful things using the assignment operator (&lt;-), for example,\n\n# assign dimensions\nroom_length &lt;- 7.8\nroom_width  &lt;- 6.4\n\n# compute area\nroom_area &lt;- room_length * room_width\n\n# view\nroom_area\n#&gt; [1] 49.92\n\nOn coding style. Summary of commonly used coding styles for naming objects in R include:\n\n\nstyle\nexample\n\n\n\nsnake case\nroom_area\n\n\ncamel case\nroomArea\n\n\nPascal case\nRoomArea\n\n\n\nWe use snake case, that is, lowercase letters and numbers with words separated by underscores. You may of course use any style you are comfortable with.\nText objects. You can assign text to an object.\n\n# assign text to an object\ngreeting &lt;- \"Hello world!\"\n\n# view\ngreeting\n#&gt; [1] \"Hello world!\"\n\nVectors. The objects presented so far have been scalars (single values). Working with vectors is where R shines best as they are the basic building blocks of datasets.\nWe can create a vector using the c() (combine values into a vector) function.\n\n# a numeric vector\nx1 &lt;- c(26, 10, 4, 7, 41, 19)\n\n# view\nx1\n#&gt; [1] 26 10  4  7 41 19\n\n# a character vector\nx2 &lt;- c(\"Peru\", \"Italy\", \"Cuba\", \"Ghana\")\n\n# view\nx2\n#&gt; [1] \"Peru\"  \"Italy\" \"Cuba\"  \"Ghana\"\n\nThere are many other ways to create vectors, for example, rep() (replicate elements) and seq() (create sequences):\n\n# repeat vector (2, 6, 7, 4) three times\nr1 &lt;- rep(c(2, 6, 7, 4), times = 3)\n\n# view\nr1\n#&gt;  [1] 2 6 7 4 2 6 7 4 2 6 7 4\n\n\n# vector from -2 to 3 incremented by 0.5\ns1 &lt;- seq(from = -2, to = 3, by = 0.5)\n\n# view\ns1\n#&gt;  [1] -2.0 -1.5 -1.0 -0.5  0.0  0.5  1.0  1.5  2.0  2.5  3.0\n\nVector operations. You can do calculations on vectors, for example using x1 from above:\n\n# multiply every element by 2\nx1 * 2\n#&gt; [1] 52 20  8 14 82 38\n\n# parentheses set the order of operations, working inside out\nround(sqrt(x1 * 2.6), 2)\n#&gt; [1]  8.22  5.10  3.22  4.27 10.32  7.03\n\nMissing values. Missing values are coded as NA in R. For example,\n\n# numeric vector with a missing value\nx2 &lt;- c(3, -7, NA, 5, 1, 1)\n\n# view\nx2\n#&gt; [1]  3 -7 NA  5  1  1\n\n# character vector with a missing value\nx3 &lt;- c(\"rat\", NA, \"mouse\", \"hamster\")\n\n# view\nx3\n#&gt; [1] \"rat\"     NA        \"mouse\"   \"hamster\"\n\nManaging objects. Use function ls() to list the objects in your workspace. The rm() function deletes them.\n\n# view objects in workspace\nls()\n#&gt;  [1] \"age\"         \"AgE\"         \"city\"        \"greeting\"    \"height\"     \n#&gt;  [6] \"name\"        \"r1\"          \"room_area\"   \"room_length\" \"room_width\" \n#&gt; [11] \"s1\"          \"x\"           \"x1\"          \"x2\"          \"x3\"         \n#&gt; [16] \"xm\"\n\n# remove objects\nrm(x1, x2, x3, r1, s1, AgE, age)\n\n# view result\nls()\n#&gt; [1] \"city\"        \"greeting\"    \"height\"      \"name\"        \"room_area\"  \n#&gt; [6] \"room_length\" \"room_width\"  \"x\"           \"xm\"\n\n\n\nExercise 1.3\nAnswer\n\n\n\nAdd the tax to the net amount and round to the nearest integer.\n\nnet &lt;- c(108.99, 291.42, 16.28, 62.29, 31.77)\ntax &lt;- c(22.89, 17.49, 0.98, 13.08, 6.67)\n\n\n\n\n#&gt; [1] 132 309  17  75  38",
    "crumbs": [
      "Tutorial links",
      "R basics"
    ]
  },
  {
    "objectID": "r-basics.html#r-functions-and-packages",
    "href": "r-basics.html#r-functions-and-packages",
    "title": "R basics",
    "section": "R functions and packages",
    "text": "R functions and packages\nR functions. We have already used some R functions (e.g. c(), mean(), rep(), sqrt(), round()). Most computation in R involves functions.\nA function essentially has a name and a list of arguments separated by commas. For example:\n\n# closer look at function arguments\nseq(from = 5, to = 8, by = 0.4)\n#&gt; [1] 5.0 5.4 5.8 6.2 6.6 7.0 7.4 7.8\n\n\nthe function name is seq\n\nthe function has three arguments from (the start value), to (the end value), and by (the increment between values)\narguments are assigned values (using =) within the parentheses and are separated by commas\n\nThe seq() function has other arguments, documented in the help page. For example, we could use the argument length.out (instead of by) to fix the length of the sequence as follows:\n\n# replacing `by` with `length.out` \nseq(from = 5, to = 8, length.out = 16)\n#&gt;  [1] 5.0 5.2 5.4 5.6 5.8 6.0 6.2 6.4 6.6 6.8 7.0 7.2 7.4 7.6 7.8 8.0\n\nCustom functions. As you gain familiarity with R, you may want to learn how to construct your own custom functions, but that’s not an objective of our “basics” tutorials.\nR packages. The basic R installation comes with over 2000 functions, but R can be extended further using contributed packages. Packages are like “apps” for R, containing functions, data, and documentation.\nTo see a list of functions and data sets bundled in a package, use the ls() function, e,g,\n\nls(\"package:midfieldr\")\n#&gt;  [1] \"add_completion_status\" \"add_data_sufficiency\"  \"add_timely_term\"      \n#&gt;  [4] \"baseline_mcid\"         \"cip\"                   \"filter_cip\"           \n#&gt;  [7] \"fye_proxy\"             \"grade_scale\"           \"order_multiway\"       \n#&gt; [10] \"prep_fye_mice\"         \"same_content\"          \"sat_act_scale\"        \n#&gt; [13] \"select_required\"       \"study_observations\"    \"study_programs\"       \n#&gt; [16] \"study_results\"         \"toy_course\"            \"toy_degree\"           \n#&gt; [19] \"toy_student\"           \"toy_term\"\n\nAlternatively, in RStudio select the Packages tab and in its menu bar type the package name in the search box. In the pane, click on the package name. A help page opens listing all the functions and names of data sets in the package, e.g.,\n\nIn MIDFIELD work, we use a small number of R packages:\n\nmidfieldr for tools to study student unit records\nmidfielddata for practice data\ndata.table for manipulating data\nggplot2 for charts",
    "crumbs": [
      "Tutorial links",
      "R basics"
    ]
  },
  {
    "objectID": "r-basics.html#about-r-objects",
    "href": "r-basics.html#about-r-objects",
    "title": "R basics",
    "section": "About R objects",
    "text": "About R objects\nEverything in R has class.\n\nclass(room_area)  # assigned earlier\n#&gt; [1] \"numeric\"\n\nclass(greeting)   # assigned earlier\n#&gt; [1] \"character\"\n\nclass(seq)        # R function \n#&gt; [1] \"function\"\n\nCertain actions will change the class of an object. Suppose we create a vector from the room_area and greeting objects.\n\nx &lt;- c(room_area, greeting)\nx\n#&gt; [1] \"49.92\"        \"Hello world!\"\n\nclass(x)\n#&gt; [1] \"character\"\n\nBy concatenating a number and a character string, R changed the class of room area from “numeric” to “character” because all elements of a vector must have the same class.\nData frames. The most common class of data object we will use is the data frame: a two-dimensional array of rows and columns in R. All values in a column are of the same type (numerical, character, logical, etc.) but columns can be of different types.\nFor example, the data frame study_results that is bundled with midfieldr has three character columns and three numerical columns.\n\n# a data frame bundled with midfieldr\nstudy_results\n#&gt;     program    sex            race ever_enrolled graduates stickiness\n#&gt;      &lt;char&gt; &lt;char&gt;          &lt;char&gt;         &lt;int&gt;     &lt;int&gt;      &lt;num&gt;\n#&gt;  1:      CE Female           Asian            15        10       66.7\n#&gt;  2:      CE Female           Black             4         1       25.0\n#&gt;  3:      CE Female   International            23        13       56.5\n#&gt;  4:      CE Female          Latine            13         6       46.2\n#&gt;  5:      CE Female Native American             1         1      100.0\n#&gt;  6:      CE Female   Other/Unknown             5         3       60.0\n#&gt;  7:      CE Female           White           263       162       61.6\n#&gt;  8:      CE   Male           Asian            30        25       83.3\n#&gt;  9:      CE   Male           Black             8         5       62.5\n#&gt; 10:      CE   Male   International            97        55       56.7\n#&gt; 11:      CE   Male          Latine            66        31       47.0\n#&gt; 12:      CE   Male Native American             3         1       33.3\n#&gt; 13:      CE   Male   Other/Unknown            27        11       40.7\n#&gt; 14:      CE   Male           White           949       612       64.5\n#&gt; 15:      EE Female           Asian            21        12       57.1\n#&gt; 16:      EE Female           Black             6         3       50.0\n#&gt; 17:      EE Female   International            28         9       32.1\n#&gt; 18:      EE Female          Latine             8         3       37.5\n#&gt; 19:      EE Female Native American             1         0        0.0\n#&gt; 20:      EE Female   Other/Unknown             7         3       42.9\n#&gt; 21:      EE Female           White           118        56       47.5\n#&gt; 22:      EE   Male           Asian           123        71       57.7\n#&gt; 23:      EE   Male           Black            29        17       58.6\n#&gt; 24:      EE   Male   International           195        90       46.2\n#&gt; 25:      EE   Male          Latine            45        17       37.8\n#&gt; 26:      EE   Male Native American             3         0        0.0\n#&gt; 27:      EE   Male   Other/Unknown            42        16       38.1\n#&gt; 28:      EE   Male           White           864       439       50.8\n#&gt; 29:     ISE Female           Asian            15        10       66.7\n#&gt; 30:     ISE Female           Black             7         6       85.7\n#&gt; 31:     ISE Female   International             6         2       33.3\n#&gt; 32:     ISE Female           White            77        54       70.1\n#&gt; 33:     ISE   Male           Asian            24        14       58.3\n#&gt; 34:     ISE   Male           Black             9         6       66.7\n#&gt; 35:     ISE   Male   International            22        12       54.5\n#&gt; 36:     ISE   Male          Latine             6         4       66.7\n#&gt; 37:     ISE   Male           White           187       130       69.5\n#&gt; 38:      ME Female           Asian             7         1       14.3\n#&gt; 39:      ME Female           Black             3         2       66.7\n#&gt; 40:      ME Female   International            19        11       57.9\n#&gt; 41:      ME Female          Latine            12         8       66.7\n#&gt; 42:      ME Female   Other/Unknown             8         4       50.0\n#&gt; 43:      ME Female           White           213       134       62.9\n#&gt; 44:      ME   Male           Asian            76        49       64.5\n#&gt; 45:      ME   Male           Black            30        19       63.3\n#&gt; 46:      ME   Male   International           178        89       50.0\n#&gt; 47:      ME   Male          Latine            79        42       53.2\n#&gt; 48:      ME   Male Native American             5         1       20.0\n#&gt; 49:      ME   Male   Other/Unknown            80        41       51.2\n#&gt; 50:      ME   Male           White          1596       953       59.7\n#&gt;     program    sex            race ever_enrolled graduates stickiness\n\nclass(study_results)\n#&gt; [1] \"data.table\" \"data.frame\"\n\nThe class() function reveals that this data.frame object is also a data.table object, which is an enhanced version of R’s standard data frame.\n\n\nExercise 1.4\nAnswer\n\n\n\nFor the following midfieldr objects, determine:\n\nthe class of add_timely_term\n\nthe class of toy_student\n\nthe names of the variables in toy_term\n\n\n\n\n\nfunction\ndata.table, data.frame\nmcid, institution, term, cip6, level\n\n\n\n\nEverything in R has structure.\n\nstr(room_area)  # assigned earlier\n#&gt;  num 49.9\n\nstr(greeting)         # assigned earlier\n#&gt;  chr \"Hello world!\"\n\nstr(seq)              # R function \n#&gt; function (...)\n\nstr(study_results)\n#&gt; Classes 'data.table' and 'data.frame':   50 obs. of  6 variables:\n#&gt;  $ program      : chr  \"CE\" \"CE\" \"CE\" \"CE\" ...\n#&gt;  $ sex          : chr  \"Female\" \"Female\" \"Female\" \"Female\" ...\n#&gt;  $ race         : chr  \"Asian\" \"Black\" \"International\" \"Latine\" ...\n#&gt;  $ ever_enrolled: int  15 4 23 13 1 5 263 30 8 97 ...\n#&gt;  $ graduates    : int  10 1 13 6 1 3 162 25 5 55 ...\n#&gt;  $ stickiness   : num  66.7 25 56.5 46.2 100 60 61.6 83.3 62.5 56.7 ...\n#&gt;  - attr(*, \".internal.selfref\")=&lt;externalptr&gt;\n\n\n\nExercise 1.5\nAnswer\n\n\n\nUse str() to determine\n\n\nadd_timely_term arguments\n\ntoy_student dimensions\n\nstudy_results numerical variables\n\n\n\n\nThe str() function prints out the arguments and their default values within the parentheses:\n\n\nstr(add_timely_term)\n#&gt; function (dframe, midfield_term = term, ..., span = NULL, sched_span = NULL)\n\n\n99 rows and 4 columns\n3 variables: ever_enrolled, graduates, stickiness",
    "crumbs": [
      "Tutorial links",
      "R basics"
    ]
  },
  {
    "objectID": "r-basics.html#keyboard-shortcuts",
    "href": "r-basics.html#keyboard-shortcuts",
    "title": "R basics",
    "section": "Keyboard shortcuts",
    "text": "Keyboard shortcuts\nIf you are working in RStudio, you can see the menu of keyboard shortcuts using the menu Tools &gt; Keyboard Shortcuts Help.\nThe shortcuts we use regularly include\n\n\n\n\n\n\n\n\n\nWindows / Linux\nAction\nMac OS\n\n\n\nctrl L\nClear the RStudio Console\nctrl L\n\n\nctrl Enter\nRun selected line(s)\ncmd Return\n\n\nctrl shift Enter\nRun complete script\ncmd shift Return\n\n\nctrl alt B\nRun from begining to line\ncmd option B\n\n\nctrl alt E\nRun from line to end\ncmd option E\n\n\n\nalt –\nInsert the assignment operator &lt;-\n\n\noption –\n\n\nctrl shift C\nComment/uncomment line(s)\ncmd shift C\n\n\nctrl X, C, V\nCut, copy, paste\ncmd X, C, V\n\n\nctrl Z\nUndo\ncmd Z\n\n\nctrl F\nFind in text\ncmd F\n\n\nctrl I\nIndent or re-indent lines od code\ncmd I\n\n\nctrl S\nSave\ncmd S\n\n\nctrl A\nSelect all text\ncmd A\n\n\nctrl shift K\nCompile R Markdown document\ncmd shift K",
    "crumbs": [
      "Tutorial links",
      "R basics"
    ]
  },
  {
    "objectID": "introduction.html",
    "href": "introduction.html",
    "title": "Introduction",
    "section": "",
    "text": "Image: A Cautious Introduction by Carol Blyberg is licensed under CC BY-NC 2.0\nThe MIDFIELD Institute is a hands-on workshop that helps participants explore using the Multiple-Institution Database for Investigating Longitudinal Development (MIDFIELD). The Institute is an all-virtual meeting over several days.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "introduction.html#about-midfield",
    "href": "introduction.html#about-midfield",
    "title": "Introduction",
    "section": "About MIDFIELD",
    "text": "About MIDFIELD\nMIDFIELD is a partnership of higher education institutions with engineering programs. Begun in 2004 as an extension of the SUCCEED Longitudinal Database, MIDFIELD contains student-level records for all undergraduate, degree-seeking students at the partner institutions.\nAs of June 2024, MIDFIELD contains student-level records for 2.4 M undergraduates at 21 US institutions.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "introduction.html#facilitators",
    "href": "introduction.html#facilitators",
    "title": "Introduction",
    "section": "Facilitators",
    "text": "Facilitators\n\nSusan Lord\n\nDirector of the MIDFIELD Institute and Professor and Chair of Integrated Engineering at the University of San Diego. She is a Fellow of the IEEE and the ASEE. Dr. Lord has considerable experience facilitating workshops including the National Effective Teaching Institute (NETI) and special sessions at FIE. (slord@sandiego.edu)\n\nMatthew Ohland\n\nMIDFIELD Director and Principal Investigator. He is the the Dale and Suzi Gallagher Professor and Associate Head of Engineering Education at Purdue University and a Fellow of IEEE, ASEE, and AAAS. Dr. Ohland has considerable experience facilitating workshops including the NETI and CATME training. (ohland@purdue.edu)\n\nMarisa Orr\n\n(On leave.) MIDFIELD Associate Director and Associate Professor in Engineering and Science Education with a joint appointment in Mechanical Engineering at Clemson University. She received the 2009 Helen Plants Award for the best nontraditional session at FIE, “Enhancing Student Learning Using SCALE-UP Format.” (marisak@clemson.edu)\n\nRussell Long\n\n(Retired.) MIDFIELD Managing Director and Data Steward. He developed the stratified data sample for the R packages used in this workshop. Mr. Long is a SAS expert with over twenty years of experience in institutional research and assessment. (ralong@purdue.edu)\n\nRichard Layton\n\nMIDFIELD Data Visualization Specialist and Professor Emeritus of Mechanical Engineering, Rose-Hulman Institute of Technology. He is the lead developer of the R packages used with the MIDFIELD practice data sets and the associated tutorials and workshop activities. (graphdoctor@gmail.com)",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "introduction.html#publications",
    "href": "introduction.html#publications",
    "title": "Introduction",
    "section": "Publications",
    "text": "Publications\nThe MIDFIELD team has been exploring and presenting the stories in the MIDFIELD data for over 10 years. To see a sample of our work, you can follow these links:\n\nLord SM, Ohland MW, Layton RA, and Camacho MM (2019) Beyond pipeline and pathways: Ecosystem metrics. Journal of Engineering Education, 108, 32–56. Wickenden best paper award.\nLord SM, Layton RA, and Ohland MW (2015) Multi-Institution study of student demographics and outcomes in Electrical and Computer Engineering in the USA, IEEE Transactions on Education, 58(3), 141–150. Batchman best paper award.\nBrawner CE, Lord SM, Layton RA, Ohland MW, and Long RA (2015) Factors affecting women’s persistence in chemical engineering, International Journal of Engineering Education 31(6A), 1431–1447.\n\nLink to a comprehensive list of publications by researchers using MIDFIELD.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "introduction.html#acknowledgements",
    "href": "introduction.html#acknowledgements",
    "title": "Introduction",
    "section": "Acknowledgements",
    "text": "Acknowledgements\nFunding provided by the National Science Foundation grant numbers 1545667 and 2142087.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "data-shaping-06-going-further.html",
    "href": "data-shaping-06-going-further.html",
    "title": "Going further",
    "section": "",
    "text": "Image: From the bottom uo by Jusitn Kern is licensed under CC BY-NC-ND 2.0\nUsing base R, data.table, and dplyr/tidyr to transform MIDFIELD data as needed for your analysis.\nIn this section we demonstrate …",
    "crumbs": [
      "Shaping data 3 ways",
      "Going further"
    ]
  },
  {
    "objectID": "data-shaping-06-going-further.html#setup",
    "href": "data-shaping-06-going-further.html#setup",
    "title": "Going further",
    "section": "Setup",
    "text": "Setup\nLoad packages.\n\nlibrary(\"midfielddata\")\nlibrary(\"data.table\")\nlibrary(\"dplyr\", warn.conflicts = FALSE)\nlibrary(\"tidyr\")\nlibrary(\"wrapr\")\n\nLoad datasets from midfielddata.\n\ndata(student, term, degree)\n\nRecode strings in degree for output readability as described in Basic Transforms.\n\ndegree[, degree := gsub(\" of\", \"\", degree)]\ndegree[, degree := sub(\"Bachelor Science\", \"BS\", degree)]\ndegree[, degree := sub(\"Bachelor Arts\", \"BA\", degree)]\ndegree[, degree := sub(\"Bachelor Fine Arts\", \"BFA\", degree)]\n\nFormat data as described in the Introduction.\n\n# base R\nstudent_df &lt;- data.frame(student)\nterm_df &lt;- data.frame(term)\ndegree_df &lt;- data.frame(degree)\n\n\n# data.table\nstudent_dt &lt;- copy(student)\nterm_dt &lt;- copy(term)\ndegree_dt &lt;- copy(degree)\n\n\n# dplyr\nstudent_tbl &lt;- tibble(student)\nterm_tbl &lt;- tibble(term)\ndegree_tbl &lt;- tibble(degree)",
    "crumbs": [
      "Shaping data 3 ways",
      "Going further"
    ]
  },
  {
    "objectID": "data-shaping-06-going-further.html#advanced-row-subsetting-by-groups",
    "href": "data-shaping-06-going-further.html#advanced-row-subsetting-by-groups",
    "title": "Going further",
    "section": "Advanced row-subsetting by groups",
    "text": "Advanced row-subsetting by groups\nWhen a specific instance yields a block of rows\nWhen subsetting rows for a specific instance of one variable (first, last, etc.) by group or key variable, we may need to allow for the possible return of more than one row per key.\nFor example, from the degree data table, subsetting for the first degree-term for the following student should return two rows, one each for Electrical Engineering and Mechanical Engineering.\n\nid_1 &lt;- \"MCID3112353622\"\ndegree[mcid == id_1]\n#&gt;              mcid   institution term_degree   cip6                       degree\n#&gt;            &lt;char&gt;        &lt;char&gt;      &lt;char&gt; &lt;char&gt;                       &lt;char&gt;\n#&gt; 1: MCID3112353622 Institution C       20133 141001 BS in Electrical Engineering\n#&gt; 2: MCID3112353622 Institution C       20133 141901 BS in Mechanical Engineering\n\nIn contrast, subsetting for the first term by ID for this next student should return one row for their degree in Economics (Summer 2003) and drop the row for their degree in History (Fall 2006).\n\nid_2 &lt;- \"MCID3111600469\"\ndegree[mcid == id_2]\n#&gt;              mcid   institution term_degree   cip6          degree\n#&gt;            &lt;char&gt;        &lt;char&gt;      &lt;char&gt; &lt;char&gt;          &lt;char&gt;\n#&gt; 1: MCID3111600469 Institution C       20024 450601 BA in Economics\n#&gt; 2: MCID3111600469 Institution C       20061 540101   BA in History\n\nTask. Retain all rows of the earliest term in which students earn one or more degrees.\n\nkey_columns &lt;- c(\"mcid\", \"term_degree\")\ncolumns_we_want &lt;- c(key_columns, \"degree\")\n\n\n# base R\nDF &lt;- degree_df[, key_columns, drop = FALSE]\norder_index &lt;- with(DF, order(mcid, term_degree))\nDF &lt;- DF[order_index, , drop = FALSE]\nDF_by &lt;- by(DF, DF$mcid, function(x) \n            data.frame(mcid = unique(x$mcid),\n                       term_degree = x$term_degree[1]))\nDF_combine &lt;- do.call(rbind, DF_by)\nDF &lt;- degree_df[, columns_we_want, drop = FALSE]\nresult_df &lt;- merge(DF_combine, DF, by = key_columns, all.x = TRUE)\nrownames(result_df) &lt;- NULL\n\n\n# data.table\nDT &lt;- degree_dt[, ..columns_we_want]\nsetkeyv(DT, key_columns)\nresult_dt &lt;- DT[, .SD[term_degree == term_degree[1]], by = c(\"mcid\")]\nsetkey(result_dt, NULL)\n\n\n# dplyr\nresult_tbl &lt;- degree_tbl %&gt;%\n  select(all_of(columns_we_want)) %&gt;% \n  arrange(mcid, term_degree) %&gt;%\n  group_by(mcid) %&gt;%\n  filter(term_degree == term_degree[1]) %&gt;%\n  ungroup()\n\n\nresult_dt\n#&gt;                  mcid term_degree                                  degree\n#&gt;                &lt;char&gt;      &lt;char&gt;                                  &lt;char&gt;\n#&gt;     1: MCID3111142225       19881            BS in Electrical Engineering\n#&gt;     2: MCID3111142290       19921            BS in Electrical Engineering\n#&gt;     3: MCID3111142294       19903            BS in Electrical Engineering\n#&gt;     4: MCID3111142299       19921            BS in Electrical Engineering\n#&gt;     5: MCID3111142689       19913                        BA in Journalism\n#&gt;    ---                                                                   \n#&gt; 49614: MCID3112829602       20173  BA in Political Science and Government\n#&gt; 49615: MCID3112831015       20181                         BA in Geography\n#&gt; 49616: MCID3112839623       20181                       BS in Linguistics\n#&gt; 49617: MCID3112845220       20181                       BS in Mathematics\n#&gt; 49618: MCID3112845673       20174 BS in Speech Communication and Rhetoric\n\ncheck_equiv_frames(result_df, result_dt)\n#&gt; [1] TRUE\ncheck_equiv_frames(result_dt, result_tbl)\n#&gt; [1] TRUE\n\nComments\n\nbase R. Order rows by ID and term; use by() for a split-apply-combine strategy to create a data frame with two columns: ID and first degree-term; and left-join using merge() to recover the matching degree data, including rows with more than one degree per student ID.\ndata.table. setkeyv() orders the rows and .SD[...] subsets for the earliest term by ID, including any multiple rows.\ndplyr. arrange() orders the rows, group_by() sets ID as the key, and filter() subsets for the earliest term, including any multiple rows.\n\nCheck that we subset the relevant rows. The result for id_1 (from the earlier example) correctly includes two degrees in the same term.\n\nresult_dt[mcid == id_1]\n#&gt;              mcid term_degree                       degree\n#&gt;            &lt;char&gt;      &lt;char&gt;                       &lt;char&gt;\n#&gt; 1: MCID3112353622       20133 BS in Electrical Engineering\n#&gt; 2: MCID3112353622       20133 BS in Mechanical Engineering\n\nThe result for id_2correctly includes their first degree in Economics and drops their subsequent degree in History.\n\nresult_dt[mcid == id_2]\n#&gt;              mcid term_degree          degree\n#&gt;            &lt;char&gt;      &lt;char&gt;          &lt;char&gt;\n#&gt; 1: MCID3111600469       20024 BA in Economics\n\nWhen a specific instance yields one row\nIn contrast to the previous case, there are times when we expect subsetting for a specific instance by group to yield one row only.\nFor example, suppose we want to identify the first term in which a student’s cumulative GPA dropped below 2.0. By definition, the result should yield only one row (or none) per ID.\n\ncolumns_we_want &lt;- c(\"mcid\", \"term\", \"standing\", \"gpa_cumul\")\nkey_columns &lt;- c(\"mcid\", \"term\")\n\n\n# base R\nrows_we_want &lt;- term_df$gpa_cumul &lt; 2.0\nDF &lt;- term_df[rows_we_want, columns_we_want, drop = FALSE]\norder_index &lt;- with(DF, order(mcid, term))\nDF &lt;- DF[order_index, , drop = FALSE]\nDF_by &lt;- by(DF, DF$mcid, function(x) \n            data.frame(mcid = x$mcid[1],\n                       term = x$term[1],\n                       standing = x$standing[1],\n                       gpa_cumul = x$gpa_cumul[1]))\nresult_df &lt;- do.call(rbind, DF_by)\nrownames(result_df) &lt;- NULL\n\n\n# data.table\nrows_we_want &lt;- term_dt$gpa_cumul &lt; 2.0\nDT &lt;- term_dt[rows_we_want, ..columns_we_want]\nsetkeyv(DT, key_columns)\nresult_dt &lt;- DT[, .SD[1], by = c(\"mcid\")]\nsetkey(result_dt, NULL)\n\n\n# dplyr\nresult_tbl &lt;- term_tbl %&gt;%\n  filter(gpa_cumul &lt; 2.0) %&gt;%\n  select(all_of(columns_we_want)) %&gt;%\n  arrange(mcid, term) %&gt;%\n  group_by(mcid) %&gt;%\n  slice(1L) %&gt;%\n  ungroup()\n\n\nresult_dt\n#&gt;                  mcid   term           standing gpa_cumul\n#&gt;                &lt;char&gt; &lt;char&gt;             &lt;char&gt;     &lt;num&gt;\n#&gt;     1: MCID3111142283  19881 Academic Probation      1.85\n#&gt;     2: MCID3111142633  19883 Academic Probation      1.96\n#&gt;     3: MCID3111142784  19883 Academic Probation      1.81\n#&gt;     4: MCID3111142895  19881 Academic Probation      1.81\n#&gt;     5: MCID3111142982  19896 Academic Probation      1.97\n#&gt;    ---                                                   \n#&gt; 11675: MCID3112897319  20181 Academic Dismissal      1.77\n#&gt; 11676: MCID3112897359  20181 Academic Dismissal      1.97\n#&gt; 11677: MCID3112897470  20181 Academic Dismissal      1.36\n#&gt; 11678: MCID3112897505  20181 Academic Dismissal      1.57\n#&gt; 11679: MCID3112898068  20181 Academic Dismissal      1.45\n\ncheck_equiv_frames(result_df, result_dt)\n#&gt; [1] TRUE\ncheck_equiv_frames(result_dt, result_tbl)\n#&gt; [1] TRUE\n\nComments\n\nbase R. Subset for rows with GPA &lt; 2.0. Like we did above, order rows by ID and term use by() to split-apply-combine operate on all four columns, but retain the first instance (one row) only by ID.\ndata.table. Subset rows and columns; setkeyv() orders the rows and .SD[1] subsets for the first instance only (one row).\ndplyr. Subset rows and columns; order rows; use slice(1L) to subset the first row by ID.\n\nCheck that we have one row per ID as expected.\n\n(n_mcid &lt;- length(unique(result_dt$mcid)))\n#&gt; [1] 11679\n(n_observation &lt;- nrow(result_dt))\n#&gt; [1] 11679\nall.equal(n_mcid, n_observation)\n#&gt; [1] TRUE",
    "crumbs": [
      "Shaping data 3 ways",
      "Going further"
    ]
  },
  {
    "objectID": "data-shaping-06-going-further.html#references",
    "href": "data-shaping-06-going-further.html#references",
    "title": "Going further",
    "section": "References",
    "text": "References",
    "crumbs": [
      "Shaping data 3 ways",
      "Going further"
    ]
  },
  {
    "objectID": "data-shaping-04-multi-table-transforms.html",
    "href": "data-shaping-04-multi-table-transforms.html",
    "title": "Multi-table transforms",
    "section": "",
    "text": "Image: Merge by Steve Walser is licensed under CC BY-NC-ND 2.0\nUsing base R, data.table, and dplyr to transform MIDFIELD data as needed for your analysis.\nIn this section, we split a data frame into a family of data frames, we concatenate tables row-wise, and we join tables.",
    "crumbs": [
      "Shaping data 3 ways",
      "Multi-table transforms"
    ]
  },
  {
    "objectID": "data-shaping-04-multi-table-transforms.html#setup",
    "href": "data-shaping-04-multi-table-transforms.html#setup",
    "title": "Multi-table transforms",
    "section": "Setup",
    "text": "Setup\nLoad packages.\n\nlibrary(\"midfielddata\")\nlibrary(\"data.table\")\nlibrary(\"dplyr\", warn.conflicts = FALSE)\nlibrary(\"wrapr\")\n\nFormat data as described in the Introduction.\n\ndata(student, degree)\ncohort &lt;- fread(\"data/three_blocs.csv\")\n\n\n# base R\nstudent_df &lt;- data.frame(student)\ndegree_df &lt;- data.frame(degree)\ncohort_df &lt;- data.frame(cohort)\n\n\n# data.table\nstudent_dt &lt;- copy(student)\ndegree_dt &lt;- copy(degree)\ncohort_dt &lt;- copy(cohort)\n\n\n# dplyr\nstudent_tbl &lt;- tibble(student)\ndegree_tbl &lt;- tibble(degree)\ncohort_tbl &lt;- tibble(cohort)",
    "crumbs": [
      "Shaping data 3 ways",
      "Multi-table transforms"
    ]
  },
  {
    "objectID": "data-shaping-04-multi-table-transforms.html#splitting-tables",
    "href": "data-shaping-04-multi-table-transforms.html#splitting-tables",
    "title": "Multi-table transforms",
    "section": "Splitting tables",
    "text": "Splitting tables\nSplitting is an operation that separates a data frame row-wise based on values in specified columns. Splitting is an inherent part of the grouping and summarizing operations described in Aggregating transforms: Summarizing such as base R by(), data.table [, , by], and dplyr group_by().\nHowever, splitting can be performed as a stand-alone operation as well. Base R split() creates a list of data frames and wrapr unpack() can be used to extract the data frames from the list and bind a variable name to each.\nA quick look at the cohort data before splitting.\n\ncohort\n#&gt;                  mcid    program peer_group\n#&gt;                &lt;char&gt;     &lt;char&gt;     &lt;char&gt;\n#&gt;     1: MCID3111142965 Electrical   starters\n#&gt;     2: MCID3111145102 Electrical   starters\n#&gt;     3: MCID3111150194 Industrial   starters\n#&gt;     4: MCID3111156083 Electrical   starters\n#&gt;     5: MCID3111156325 Electrical   starters\n#&gt;    ---                                     \n#&gt; 12966: MCID3112618553 Mechanical  graduates\n#&gt; 12967: MCID3112618574 Mechanical  graduates\n#&gt; 12968: MCID3112618976 Mechanical  graduates\n#&gt; 12969: MCID3112619484 Electrical  graduates\n#&gt; 12970: MCID3112641535 Mechanical  graduates\n\nTask. Split the cohort data frame by peer groups.\n\n# base R\nDF_split &lt;- split(cohort_df, cohort_df$peer_group)\nstart_df &lt;- DF_split$starters\never_df &lt;- DF_split$ever_enrolled\ngrad_df &lt;- DF_split$graduates\n\n\n# data.table\nDT_split &lt;- split(cohort_dt, by = \"peer_group\")\nwrapr::unpack(DT_split, \n              start_dt = starters,\n              ever_dt = ever_enrolled,\n              grad_dt = graduates)\n\n\n# dplyr\nTBL_split &lt;- split(cohort_tbl, cohort_tbl$peer_group)\nwrapr::unpack(TBL_split, \n              start_tbl = starters,\n              ever_tbl = ever_enrolled,\n              grad_tbl = graduates)\n\n\n# Display/check one representative result\nstart_dt\n#&gt;                 mcid    program peer_group\n#&gt;               &lt;char&gt;     &lt;char&gt;     &lt;char&gt;\n#&gt;    1: MCID3111142965 Electrical   starters\n#&gt;    2: MCID3111145102 Electrical   starters\n#&gt;    3: MCID3111150194 Industrial   starters\n#&gt;    4: MCID3111156083 Electrical   starters\n#&gt;    5: MCID3111156325 Electrical   starters\n#&gt;   ---                                     \n#&gt; 4049: MCID3112618572 Mechanical   starters\n#&gt; 4050: MCID3112618976 Mechanical   starters\n#&gt; 4051: MCID3112619118 Electrical   starters\n#&gt; 4052: MCID3112619484 Electrical   starters\n#&gt; 4053: MCID3112619666 Mechanical   starters\n\ncheck_equiv_frames(start_df, start_dt)\n#&gt; [1] TRUE\ncheck_equiv_frames(start_dt, start_tbl)\n#&gt; [1] TRUE\n\nComments\n\nbase R. The data frames are extracted from the DF_split list using $.\ndata.table. split() has a method for data.tables using the by argument.\ndplyr does not have its own splitting function, though tidyr nest() is similar—but requires additional housekeeping to unpack the resulting data frames. It seems easier in this case to use base R split() and wrapr unpack().\n\nConfirm that the number of rows in the new tables adds up to the expected total.\n\n(x &lt;- nrow(start_df))\n#&gt; [1] 4053\n(y &lt;- nrow(ever_df))\n#&gt; [1] 5653\n(z &lt;- nrow(grad_df))\n#&gt; [1] 3264\nsum(c(x, y, z))\n#&gt; [1] 12970\nnrow(cohort)\n#&gt; [1] 12970",
    "crumbs": [
      "Shaping data 3 ways",
      "Multi-table transforms"
    ]
  },
  {
    "objectID": "data-shaping-04-multi-table-transforms.html#appending-rows",
    "href": "data-shaping-04-multi-table-transforms.html#appending-rows",
    "title": "Multi-table transforms",
    "section": "Appending rows",
    "text": "Appending rows\nAppending rows is the inverse of splitting a data frame.\nIf two or more data frames have the same number of columns, with the same names, in the same order, one set of rows is easily appended to the other. We confirm that both objects are data frames and then verify the column names and positions.\nTask. Append the three tables from the previous example into a single data frame (row-wise).\n\nclass(start_df)\n#&gt; [1] \"data.frame\"\nclass(ever_df)\n#&gt; [1] \"data.frame\"\nclass(grad_df)\n#&gt; [1] \"data.frame\"\ncolnames(start_df)\n#&gt; [1] \"mcid\"       \"program\"    \"peer_group\"\ncolnames(ever_df)\n#&gt; [1] \"mcid\"       \"program\"    \"peer_group\"\ncolnames(grad_df)\n#&gt; [1] \"mcid\"       \"program\"    \"peer_group\"\n\n\n# base R\nresult_df &lt;- rbind(start_df, ever_df, grad_df)\n\n\n# data.table\nresult_dt &lt;- rbindlist(list(start_df, ever_dt, grad_dt))\n\n\n# dplyr\nresult_tbl &lt;- bind_rows(start_tbl, ever_tbl, grad_tbl)\n\n\nresult_dt\n#&gt;                  mcid    program peer_group\n#&gt;                &lt;char&gt;     &lt;char&gt;     &lt;char&gt;\n#&gt;     1: MCID3111142965 Electrical   starters\n#&gt;     2: MCID3111145102 Electrical   starters\n#&gt;     3: MCID3111150194 Industrial   starters\n#&gt;     4: MCID3111156083 Electrical   starters\n#&gt;     5: MCID3111156325 Electrical   starters\n#&gt;    ---                                     \n#&gt; 12966: MCID3112618553 Mechanical  graduates\n#&gt; 12967: MCID3112618574 Mechanical  graduates\n#&gt; 12968: MCID3112618976 Mechanical  graduates\n#&gt; 12969: MCID3112619484 Electrical  graduates\n#&gt; 12970: MCID3112641535 Mechanical  graduates\n \ncheck_equiv_frames(result_df, result_dt)\n#&gt; [1] TRUE\ncheck_equiv_frames(result_dt, result_tbl)\n#&gt; [1] TRUE\n\nComments\n\nbase R. rbind() acts on the data frames listed.\ndata.table. rbindlist(), argument must be a list of data frames.\ndplyr. bind_rows() acts on the data frames listed. Can be a list of data frames.\n\nConfirm that the reassembled data frame is equivalent to the original.\n\ncheck_equiv_frames(cohort, result_dt)\n#&gt; [1] TRUE",
    "crumbs": [
      "Shaping data 3 ways",
      "Multi-table transforms"
    ]
  },
  {
    "objectID": "data-shaping-04-multi-table-transforms.html#appending-columns",
    "href": "data-shaping-04-multi-table-transforms.html#appending-columns",
    "title": "Multi-table transforms",
    "section": "Appending columns",
    "text": "Appending columns\nColumns can be appended to a data frame using cbind() and bind_cols()—the column-wise equivalents to rbind() and bind_rows()—but we rarely use them. Instead, appending new columns is nearly always accomplished in our work using joins. The most common joins in midfieldr work are the left join and the inner join, described next.",
    "crumbs": [
      "Shaping data 3 ways",
      "Multi-table transforms"
    ]
  },
  {
    "objectID": "data-shaping-04-multi-table-transforms.html#left-join",
    "href": "data-shaping-04-multi-table-transforms.html#left-join",
    "title": "Multi-table transforms",
    "section": "Left join",
    "text": "Left join\nA left join is a merge operation between two data frames that returns all observations (rows) of the “left” data frame x and all the matching rows in the “right” data frame y.\nThe general forms of the left join are:\n  # base R\n  merge(x, y, by, all.x = TRUE)\n\n  # data.table\n  y[x, j, on]\n\n  # dplyr\n  left_join(x, y, by)\nwhere\n\n\nx is the “left” data frame, all rows returned\n\ny is the “right” data frame, matching rows returned\n\nby and on are the vectors of shared column names to merge by\n\nj (if used) selects columns from the joined data frame to retain\n\nTask. Join student race and sex to the data frame of graduates by ID.\nWe use intermediate variables x and y in each system to help clarify the join operation.\n\n# base R\nx &lt;- grad_df[, c(\"mcid\", \"program\"), drop = FALSE]\ny &lt;- student_df[, c(\"mcid\", \"race\", \"sex\"), drop = FALSE]\nresult_df &lt;- merge(x, y, by = c(\"mcid\"), all.x = TRUE)\n\n\n# data.table\nx &lt;- grad_dt[, .(mcid, program)]\ny &lt;- student_dt[, .(mcid, race, sex)]\nresult_dt &lt;- y[x, , on = c(\"mcid\")]\n\n\n# dplyr\nx &lt;- select(grad_tbl, mcid, program)\ny &lt;- select(student_tbl, mcid, race, sex)\nresult_tbl &lt;- left_join(x, y, by = c(\"mcid\"))\n\n\nresult_dt\n#&gt;                 mcid          race    sex    program\n#&gt;               &lt;char&gt;        &lt;char&gt; &lt;char&gt;     &lt;char&gt;\n#&gt;    1: MCID3111142965 International   Male Electrical\n#&gt;    2: MCID3111145102         White   Male Electrical\n#&gt;    3: MCID3111146537         Asian Female Electrical\n#&gt;    4: MCID3111146674         Asian   Male Electrical\n#&gt;    5: MCID3111150194         Black   Male Industrial\n#&gt;   ---                                               \n#&gt; 3260: MCID3112618553 International   Male Mechanical\n#&gt; 3261: MCID3112618574 International   Male Mechanical\n#&gt; 3262: MCID3112618976         White   Male Mechanical\n#&gt; 3263: MCID3112619484         White   Male Electrical\n#&gt; 3264: MCID3112641535         White   Male Mechanical\n\ncheck_equiv_frames(result_df, result_dt)\n#&gt; [1] TRUE\ncheck_equiv_frames(result_dt, result_tbl)\n#&gt; [1] TRUE\n\nComments\n\nbase R.\ndata.table.\ndplyr.",
    "crumbs": [
      "Shaping data 3 ways",
      "Multi-table transforms"
    ]
  },
  {
    "objectID": "data-shaping-04-multi-table-transforms.html#inner-join",
    "href": "data-shaping-04-multi-table-transforms.html#inner-join",
    "title": "Multi-table transforms",
    "section": "Inner join",
    "text": "Inner join\nAn inner join is a merge operation between two data frames that returns all observations (rows) from two data frames that match specified conditions in both.\nThe general forms of the inner join are:\n  # base R\n  merge(x, y, by, all = FALSE)\n\n  # data.table\n  y[x, j, on, nomatch = NULL]\n\n  # dplyr\n  inner_join(x, y, by)\nwhere\n\n\nx is a data frame, matching rows returned\n\ny is a data frame, matching rows returned\n\nby and on are the vectors of shared column names to merge by\n\nj (if used) selects columns from the joined data frame to retain\n\nTask. Join the CIP column from the degree data to the ever-enrolled dataset by ID, retaining only those students who completed a degree, i.e., IDs common to both data sets (inner join).\n\n# base R\nx &lt;- ever_df[, c(\"mcid\"), drop = FALSE]\nx &lt;- unique(x)\ny &lt;- degree_df[, c(\"mcid\", \"cip6\"), drop = FALSE]\nnames(y)[names(y) == \"cip6\"] &lt;- \"degree_CIP\"\nresult_df &lt;- merge(x, y, by = c(\"mcid\"), all = FALSE)\n\n\n# data.table\nx &lt;- ever_dt[, .(mcid)]\nx &lt;- unique(x)\ny &lt;- degree_dt[, .(mcid, degree_CIP = cip6)]\nresult_dt &lt;- y[x, , on = \"mcid\", nomatch = NULL]\n\n\n# dplyr\nx &lt;- select(ever_tbl, mcid) %&gt;%\n  distinct()\ny &lt;- select(degree_tbl, mcid, cip6) %&gt;%\n  rename(degree_CIP = cip6)\nresult_tbl &lt;- inner_join(x, y, by = join_by(mcid))\n\n\nresult_dt\n#&gt;                 mcid degree_CIP\n#&gt;               &lt;char&gt;     &lt;char&gt;\n#&gt;    1: MCID3111142965     141001\n#&gt;    2: MCID3111145102     141001\n#&gt;    3: MCID3111146537     141001\n#&gt;    4: MCID3111146674     141001\n#&gt;    5: MCID3111150194     143501\n#&gt;   ---                          \n#&gt; 4194: MCID3112618976     141901\n#&gt; 4195: MCID3112619484     141001\n#&gt; 4196: MCID3112641399     270301\n#&gt; 4197: MCID3112641535     141901\n#&gt; 4198: MCID3112698681     110701\n\ncheck_equiv_frames(result_df, result_dt)\n#&gt; [1] TRUE\ncheck_equiv_frames(result_dt, result_tbl)\n#&gt; [1] TRUE\n\nComments\n\nbase R.\ndata.table.\ndplyr.",
    "crumbs": [
      "Shaping data 3 ways",
      "Multi-table transforms"
    ]
  },
  {
    "objectID": "data-shaping-04-multi-table-transforms.html#references",
    "href": "data-shaping-04-multi-table-transforms.html#references",
    "title": "Multi-table transforms",
    "section": "References",
    "text": "References",
    "crumbs": [
      "Shaping data 3 ways",
      "Multi-table transforms"
    ]
  },
  {
    "objectID": "data-shaping-02-basic-transforms.html",
    "href": "data-shaping-02-basic-transforms.html",
    "title": "Basic transforms",
    "section": "",
    "text": "Image: Transformers by danjo paluska is licensed under CC BY 2.0\nUsing base R, data.table, and dplyr/tidyr to transform MIDFIELD data as needed for your analysis.\nIn this section we demonstrate adding and removing columns, editing column names, creating two new columns by splitting a character column, converting the class of a column, and recoding the values in a column.",
    "crumbs": [
      "Shaping data 3 ways",
      "Basic transforms"
    ]
  },
  {
    "objectID": "data-shaping-02-basic-transforms.html#setup",
    "href": "data-shaping-02-basic-transforms.html#setup",
    "title": "Basic transforms",
    "section": "Setup",
    "text": "Setup\nLoad packages.\n\nlibrary(\"midfielddata\")\nlibrary(\"data.table\")\nlibrary(\"dplyr\", warn.conflicts = FALSE)\nlibrary(\"tidyr\")\nlibrary(\"stringr\")\nlibrary(\"wrapr\")\n\nFormat data as described in the Introduction.\n\ndata(student, term, degree)\n\n\n# base R\nstudent_df &lt;- data.frame(student)\nterm_df &lt;- data.frame(term)\ndegree_df &lt;- data.frame(degree)\n\n\n# data.table\nstudent_dt &lt;- copy(student)\nterm_dt &lt;- copy(term)\ndegree_dt &lt;- copy(degree)\n\n\n# dplyr\nstudent_tbl &lt;- tibble(student)\nterm_tbl &lt;- tibble(term)\ndegree_tbl &lt;- tibble(degree)",
    "crumbs": [
      "Shaping data 3 ways",
      "Basic transforms"
    ]
  },
  {
    "objectID": "data-shaping-02-basic-transforms.html#adding-columns",
    "href": "data-shaping-02-basic-transforms.html#adding-columns",
    "title": "Basic transforms",
    "section": "Adding columns",
    "text": "Adding columns\nTask. Add a column to the student table for total SAT score.\n\ncolumns_we_want &lt;- c(\"mcid\", \"sat_math\", \"sat_verbal\", \"act_comp\")\n\n\n# base R\nresult_df &lt;- student_df[, columns_we_want, drop = FALSE]\nresult_df$sat_total &lt;- result_df$sat_math + result_df$sat_verbal\n\n\n# data.table\nresult_dt &lt;- student_dt[, ..columns_we_want]\nresult_dt[, sat_total := sat_math + sat_verbal]\n\n\n# dplyr\nresult_tbl &lt;- student_tbl %&gt;%\n  select(all_of(columns_we_want)) %&gt;%\n  mutate(sat_total = sat_math + sat_verbal)\n\n\nresult_dt\n#&gt;                  mcid sat_math sat_verbal act_comp sat_total\n#&gt;                &lt;char&gt;    &lt;num&gt;      &lt;num&gt;    &lt;num&gt;     &lt;num&gt;\n#&gt;     1: MCID3111142225       NA         NA       NA        NA\n#&gt;     2: MCID3111142283      560        230       NA       790\n#&gt;     3: MCID3111142290      510        380       NA       890\n#&gt;     4: MCID3111142294      640        460       NA      1100\n#&gt;     5: MCID3111142299      600        500       NA      1100\n#&gt;    ---                                                      \n#&gt; 97551: MCID3112898886      530        560       29      1090\n#&gt; 97552: MCID3112898890      570        580       25      1150\n#&gt; 97553: MCID3112898894      510        590       24      1100\n#&gt; 97554: MCID3112898895      420        590       32      1010\n#&gt; 97555: MCID3112898940      470        540       32      1010\n\ncheck_equiv_frames(result_df, result_dt)\n#&gt; [1] TRUE\ncheck_equiv_frames(result_dt, result_tbl)\n#&gt; [1] TRUE\n\nComments\n\nbase R. df$new_col creates the new column.\ndata.table. := alters or creates columns “in place”. The data.table at hand gets altered instead of a new one being created.\ndplyr. New columns are created with mutate().",
    "crumbs": [
      "Shaping data 3 ways",
      "Basic transforms"
    ]
  },
  {
    "objectID": "data-shaping-02-basic-transforms.html#removing-columns",
    "href": "data-shaping-02-basic-transforms.html#removing-columns",
    "title": "Basic transforms",
    "section": "Removing columns",
    "text": "Removing columns\nIn previous examples, when selecting some columns we have implicitly removed every column not selected (if any). Here we explicitly select the columns to be removed.\nTask. Using the results from the previous example, remove the SAT math and verbal columns.\n\n# base R\nresult_df[c(\"sat_math\", \"sat_verbal\")] &lt;- NULL\n\n\n# data.table\nresult_dt[, c(\"sat_math\", \"sat_verbal\") := NULL]\n\n\n# dplyr\nresult_tbl &lt;- result_tbl %&gt;%\n  select(-sat_math, -sat_verbal)\n\n\nresult_dt\n#&gt;                  mcid act_comp sat_total\n#&gt;                &lt;char&gt;    &lt;num&gt;     &lt;num&gt;\n#&gt;     1: MCID3111142225       NA        NA\n#&gt;     2: MCID3111142283       NA       790\n#&gt;     3: MCID3111142290       NA       890\n#&gt;     4: MCID3111142294       NA      1100\n#&gt;     5: MCID3111142299       NA      1100\n#&gt;    ---                                  \n#&gt; 97551: MCID3112898886       29      1090\n#&gt; 97552: MCID3112898890       25      1150\n#&gt; 97553: MCID3112898894       24      1100\n#&gt; 97554: MCID3112898895       32      1010\n#&gt; 97555: MCID3112898940       32      1010\n\ncheck_equiv_frames(result_df, result_dt)\n#&gt; [1] TRUE\ncheck_equiv_frames(result_dt, result_tbl)\n#&gt; [1] TRUE\n\nComments\n\nbase R.\ndata.table. Use a vector of column names and := to remove the columns “in place”.\ndplyr. Use select() with minus signs.",
    "crumbs": [
      "Shaping data 3 ways",
      "Basic transforms"
    ]
  },
  {
    "objectID": "data-shaping-02-basic-transforms.html#editing-column-names",
    "href": "data-shaping-02-basic-transforms.html#editing-column-names",
    "title": "Basic transforms",
    "section": "Editing column names",
    "text": "Editing column names\nTask. Using the results from the previous example, rename the columns.\nIn each case, we take care to explicitly match old and new names.\n\n# base R\nnames(result_df)[names(result_df) == \"mcid\"] &lt;- \"Student\"\nnames(result_df)[names(result_df) == \"sat_total\"] &lt;- \"SAT\"\nnames(result_df)[names(result_df) == \"act_comp\"] &lt;- \"ACT\"\n\n\n# data.table\nsetnames(result_dt,\n  old = c(\"mcid\", \"sat_total\", \"act_comp\"),\n  new = c(\"Student\", \"SAT\", \"ACT\")\n)\n\n\n# dplyr\nresult_tbl &lt;- result_tbl %&gt;%\n    rename(Student = mcid, SAT = sat_total, ACT = act_comp)\n\n\nresult_dt\n#&gt;               Student   ACT   SAT\n#&gt;                &lt;char&gt; &lt;num&gt; &lt;num&gt;\n#&gt;     1: MCID3111142225    NA    NA\n#&gt;     2: MCID3111142283    NA   790\n#&gt;     3: MCID3111142290    NA   890\n#&gt;     4: MCID3111142294    NA  1100\n#&gt;     5: MCID3111142299    NA  1100\n#&gt;    ---                           \n#&gt; 97551: MCID3112898886    29  1090\n#&gt; 97552: MCID3112898890    25  1150\n#&gt; 97553: MCID3112898894    24  1100\n#&gt; 97554: MCID3112898895    32  1010\n#&gt; 97555: MCID3112898940    32  1010\n\ncheck_equiv_frames(result_df, result_dt)\n#&gt; [1] TRUE\ncheck_equiv_frames(result_dt, result_tbl)\n#&gt; [1] TRUE\n\nComments\n\nbase R. While other approaches work too, this approach ensures that old and new names are explicitly matched.\ndata.table. setnames() edits the column names in place.\ndplyr. rename() uses new_name = old_name syntax.",
    "crumbs": [
      "Shaping data 3 ways",
      "Basic transforms"
    ]
  },
  {
    "objectID": "data-shaping-02-basic-transforms.html#split-a-character-column",
    "href": "data-shaping-02-basic-transforms.html#split-a-character-column",
    "title": "Basic transforms",
    "section": "Split a character column",
    "text": "Split a character column\nTask. In the term data, create new columns for year YYYY and term code T by splitting the character term column.\nIn each system, we use the base R substr() function to split the term character value into a 4-character year in one new column and a 1-character term-code in a new second column. We also drop rows with missing values (if any).\n\ncolumns_we_want &lt;- c(\"mcid\", \"term\")\n\n\n# base R\nDF &lt;- term_df[, columns_we_want, drop = FALSE]\nDF$year &lt;- substr(DF$term, 1, 4)\nDF$term_code &lt;- substr(DF$term, 5, 5)\nresult_df &lt;- na.omit(DF)\n\n\n# data.table\nDT &lt;- term_dt[, ..columns_we_want]\nDT[, c(\"year\", \"term_code\") := .(substr(term, 1, 4), substr(term, 5, 5))]\nresult_dt &lt;- na.omit(DT)\n\n\n# dplyr\nresult_tbl &lt;- term_tbl %&gt;%\n  select(mcid, term) %&gt;%\n  mutate(year = substr(term, 1, 4), term_code = substr(term, 5, 5)) %&gt;%\n  drop_na()\n\n\noptions(datatable.print.topn = 5)\nresult_dt\n#&gt;                   mcid   term   year term_code\n#&gt;                 &lt;char&gt; &lt;char&gt; &lt;char&gt;    &lt;char&gt;\n#&gt;      1: MCID3111142225  19881   1988         1\n#&gt;      2: MCID3111142283  19881   1988         1\n#&gt;      3: MCID3111142283  19883   1988         3\n#&gt;      4: MCID3111142283  19885   1988         5\n#&gt;      5: MCID3111142283  19891   1989         1\n#&gt;     ---                                       \n#&gt; 639911: MCID3112898886  20181   2018         1\n#&gt; 639912: MCID3112898890  20181   2018         1\n#&gt; 639913: MCID3112898894  20181   2018         1\n#&gt; 639914: MCID3112898895  20181   2018         1\n#&gt; 639915: MCID3112898940  20181   2018         1\n\ncheck_equiv_frames(result_df, result_dt)\n#&gt; [1] TRUE\ncheck_equiv_frames(result_dt, result_tbl)\n#&gt; [1] TRUE\n\nComments\n\nbase R.\ndata.table.\ndplyr.",
    "crumbs": [
      "Shaping data 3 ways",
      "Basic transforms"
    ]
  },
  {
    "objectID": "data-shaping-02-basic-transforms.html#convert-column-class",
    "href": "data-shaping-02-basic-transforms.html#convert-column-class",
    "title": "Basic transforms",
    "section": "Convert column class",
    "text": "Convert column class\nTask. Using the results from the previous example, convert character year to numerical class.\n\n# base R\nresult_df$year &lt;- as.double(result_df$year)\n\n\n# data.table\nresult_dt[, year := as.double(year)]\n\n\n# dplyr\nresult_tbl &lt;- result_tbl %&gt;%\n  mutate(year = as.double(year))\n\n\nresult_dt\n#&gt;                   mcid   term  year term_code\n#&gt;                 &lt;char&gt; &lt;char&gt; &lt;num&gt;    &lt;char&gt;\n#&gt;      1: MCID3111142225  19881  1988         1\n#&gt;      2: MCID3111142283  19881  1988         1\n#&gt;      3: MCID3111142283  19883  1988         3\n#&gt;      4: MCID3111142283  19885  1988         5\n#&gt;      5: MCID3111142283  19891  1989         1\n#&gt;     ---                                      \n#&gt; 639911: MCID3112898886  20181  2018         1\n#&gt; 639912: MCID3112898890  20181  2018         1\n#&gt; 639913: MCID3112898894  20181  2018         1\n#&gt; 639914: MCID3112898895  20181  2018         1\n#&gt; 639915: MCID3112898940  20181  2018         1\n\ncheck_equiv_frames(result_df, result_dt)\n#&gt; [1] TRUE\ncheck_equiv_frames(result_dt, result_tbl)\n#&gt; [1] TRUE\n\nComments\n\nbase R.\ndata.table.\ndplyr.",
    "crumbs": [
      "Shaping data 3 ways",
      "Basic transforms"
    ]
  },
  {
    "objectID": "data-shaping-02-basic-transforms.html#recode-column-values",
    "href": "data-shaping-02-basic-transforms.html#recode-column-values",
    "title": "Basic transforms",
    "section": "Recode column values",
    "text": "Recode column values\nWhen recoding the values of a column we have a choice: we can recode in place, eliminating the original values entirely, or we can add new column with the new coding. In this first example, we add a column.\nAdd a column with the recoded values\nTask. Using the results from the previous example, add a column that re-codes the term-codes from numbers to academic terms “Fall”, “Winter”, etc. The existing column is term_code; the new column is term_name.\n\n# base R\nresult_df &lt;- within(result_df, {\n    term_name &lt;- NA\n    term_name[term_code == \"1\"] &lt;- \"Fall\"\n    term_name[term_code == \"2\"] &lt;- \"Winter\"\n    term_name[term_code == \"3\"] &lt;- \"Spring\"\n    term_name[term_code == \"4\"] &lt;- \"Summer 1\"\n    term_name[term_code == \"5\"] &lt;- \"Summer 2\"\n    term_name[term_code == \"6\"] &lt;- \"Summer 3\"\n})\n\n\n# data.table\nresult_dt[, term_name := fcase(\n  term_code == \"1\", \"Fall\",\n  term_code == \"2\", \"Winter\",\n  term_code == \"3\", \"Spring\",\n  term_code == \"4\", \"Summer 1\",\n  term_code == \"5\", \"Summer 2\",\n  term_code == \"6\", \"Summer 3\"\n)]\n\n\n# dplyr\nresult_tbl &lt;- result_tbl %&gt;%\n  mutate(term_name = case_match(\n    term_code,\n    \"1\" ~ \"Fall\",\n    \"2\" ~ \"Winter\",\n    \"3\" ~ \"Spring\",\n    \"4\" ~ \"Summer 1\",\n    \"5\" ~ \"Summer 2\",\n    \"6\" ~ \"Summer 3\"\n  ))\n\n\nresult_dt\n#&gt;                   mcid   term  year term_code term_name\n#&gt;                 &lt;char&gt; &lt;char&gt; &lt;num&gt;    &lt;char&gt;    &lt;char&gt;\n#&gt;      1: MCID3111142225  19881  1988         1      Fall\n#&gt;      2: MCID3111142283  19881  1988         1      Fall\n#&gt;      3: MCID3111142283  19883  1988         3    Spring\n#&gt;      4: MCID3111142283  19885  1988         5  Summer 2\n#&gt;      5: MCID3111142283  19891  1989         1      Fall\n#&gt;     ---                                                \n#&gt; 639911: MCID3112898886  20181  2018         1      Fall\n#&gt; 639912: MCID3112898890  20181  2018         1      Fall\n#&gt; 639913: MCID3112898894  20181  2018         1      Fall\n#&gt; 639914: MCID3112898895  20181  2018         1      Fall\n#&gt; 639915: MCID3112898940  20181  2018         1      Fall\n\ncheck_equiv_frames(result_df, result_dt)\n#&gt; [1] TRUE\ncheck_equiv_frames(result_dt, result_tbl)\n#&gt; [1] TRUE\n\nComments\n\nbase R. within() is similar to with() but allows us to modify a data frame. We create the new column with term_name &lt;- NA then systematically edit its values based on the values in term_code.\ndata.table. term_name is created using := then fcase() assigns its values based on logical expressions operating on term_code.\ndplyr. term_name is created using mutate() then case_match() assigns its values by finding matches to the term_code values.\nRecode strings in place\nHere, we partially recode string values.\nTask. In the degree data, shorten the values in the degree column by substituting “BA” for “Bachelor of Arts” and “BS” for Bachelor of Science” to make the printout more readable.\nSome of the degree values are recorded as “Bachelor Science” instead of “Bachelor of Science”, so to simplify the process the first thing we do is remove all instances of the preposition “of”. We also select three columns to make the printout more readable.\n\ncolumns_we_want &lt;- c(\"mcid\", \"term_degree\", \"degree\")\n\n\n# base R\nresult_df &lt;- degree_df[, columns_we_want, drop = FALSE]\nresult_df$degree &lt;- gsub(\" of\", \"\", result_df$degree)\nresult_df$degree &lt;- sub(\"Bachelor Science\", \"BS\", result_df$degree)\nresult_df$degree &lt;- sub(\"Bachelor Arts\", \"BA\", result_df$degree)\nresult_df$degree &lt;- sub(\"Bachelor Fine Arts\", \"BFA\", result_df$degree)\n\n\n# data.table\nresult_dt &lt;- degree_dt[, ..columns_we_want]\nresult_dt[, degree := gsub(\" of\", \"\", degree)]\nresult_dt[, degree := sub(\"Bachelor Science\", \"BS\", degree)]\nresult_dt[, degree := str_replace(degree, \"Bachelor Arts\", \"BA\")]\nresult_dt[, degree := str_replace(degree, \"Bachelor Fine Arts\", \"BFA\")]\n\n\n# dplyr/stringr\nresult_tbl &lt;- degree_tbl %&gt;%\n select(all_of(columns_we_want)) %&gt;%\n mutate(degree = str_replace_all(degree, \" of\", \"\")) %&gt;% \n mutate(degree = str_replace(degree, \"Bachelor Science\", \"BS\")) %&gt;%\n mutate(degree = str_replace(degree, \"Bachelor Arts\", \"BA\")) %&gt;%\n mutate(degree = str_replace(degree, \"Bachelor Fine Arts\", \"BFA\"))\n\n\nresult_dt\n#&gt;                  mcid term_degree                                  degree\n#&gt;                &lt;char&gt;      &lt;char&gt;                                  &lt;char&gt;\n#&gt;     1: MCID3111142225       19881            BS in Electrical Engineering\n#&gt;     2: MCID3111142290       19921            BS in Electrical Engineering\n#&gt;     3: MCID3111142294       19903            BS in Electrical Engineering\n#&gt;     4: MCID3111142299       19921            BS in Electrical Engineering\n#&gt;     5: MCID3111142689       19913                        BA in Journalism\n#&gt;    ---                                                                   \n#&gt; 49661: MCID3112829602       20173  BA in Political Science and Government\n#&gt; 49662: MCID3112831015       20181                         BA in Geography\n#&gt; 49663: MCID3112839623       20181                       BS in Linguistics\n#&gt; 49664: MCID3112845220       20181                       BS in Mathematics\n#&gt; 49665: MCID3112845673       20174 BS in Speech Communication and Rhetoric\n\ncheck_equiv_frames(result_df, result_dt)\n#&gt; [1] TRUE\ncheck_equiv_frames(result_dt, result_tbl)\n#&gt; [1] TRUE\n\nComments\n\nbase R. gsub() replaces all matches in a string; sub() replaces the first match only.\ndata.table. data.table does not have its own string manipulation functions, so here we show two operations using base R and two operations using stringr.\ndplyr/stringr. str_replace_all() replaces all matches in a string; str_replace() replaces the first match only.",
    "crumbs": [
      "Shaping data 3 ways",
      "Basic transforms"
    ]
  },
  {
    "objectID": "data-shaping-02-basic-transforms.html#references",
    "href": "data-shaping-02-basic-transforms.html#references",
    "title": "Basic transforms",
    "section": "References",
    "text": "References",
    "crumbs": [
      "Shaping data 3 ways",
      "Basic transforms"
    ]
  },
  {
    "objectID": "data-shaping-00-introduction.html",
    "href": "data-shaping-00-introduction.html",
    "title": "Shaping MIDFIELD data three ways",
    "section": "",
    "text": "Image: Workshop by Daniel Mee is licensed under CC BY 2.0\nUsing base R, data.table, and dplyr/tidyr to transform MIDFIELD data as needed for your analysis.\nIn this series of articles, we hope to address the needs of users who would prefer to use base R or dplyr syntax in lieu of the data.table syntax that appears everywhere else in midfieldr tutorials. We illustrate common data shaping tasks three ways: using base R, data.table, and dplyr systems.\nSources for translating among the three systems include (atrebas, 2019; Gimond, 2019; Hajnala, 2018; Mercer, 2020; and Vaughan, 2023). In particular, our outline is roughly based on Chapter 5 of (Zumel & Mount, 2020).",
    "crumbs": [
      "Shaping data 3 ways",
      "Introduction"
    ]
  },
  {
    "objectID": "data-shaping-00-introduction.html#getting-started",
    "href": "data-shaping-00-introduction.html#getting-started",
    "title": "Shaping MIDFIELD data three ways",
    "section": "Getting started",
    "text": "Getting started\nProject organization. If you are writing your own scripts to follow along, our tutorials assume that you:\n\nAre working within an RStudio Project\n\nHave set up a directory structure with folders for data and scripts.\n\n\nPackages. The table lists the packages used in the data shaping articles overall. You may wish to install these packages before starting.\n\n\n\n\n\nTable 1: Packages in the data shaping articles\n\npackages\nused for\n\n\n\nmidfielddata\nstudent records practice data\n\n\ndata.table\nmanipulating data\n\n\ndplyr\nmanipulating data\n\n\ntidyr\nmanipulating data\n\n\nreadr\nimport data\n\n\nwrapr\ntools for writing and debugging R code\n\n\ncdata\nreshaping transforms\n\n\nggplot2\ncreating charts\n\n\n\n\n\n\n\nWe load the packages used in an article as one of the first code chunks, as shown below. You can copy any code chunk by clicking on the “Copy to clipboard” icon .\n\n# packages used in this article\nlibrary(\"data.table\")\nlibrary(\"dplyr\", warn.conflicts = FALSE)\nlibrary(\"midfielddata\")\nlibrary(\"readr\")\nlibrary(\"wrapr\", warn.conflicts = FALSE)",
    "crumbs": [
      "Shaping data 3 ways",
      "Introduction"
    ]
  },
  {
    "objectID": "data-shaping-00-introduction.html#data",
    "href": "data-shaping-00-introduction.html#data",
    "title": "Shaping MIDFIELD data three ways",
    "section": "Data",
    "text": "Data\nLoad the datasets from midfielddata. View data dictionaries via ?student, ?term, and ?degree.\n\ndata(student, term, degree)\n\nHave a quick look at each one using dplyr glimpse().\n\nglimpse(student)\n#&gt; Rows: 97,555\n#&gt; Columns: 13\n#&gt; $ mcid           &lt;chr&gt; \"MCID3111142225\", \"MCID3111142283\", \"MCID3111142290\", \"…\n#&gt; $ institution    &lt;chr&gt; \"Institution B\", \"Institution J\", \"Institution J\", \"Ins…\n#&gt; $ transfer       &lt;chr&gt; \"First-Time Transfer\", \"First-Time Transfer\", \"First-Ti…\n#&gt; $ hours_transfer &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n#&gt; $ race           &lt;chr&gt; \"Asian\", \"Asian\", \"Asian\", \"Asian\", \"Asian\", \"Asian\", \"…\n#&gt; $ sex            &lt;chr&gt; \"Male\", \"Female\", \"Male\", \"Male\", \"Male\", \"Male\", \"Male…\n#&gt; $ age_desc       &lt;chr&gt; \"Under 25\", \"Under 25\", \"Under 25\", \"Under 25\", \"Under …\n#&gt; $ us_citizen     &lt;chr&gt; \"Yes\", \"Yes\", \"Yes\", \"Yes\", \"Yes\", \"Yes\", \"Yes\", \"Yes\",…\n#&gt; $ home_zip       &lt;chr&gt; NA, \"22020\", \"23233\", \"20853\", \"22003\", \"23234\", \"24148…\n#&gt; $ high_school    &lt;chr&gt; NA, NA, \"471872\", NA, \"470080\", \"471877\", NA, NA, NA, N…\n#&gt; $ sat_math       &lt;dbl&gt; NA, 560, 510, 640, 600, 570, 480, NA, NA, NA, 520, 430,…\n#&gt; $ sat_verbal     &lt;dbl&gt; NA, 230, 380, 460, 500, 530, 530, NA, NA, NA, 490, 490,…\n#&gt; $ act_comp       &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n\nglimpse(term)\n#&gt; Rows: 639,915\n#&gt; Columns: 13\n#&gt; $ mcid                &lt;chr&gt; \"MCID3111142225\", \"MCID3111142283\", \"MCID311114228…\n#&gt; $ institution         &lt;chr&gt; \"Institution B\", \"Institution J\", \"Institution J\",…\n#&gt; $ term                &lt;chr&gt; \"19881\", \"19881\", \"19883\", \"19885\", \"19891\", \"1989…\n#&gt; $ cip6                &lt;chr&gt; \"140901\", \"240102\", \"240102\", \"190601\", \"190601\", …\n#&gt; $ level               &lt;chr&gt; \"01 First-year\", \"01 First-year\", \"01 First-year\",…\n#&gt; $ standing            &lt;chr&gt; \"Good Standing\", \"Academic Probation\", \"Academic P…\n#&gt; $ coop                &lt;chr&gt; \"No\", \"No\", \"No\", \"No\", \"No\", \"No\", \"No\", \"No\", \"N…\n#&gt; $ hours_term          &lt;dbl&gt; 7, 6, 12, 6, 6, 6, 6, 18, 15, 14, 13, 3, 13, 3, 3,…\n#&gt; $ hours_term_attempt  &lt;dbl&gt; 7, 6, 12, 6, 6, 6, 6, 18, 18, 14, 13, 3, 13, 3, 3,…\n#&gt; $ hours_cumul         &lt;dbl&gt; 7, 6, 18, 24, 30, 36, 42, 63, 78, 14, 27, 60, 82, …\n#&gt; $ hours_cumul_attempt &lt;dbl&gt; 7, 6, 18, 24, 30, 36, 42, 63, 81, 14, 27, 60, 82, …\n#&gt; $ gpa_term            &lt;dbl&gt; 2.56, 1.85, 1.93, 2.15, 1.85, 1.20, 1.85, 2.33, 2.…\n#&gt; $ gpa_cumul           &lt;dbl&gt; 2.56, 1.85, 1.90, 1.96, 1.94, 1.82, 1.82, 1.98, 2.…\n\nglimpse(degree)\n#&gt; Rows: 49,665\n#&gt; Columns: 5\n#&gt; $ mcid        &lt;chr&gt; \"MCID3111142225\", \"MCID3111142290\", \"MCID3111142294\", \"MCI…\n#&gt; $ institution &lt;chr&gt; \"Institution B\", \"Institution J\", \"Institution J\", \"Instit…\n#&gt; $ term_degree &lt;chr&gt; \"19881\", \"19921\", \"19903\", \"19921\", \"19913\", \"19883\", \"199…\n#&gt; $ cip6        &lt;chr&gt; \"141001\", \"141001\", \"141001\", \"141001\", \"090401\", \"141901\"…\n#&gt; $ degree      &lt;chr&gt; \"Bachelor of Science in Electrical Engineering\", \"Bachelor…",
    "crumbs": [
      "Shaping data 3 ways",
      "Introduction"
    ]
  },
  {
    "objectID": "data-shaping-00-introduction.html#three-systems",
    "href": "data-shaping-00-introduction.html#three-systems",
    "title": "Shaping MIDFIELD data three ways",
    "section": "Three systems",
    "text": "Three systems\nWe format the data frames used in our examples three ways, once for each system: base R, data.table, and dplyr. The table shows the naming convention we use to distinguish the different forms.\n\n\n\n\n\nTable 2: Dataset naming convention\n\nsystem\nsuffix\nexample\nclass\n\n\n\nbase R\n_df\nstudent_df\ndata.frame\n\n\ndata.table\n_dt\nstudent_dt\ndata.frame, data.table\n\n\ndplyr\n_tbl\nstudent_tbl\ndata.frame, tbl_df, tbl\n\n\n\n\n\n\n\nCode chunks that do the same task are grouped and color coded by system, as illustrated below. Here, we prepare three versions of the student table, one per system.\n\n# base R\nstudent_df &lt;- data.frame(student)\n\n\n# data.table\nstudent_dt &lt;- copy(student)\n\n\n# dplyr\nstudent_tbl &lt;- tibble(student)\n\n\nA group of code chunks is typically followed by a comment section. For example, commenting on the code chunks above:\nComments\n\nbase R. data.frame() converts the dataset to class data.frame, removing attributes associated with the default data.table format.\ndata.table. copy() creates a new memory address for the new object. In data.table, if we don’t “copy”, any subsequent operations on student_dt are applied “by reference” to the original student table.\ndplyr. tibble() converts the dataset to class tbl_df, removing attributes associated with the default data.table format.",
    "crumbs": [
      "Shaping data 3 ways",
      "Introduction"
    ]
  },
  {
    "objectID": "data-shaping-00-introduction.html#method",
    "href": "data-shaping-00-introduction.html#method",
    "title": "Shaping MIDFIELD data three ways",
    "section": "Method",
    "text": "Method\n\nWe want to make each operation as transparent as possible for the R novice. Hence we generally write a line of code to do one thing, avoiding combined or nested operations and introducing intermediate or temporary variables that get overwritten before reaching a desired result, e.g., DF for an intermediate data.frame, DT for an intermediate data.table, vec for an intermediate vector, etc.\nIn the same vein, we sometimes use intermediate variables for indexing, e.g. rows_we_want, columns_we_want, order_index, etc.\nIn general, we show only one approach per task per system, offering what we think is the best choice for our audience. In R there are usually multiple approaches for the same task and resources for exploring other methods are readily available.\nWe follow the convention of chaining dplyr steps with the magrittr pipe %&gt;% (though assigning temporary variables would work just as well). We do not generally use the piping or chaining operations available in base R and data.table.\nIn each example, results are manipulated such that base R, data.table, and dplyr yield the same form (usually a data frame) with the same variables and observations. In most cases, we compare data frame equivalence with wrapr::check_equiv_frames() which converts its arguments to data.frame class and reorders columns and rows.\n\n\ncheck_equiv_frames(student_df, student_dt)\n#&gt; [1] TRUE\ncheck_equiv_frames(student_dt, student_tbl)\n#&gt; [1] TRUE\n\n\nIn cases where re-ordering rows or columns is part of the task, we compare results by using base R all.equal() instead of check_equiv_frames(). By setting the check.attributes argument to FALSE, data frame attributes (other than column names) are ignored, for example, row.names (if any) and class (e.g., tbl or data.table).\n\n\nall.equal(student_df, student_dt, check.attributes = FALSE)\n#&gt; [1] TRUE\nall.equal(student_dt, student_tbl, check.attributes = FALSE)\n#&gt; [1] TRUE",
    "crumbs": [
      "Shaping data 3 ways",
      "Introduction"
    ]
  },
  {
    "objectID": "data-shaping-00-introduction.html#download-and-write-csv-files",
    "href": "data-shaping-00-introduction.html#download-and-write-csv-files",
    "title": "Shaping MIDFIELD data three ways",
    "section": "Download and write CSV files",
    "text": "Download and write CSV files\nIn addition to the datasets from the midfielddata package, we have some prepared data to download from the Institute repository (an Internet connection is required).\nDownload and write a CSV file to your RStudio project data directory.\n\n# run me first\ndata_url &lt;- \"https://raw.githubusercontent.com/MIDFIELDR/2024-midfield-institute/main/data/case_blocs.csv\"\n\nOne of these code chunks can be copied and run in your Console window as these lines only have to be run once. We write the data file to the data directory of your R project with file paths relative to the R project main directory.\n\n# base R\ncase_blocs &lt;- read.csv(data_url)\nwrite.csv(case_blocs, file = \"data/case_blocs.csv\", row.names = FALSE)\n\n\n# data.table\ncase_blocs &lt;- fread(data_url)\nfwrite(case_blocs, file = \"data/case_blocs.csv\")\n\n\n# readr\ncase_blocs &lt;- read_csv(data_url, show_col_types = FALSE)\nwrite_csv(case_blocs, file = \"data/case_blocs.csv\")\n\nComments\n\nbase R. write.csv() set row.names to FALSE for consistency with other two systems. All three systems expect the same first two arguments, the data frame and the file path.\ndata.table. fwrite() Similar to write.csv() but faster. Default row.names is FALSE.\ndplyr. write_csv() also faster than write.csv(). Default row.names is FALSE.",
    "crumbs": [
      "Shaping data 3 ways",
      "Introduction"
    ]
  },
  {
    "objectID": "data-shaping-00-introduction.html#read-csv-files",
    "href": "data-shaping-00-introduction.html#read-csv-files",
    "title": "Shaping MIDFIELD data three ways",
    "section": "Read CSV files",
    "text": "Read CSV files\nImport the file you just saved.\n\n# base R\ncase_blocs_df &lt;- read.csv(\"data/case_blocs.csv\")\n\n\n# data.table\ncase_blocs_dt &lt;- fread(\"data/case_blocs.csv\")\n\n\n# readr\ncase_blocs_tbl &lt;- read_csv(\"data/case_blocs.csv\", show_col_types = FALSE)\n\n\ncase_blocs_dt\n#&gt;                  mcid    program peer_group\n#&gt;                &lt;char&gt;     &lt;char&gt;     &lt;char&gt;\n#&gt;     1: MCID3111142965 Electrical   starters\n#&gt;     2: MCID3111145102 Electrical   starters\n#&gt;     3: MCID3111150194 Industrial   starters\n#&gt;     4: MCID3111156083 Electrical   starters\n#&gt;     5: MCID3111156325 Electrical   starters\n#&gt;    ---                                     \n#&gt; 12966: MCID3112618553 Mechanical  graduates\n#&gt; 12967: MCID3112618574 Mechanical  graduates\n#&gt; 12968: MCID3112618976 Mechanical  graduates\n#&gt; 12969: MCID3112619484 Electrical  graduates\n#&gt; 12970: MCID3112641535 Mechanical  graduates\n\ncheck_equiv_frames(case_blocs_df, case_blocs_dt)\n#&gt; [1] TRUE\ncheck_equiv_frames(case_blocs_dt, case_blocs_tbl)\n#&gt; [1] TRUE\n\nComments\n\nread.csv(), fread(), and read_csv() have a large number of arguments for controlling the input. Some of the most commonly encountered are colClasses (base R and data.table) or col_types (dplyr) to specify the class of a column; skip a number of lines before reading data; and header (base R and data.table) or col_names (dplyr) to use the first row of input as column names.\nread.csv(), fread(), and read_csv() were also used earlier with a URL as the argument to download the supplemental data.",
    "crumbs": [
      "Shaping data 3 ways",
      "Introduction"
    ]
  },
  {
    "objectID": "data-shaping-00-introduction.html#references",
    "href": "data-shaping-00-introduction.html#references",
    "title": "Shaping MIDFIELD data three ways",
    "section": "References",
    "text": "References\n\n\natrebas. (2019). A data.table and dplyr tour. https://atrebas.github.io/post/2019-03-03-datatable-dplyr/\n\n\nGimond, M. (2019). base vs. tidyverse vs. data.table. https://mgimond.github.io/rug_2019_12/Index.html\n\n\nHajnala, J. (2018). Data subsetting and manipulation with base R. https://jozef.io/r002-data-manipulation/\n\n\nMercer, J. (2020). Base R, the tidyverse, and data.table: A comparison of R dialects to wrangle your data. https://tinyurl.com/yy544udn\n\n\nVaughan, D. (2023). dplyr &lt;=&gt; base R. https://dplyr.tidyverse.org/articles/base.html\n\n\nZumel, N., & Mount, J. (2020). Practical Data Science with R (2nd ed.). Manning Publications Co.",
    "crumbs": [
      "Shaping data 3 ways",
      "Introduction"
    ]
  },
  {
    "objectID": "data-shaping-00-introduction.html#appendix",
    "href": "data-shaping-00-introduction.html#appendix",
    "title": "Shaping MIDFIELD data three ways",
    "section": "Appendix",
    "text": "Appendix\nThe R and package version numbers (as of the most recent update) are:\n\nR.version$version.string\n#&gt; [1] \"R version 4.4.1 (2024-06-14 ucrt)\"\npackageVersion(\"midfielddata\")\n#&gt; [1] '0.2.1'\npackageVersion(\"data.table\")\n#&gt; [1] '1.16.0'\npackageVersion(\"dplyr\")\n#&gt; [1] '1.1.4'\npackageVersion(\"tidyr\")\n#&gt; [1] '1.3.1'\npackageVersion(\"readr\")\n#&gt; [1] '2.1.5'\npackageVersion(\"wrapr\")\n#&gt; [1] '2.1.0'\npackageVersion(\"cdata\")\n#&gt; [1] '1.2.1'\npackageVersion(\"ggplot2\")\n#&gt; [1] '3.5.1'",
    "crumbs": [
      "Shaping data 3 ways",
      "Introduction"
    ]
  },
  {
    "objectID": "chart-basics.html",
    "href": "chart-basics.html",
    "title": "R chart basics",
    "section": "",
    "text": "Figure from: Richard Layton, Stacked-bar alternatives , https://graphdr.github.io/data-stories/posts/2022-01-14-stacked-bar-alternatives/\nUsing ggplot2 to create charts in R.\nLicense. This material is adapted from Getting started in R: Tinyverse edition by Bashir and Eddelbuettel (2018) which was licensed under CC BY-SA by ilustat. This adaptation and extension, R chart basics by Richard Layton, is licensed under CC BY-SA 2.0.",
    "crumbs": [
      "Tutorial links",
      "R chart basics"
    ]
  },
  {
    "objectID": "chart-basics.html#preface",
    "href": "chart-basics.html#preface",
    "title": "R chart basics",
    "section": "Preface",
    "text": "Preface\nThe rationale for using the ggplot2 package instead of other R graphics environments (e.g., lattice, base R, or grid graphics) is nicely summarized by Zumel and Mount—it “excels at combining multiple graphical elements together” even though “its syntax can take some getting used to” (Zumel & Mount, 2020, p. 60). They raise three key points:\n\nGraphs in ggplot2 are defined only on data frames. The variables from the data frame—assigned to the x-axis, the y-axis, or to the color or size of a data marker—are called aesthetics, declared using the aes() function.\nThe ggplot() function declares the graph object; its arguments can include the data frame of interest and the aesthetics. The ggplot() function doesn’t itself produce a visualization; visualizations are produced by layers.\nLayers produce the plots and plot transformations and are added to a graph object using the + operator. Each layer can also take a data frame and aesthetics as arguments, in addition to layer-specific parameters. Example of layers are geom_point() for a scatterplot and geom_line() for a line plot.\n\nBefore starting. Our tutorials assume that you\n\nHave completed the Before you arrive instructions\nHave completed the R basics guide\n\nStart your R session by launching the RStudio project you created, e.g., midfield-institute-2024.Rproj. If you are in your RStudio project, the project name appears in the upper left corner of the RStudio window, e.g.,\n\nAnd based on the work you did in the Before you arrive session, your project directory should have three folders:",
    "crumbs": [
      "Tutorial links",
      "R chart basics"
    ]
  },
  {
    "objectID": "chart-basics.html#getting-started",
    "href": "chart-basics.html#getting-started",
    "title": "R chart basics",
    "section": "Getting started",
    "text": "Getting started\nStart a new script. I recommend that you start a new script for this segment.\n\nUse File &gt; New File &gt; R Script to create a new R script\n\nFile &gt; Save As… to name the file (we suggest 02-chart-basics.R), then save it to the scripts directory\nAt the top of the script, add a minimal header, something like:\n\n\n# R chart basics\n# your name  \n# date \n\n\nUse library() to load packages used in the script.\n\n\n# load packages\nlibrary(\"ggplot2\")\nlibrary(\"data.table\")\n\n# set data.table printout options\noptions(\n  datatable.print.nrows = 20,\n  datatable.print.topn = 5,\n  datatable.print.class = TRUE\n)\n\nReminder: In a code chunk like the one above, you can click on the Copy to Clipboard icon  in the upper right corner to enable quick copy and paste from this document to your script.\nUse your script throughout the tutorial. When a new chunk of code is given,\n\nCopy the line(s) of code into your script, save, and run.\n\nCheck your result by comparing it to the result in the tutorial.\nCheck what you’ve learned using the Your turn exercises.",
    "crumbs": [
      "Tutorial links",
      "R chart basics"
    ]
  },
  {
    "objectID": "chart-basics.html#data",
    "href": "chart-basics.html#data",
    "title": "R chart basics",
    "section": "Data",
    "text": "Data\nIntroduction. R comes with many datasets installed. We’ll use the ChickWeight data set to cover some basic data manipulation to prepare the data for graphing.\nThe help page for ChickWeight summarizes the experiment from which the data were collected,\n\nThe body weights of the chicks were measured at birth and every second day thereafter until day 20. They were also measured on day 21. There were four groups of chicks on different protein diets.”\n\nYou can view the help page by running,\nhelp(\"ChickWeight\")\nThere are 578 observations (rows) and 4 variables (columns). Recall that names are case-sensitive—weight is lowercase, the other variables are capitalized.\n\n\nChick: unique ID for each chick.\n\nDiet: one of four protein diets.\n\nTime: number of days since birth.\n\nweight: body weight of chick in grams.\n\nThe goal of graphing the data is to investigate the effect of diet on weight over time.\nDownload and save a CSV file. We use the data.table fread() function to read the data set from the workshop repository (an Internet connection is required).\nWe use fwrite() to save the file to the data directory in your project folder.\n# data URL\ndata_url &lt;- \"https://raw.githubusercontent.com/MIDFIELDR/2024-midfield-institute/main/data/chick_weight.csv\"\n\n# download the data\nchick_weight &lt;- fread(data_url)\n\n# write the data to your data directory\nfwrite(chick_weight, \"data/chick_weight.csv\")\nThese lines of code are run only once. After the data are downloaded, these lines can be commented out, e.g.,\n\n# # data URL\n# data_url &lt;- \"https://raw.githubusercontent.com/MIDFIELDR/2024-midfield-institute/main/data/chick_weight.csv\"\n# \n# # download the data\n# chick_weight &lt;- fread(data_url)\n# \n# # write the data to your data directory\n# fwrite(chick_weight, \"data/chick_weight.csv\")\n\nImport a CSV file. We import the data from the local file chick_weight.csv using fread(). This function returns a data.table object. A data.table is a data.frame with additional attributes.\n\ncw &lt;- fread(\"data/chick_weight.csv\")\n\nLook at the data. To look at the data, type the object (dataset) name:\n\n# view the data\ncw\n#&gt;      Chick  Diet  Time weight\n#&gt;      &lt;int&gt; &lt;int&gt; &lt;int&gt;  &lt;int&gt;\n#&gt;   1:    18     1     0     39\n#&gt;   2:    18     1     2     35\n#&gt;   3:    16     1     0     41\n#&gt;   4:    16     1     2     45\n#&gt;   5:    16     1     4     49\n#&gt;  ---                         \n#&gt; 574:    48     4    14    170\n#&gt; 575:    48     4    16    222\n#&gt; 576:    48     4    18    261\n#&gt; 577:    48     4    20    303\n#&gt; 578:    48     4    21    322\n\nSeveral base R functions help us inspect the data. In addition to str() that you used in the previous tutorial, we also have:\n\n\nsummary() provides a summary\n\nhead() and tail() display the beginning and end of the data set\n\n\nsummary(cw)\n#&gt;      Chick            Diet            Time           weight     \n#&gt;  Min.   : 1.00   Min.   :1.000   Min.   : 0.00   Min.   : 35.0  \n#&gt;  1st Qu.:13.00   1st Qu.:1.000   1st Qu.: 4.00   1st Qu.: 63.0  \n#&gt;  Median :26.00   Median :2.000   Median :10.00   Median :103.0  \n#&gt;  Mean   :25.75   Mean   :2.235   Mean   :10.72   Mean   :121.8  \n#&gt;  3rd Qu.:38.00   3rd Qu.:3.000   3rd Qu.:16.00   3rd Qu.:163.8  \n#&gt;  Max.   :50.00   Max.   :4.000   Max.   :21.00   Max.   :373.0\n\nExercises are written such that the question is displayed under the tab to the left; the answer is displayed by clicking on the tab to the right.\n\n\nExercise 2.1\nAnswer\n\n\n\nUse tail() to examine the last observations in cw and compare to the last observations in the ChickWeight data set provided in base R. Do they agree? Describe the differences, if any.\n\n\nThe variables (columns) are the same but in different order. The observations (rows) are apparently in different order too.\n\n#&gt;    Chick  Diet  Time weight\n#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt;  &lt;int&gt;\n#&gt; 1:    48     4    12    154\n#&gt; 2:    48     4    14    170\n#&gt; 3:    48     4    16    222\n#&gt; 4:    48     4    18    261\n#&gt; 5:    48     4    20    303\n#&gt; 6:    48     4    21    322\n#&gt;     weight Time Chick Diet\n#&gt; 573    155   12    50    4\n#&gt; 574    175   14    50    4\n#&gt; 575    205   16    50    4\n#&gt; 576    234   18    50    4\n#&gt; 577    264   20    50    4\n#&gt; 578    264   21    50    4\n\nAlso, the row numbers in cw (a data.table) are different from the row numbers in ChickWeight.\n\n\n\n\n\nExercise 2.2\nAnswer\n\n\n\nUse str() to compare cw to the original ChickWeight in base R. How are they different?\n\n\ncw is a data.frame and a data.table object and the variables are all integers.\n\n#&gt; Classes 'data.table' and 'data.frame':   578 obs. of  4 variables:\n#&gt;  $ Chick : int  18 18 16 16 16 16 16 16 16 15 ...\n#&gt;  $ Diet  : int  1 1 1 1 1 1 1 1 1 1 ...\n#&gt;  $ Time  : int  0 2 0 2 4 6 8 10 12 0 ...\n#&gt;  $ weight: int  39 35 41 45 49 51 57 51 54 41 ...\n#&gt;  - attr(*, \".internal.selfref\")=&lt;externalptr&gt;\n\nChickWeight is a data.frame and a groupedData object (a type of ordered grouping). Two columns are integers but two are factors. We’ll discuss factors in due course.\n\n#&gt; Classes 'nfnGroupedData', 'nfGroupedData', 'groupedData' and 'data.frame':   578 obs. of  4 variables:\n#&gt;  $ weight: num  42 51 59 64 76 93 106 125 149 171 ...\n#&gt;  $ Time  : num  0 2 4 6 8 10 12 14 16 18 ...\n#&gt;  $ Chick : Ord.factor w/ 50 levels \"18\"&lt;\"16\"&lt;\"15\"&lt;..: 15 15 15 15 15 15 15 15 15 15 ...\n#&gt;  $ Diet  : Factor w/ 4 levels \"1\",\"2\",\"3\",\"4\": 1 1 1 1 1 1 1 1 1 1 ...\n#&gt;  - attr(*, \"formula\")=Class 'formula'  language weight ~ Time | Chick\n#&gt;   .. ..- attr(*, \".Environment\")=&lt;environment: R_EmptyEnv&gt; \n#&gt;  - attr(*, \"outer\")=Class 'formula'  language ~Diet\n#&gt;   .. ..- attr(*, \".Environment\")=&lt;environment: R_EmptyEnv&gt; \n#&gt;  - attr(*, \"labels\")=List of 2\n#&gt;   ..$ x: chr \"Time\"\n#&gt;   ..$ y: chr \"Body weight\"\n#&gt;  - attr(*, \"units\")=List of 2\n#&gt;   ..$ x: chr \"(days)\"\n#&gt;   ..$ y: chr \"(gm)\"",
    "crumbs": [
      "Tutorial links",
      "R chart basics"
    ]
  },
  {
    "objectID": "chart-basics.html#scatterplot",
    "href": "chart-basics.html#scatterplot",
    "title": "R chart basics",
    "section": "Scatterplot",
    "text": "Scatterplot\nOur goal is to examine how weight changes over time conditioned by diet.\nDon’t worry too much about the details of the ggplot2 syntax. To learn more, try different things even if you get an error message. No harm is done!\nFirst plot. Let’s plot the weight data (y axis) as a function of time (x axis). The first plot is empty because there is no “geom” (a geometric layer) to encode the data visually.\n\nggplot(data = cw, mapping = aes(x = Time, y = weight))\n\n\n\n\n\n\n\nNext we add the geom_point() layer to encode the data as points in a scatterplot.\n\nggplot(data = cw, mapping = aes(x = Time, y = weight)) + \n  geom_point()\n\n\n\n\n\n\n\n\n\nExercise 2.3\nAnswer\n\n\n\n\nSwitch the variables Time and weight in the code chunk.\nWhat do you think of this new plot compared to the original?\n\n\n\nIn a time series, the visual convention (in Latin/Roman-descended societies) is for time to read from left to right, so this chart is not as intuitive as the earlier chart.\n\n\n\n\n\n\n\n\n\n\n\nLocation of +. The + symbol that adds a layer to a ggplot2 object cannot start a new line. Using the code above to illustrate,\n# correct\nggplot(cw, aes(weight, Time)) + geom_point()\n\n# correct\nggplot(cw, aes(weight, Time)) + \n  geom_point()\n\n# incorrect \nggplot(cw, aes(weight, Time)) \n  + geom_point()",
    "crumbs": [
      "Tutorial links",
      "R chart basics"
    ]
  },
  {
    "objectID": "chart-basics.html#another-variable",
    "href": "chart-basics.html#another-variable",
    "title": "R chart basics",
    "section": "Another variable",
    "text": "Another variable\nColor encodes a third variable. The graph does not differentiate between the diets. In the next step, we use color to encode Diet, a categorical variable with four levels: diets 1, 2, 3, and 4. One important thing to notice is that all arguments being “mapped” must be names of variables in the cw data frame.\n\nggplot(data = cw, mapping = aes(x = Time, y = weight, color = factor(Diet))) +\n  geom_point()\n\n\n\n\n\n\n\nIt is difficult to conclude anything from this graph as the points are printed on top of one another (with diet 4 overprinting diet 3 which overprints diet 2, etc.).",
    "crumbs": [
      "Tutorial links",
      "R chart basics"
    ]
  },
  {
    "objectID": "chart-basics.html#faceted-chart",
    "href": "chart-basics.html#faceted-chart",
    "title": "R chart basics",
    "section": "Faceted chart",
    "text": "Faceted chart\nFactor variables. Before we continue, we make an important change to the cw dataset by transforming Diet and Time into factor variables. Factors are treated by R as categorical variables instead of continuous variables. It will simplify our coding.\nThe := operator (from data.table) alters variables “in-place”, with no explicit assignment (&lt;-). We revisit the := operator in the R data basics tutorial.\n\n# create factors\ncw[, Diet := factor(Diet)]\ncw[, Time := factor(Time)]\n\n# notice the difference?\nsummary(cw) \n#&gt;      Chick       Diet         Time         weight     \n#&gt;  Min.   : 1.00   1:220   0      : 50   Min.   : 35.0  \n#&gt;  1st Qu.:13.00   2:120   2      : 50   1st Qu.: 63.0  \n#&gt;  Median :26.00   3:120   4      : 49   Median :103.0  \n#&gt;  Mean   :25.75   4:118   6      : 49   Mean   :121.8  \n#&gt;  3rd Qu.:38.00           8      : 49   3rd Qu.:163.8  \n#&gt;  Max.   :50.00           10     : 49   Max.   :373.0  \n#&gt;                          (Other):282\n\nfacet_wrap() function. facet_wrap() is a ggplot2 function that plots variables in separate facets, or panels. In this case, each facet contains one of the four diets.\n\n# create facets by Diet \nggplot(data = cw, mapping = aes(x = Time, y = weight, color = Diet)) +\n  geom_point() +\n  facet_wrap(vars(Diet)) +\n  theme(legend.position = \"bottom\")\n\n\n\n\n\n\n\n\n\nExercise 2.4\nAnswer\n\n\n\n\nTo address “overprinting” (where points print over other points in the same position), replace geom_point() with geom_jitter().\nWhat observations about the data can you make?\n\n\n\n\n\n\n\n\n\n\n\n\nJittering allows a much better view of the full data set.\nDiet 4 has the least variability.\nDiet 3 seems to have the highest weights.\nWe can’t really say anything about the mean effect of each diet.\n\n\n\n\n\n\nExercise 2.5\nAnswer\n\n\n\nFor the legend.position argument, try using “top”, “left” and “none”. Do we really need a legend for this plot?\n\n\n\n\n\n\n\n\n\n\nHere, the legend.position argument is “none”. The diet types are in the panel headers, so a legend is unnecessary.",
    "crumbs": [
      "Tutorial links",
      "R chart basics"
    ]
  },
  {
    "objectID": "chart-basics.html#mean-line-chart",
    "href": "chart-basics.html#mean-line-chart",
    "title": "R chart basics",
    "section": "Mean line chart",
    "text": "Mean line chart\nNext we plot the mean changes over time for each diet using the stat_summary() function. Because we do not have facets this time, we use the default legend.\n\nggplot(data = cw, mapping = aes(x = Time, y = weight, group = Diet, color = Diet)) +\n  stat_summary(fun = \"mean\", geom = \"line\")\n\n\n\n\n\n\n\nWe see that diet 3 has the highest mean weight gain by the end of the experiment but we don’t have any information about the variation (uncertainty) in the data.\n\n\nExercise 2.6\nAnswer\n\n\n\n\nWhat happens when you add geom_point() to the plot above? Don’t forget the +.\nDoes it make a difference if you put it before or after stat_summary(...)?\nHint: Look carefully at how the graph is plotted.\n\n\n\n\n\n\n\n\n\n\n\n\nThe chart is the same either way.\nThe underlying idea in ggplot2 is that a chart is assembled in layers, adding a new layer to previous layers using the + operator.",
    "crumbs": [
      "Tutorial links",
      "R chart basics"
    ]
  },
  {
    "objectID": "chart-basics.html#box-whisker-plot",
    "href": "chart-basics.html#box-whisker-plot",
    "title": "R chart basics",
    "section": "Box & whisker plot",
    "text": "Box & whisker plot\nTo see variation between the different diets we use geom_boxplot() to plot a box & whisker plot. A note of caution—the number of chicks per diet is relatively low to produce this plot.\n\nggplot(data = cw, mapping = aes(x = Time, y = weight, color = Diet)) +\n  facet_wrap(vars(Diet)) +\n  geom_boxplot() +\n  theme(legend.position = \"none\") +\n  ggtitle(\"Changing distributions of chick weight by diet and elapsed time\")\n\n\n\n\n\n\n\n\nDiet 3 seems to have the highest “average” weight gain\nDiet 4 seems to have the least amount of variation\n\n\n\nExercise 2.7\nAnswer\n\n\n\nTo the plot above, edit the axis labels using xlab() for the x-axis label and ylab() for the y-axis label. The labels should be,\n\nx-axis: “Time (days)”\ny-axis: “Weight (grams)”\n\nHint: Add a plus symbol (+) at the end of the current last line, then add a the x-label layer using the xlab() function. Repeat for the y-label. You can type help(xlab) in the Console to view its help page.",
    "crumbs": [
      "Tutorial links",
      "R chart basics"
    ]
  },
  {
    "objectID": "chart-basics.html#scatterplot-with-mean-line",
    "href": "chart-basics.html#scatterplot-with-mean-line",
    "title": "R chart basics",
    "section": "Scatterplot with mean line",
    "text": "Scatterplot with mean line\nLet’s finish with a plot that you might include in a publication\n\nggplot(data = cw, mapping = aes(x = Time, y = weight, group = Diet, color = Diet)) +\n  facet_wrap(vars(Diet)) +\n  stat_summary(fun = \"mean\", geom = \"line\", colour= \"black\") +\n  geom_jitter() +\n  theme(legend.position = \"none\") +\n  ggtitle(\"Chick weight by diet and elapsed time\") +\n  xlab(\"Time (days)\") +\n  ylab(\"Weight (grams)\")\n\n\n\n\n\n\n\nNote that I printed the line layer first then printed the points over them to let the data be prominent.\n\n\nExercise 2.8\nAnswer\n\n\n\n\nRead the help page for the facet_wrap() function\nSee if you can edit the code slightly to make the facets print out row-wise, as in 1 row and 4 columns of charts.\n\nWhat visual advantages does this arrangement provide?\nWhat visual disadvantages?",
    "crumbs": [
      "Tutorial links",
      "R chart basics"
    ]
  },
  {
    "objectID": "agenda.html",
    "href": "agenda.html",
    "title": "Program",
    "section": "",
    "text": "Image: Today’s Agenda by Rajiv Patel is licensed under CC BY-NC 2.0",
    "crumbs": [
      "Program"
    ]
  },
  {
    "objectID": "agenda.html#pre-workshop",
    "href": "agenda.html#pre-workshop",
    "title": "Program",
    "section": "Pre-workshop",
    "text": "Pre-workshop\nPre-workshop tutorials\nIf you are new to R (or new to the ggplot2 or data.table packages), we recommend you complete the three introductory tutorials listed below. Completing these tutorials before attending the Institute will make your time with us that much more productive.\n\nR basics\n\nR chart basics\nR data basics\n\nEach tutorial can be completed in under an hour if you have any experience with procedural programming languages such as MATLAB, R, or Python. Programming novices might need more than an hour each.",
    "crumbs": [
      "Program"
    ]
  },
  {
    "objectID": "agenda.html#tuesday-june-11",
    "href": "agenda.html#tuesday-june-11",
    "title": "Program",
    "section": "Tuesday, June 11",
    "text": "Tuesday, June 11\nJoin the online office hours\nOffice hours\n1:00–5:00 pm Eastern Time. We are available for answering questions and resolving problems you encounter installing R or working with R in the three pre-workshop tutorials.",
    "crumbs": [
      "Program"
    ]
  },
  {
    "objectID": "agenda.html#wednesday-june-12",
    "href": "agenda.html#wednesday-june-12",
    "title": "Program",
    "section": "Wednesday, June 12",
    "text": "Wednesday, June 12\nJoin the online meeting\nIntroductions  slides\n1:00–1:50 Eastern Time\nIntroduce facilitators and participants, objectives, and MIDFIELD.\nBreak\n1:50–2:00\nExploring data structure  slides\n2:00–3:00\nExploring data excerpts manually.\n\nStudent 3 data example\nStudent 4 data example\n\nCIP website NCES Classification of Instructional Programs (CIP)\n\nGuided practice.\n3:00–5:00\nSelf-paced case study using midfieldr and midfielddata. Real-time help.\n\nCase study: Goals A short reading.\n\nCase study: Data A midfieldr tutorial.\n\nWrap-up\nbefore 5:00\nPlease check in with us before leaving the virtual meeting.\nHomework\n\nComplete the guided practice “Data” tutorial.\nFor our think-share activities in tomorrow’s data visualization session, consider printing a hard-copy of the worksheet. (Download link in tomorrow’s program below.)\n\nOptional resources\n\nTopics from today’s guided practice are developed in greater detail in midfieldr package vignettes [link].",
    "crumbs": [
      "Program"
    ]
  },
  {
    "objectID": "agenda.html#thursday-june-13",
    "href": "agenda.html#thursday-june-13",
    "title": "Program",
    "section": "Thursday, June 13",
    "text": "Thursday, June 13\nJoin the online meeting\nMetaphors and metrics  slides\n1:00–1:30 Eastern Time\nPipelines, pathways, and ecosystems.\nBreak\n1:30–1:40\nGuided practice\n1:40–2:30\nCase study: Results Continue the case study.\nData visualization session 1  worksheets  slides\n2:30–3:20\nA hard-copy printout of the worksheet is recommended for our think-share activities. We demonstrate the perceptual limitations of common graph types and suggest more effective alternatives. Our goals in visual rhetoric are\n\nImproving perception of stories in the data\nFacilitating quantitative reasoning about the data\nEnhancing credibility of evidence supporting an argument\n\nBreak\n3:20–3:30\nA practice research question  slides\n3:30–5:00\nWe partially define a practice research question to be examined using midfieldr and midfielddata. Working in small groups and given a specific metric, choose programs and student blocs and develop the appropriate data and chart(s) to explore possible stories in your data. Report out your progress by the end of the day.\nResources\n\ndata dictionary: CIP codes (data set cip included with midfieldr)\ndata dictionaries: student practice data / research data\n\ndata dictionaries: term practice data / research data\n\ndata dictionaries: course practice data / research data\n\ndata dictionaries: degree practice data / research data\n\nWrap-up.\nbefore 5:00\nPlease check in with us before leaving the virtual meeting.\nHomework\n\nComplete the guided practice “Results” tutorial.\nConsider what research question you would like to work on during the final day of the workshop. You may continue the practice question you started today or you may develop a new research question.\n\nFor our think-share activities in tomorrow’s data visualization session, consider printing a hard-copy of the worksheet. (Download link in tomorrow’s program below.)\n\nOptional resources\n\nTopics from today’s guided practice are developed in greater detail in midfieldr package vignettes [link].\nDeveloping the migration yield metric.  slides An optional supplement to the metaphors and metrics session that outlines the iterative process between the logic of an argument and the logic of a chart that led us to develop the migration yield metric.",
    "crumbs": [
      "Program"
    ]
  },
  {
    "objectID": "agenda.html#friday-june-14",
    "href": "agenda.html#friday-june-14",
    "title": "Program",
    "section": "Friday, June 14",
    "text": "Friday, June 14\nJoin the online meeting\nData visualization session 2  worksheets  slides\n1:00–2:00 Eastern Time\nA hard-copy printout of the worksheet is recommended for our think-share activities. We illustrate a repertoire of chart types and how they are suited to specific data structures and answering specific types of questions.\nWork on your research question\n 2:00–3:30\nSmall-group work. Consult with us on your progress, discussion\nResources\n\ndata dictionary: CIP codes (data set cip included with midfieldr)\ndata dictionaries: student practice data / research data\n\ndata dictionaries: term practice data / research data\n\ndata dictionaries: course practice data / research data\n\ndata dictionaries: degree practice data / research data\n\nProgress report\n3:30–4:30\nShare with the group.\nWrap up\n 4:40–4:45",
    "crumbs": [
      "Program"
    ]
  },
  {
    "objectID": "before-you-arrive.html",
    "href": "before-you-arrive.html",
    "title": "Before you arrive",
    "section": "",
    "text": "Image: Data Visualization and R Bookshelf by Richard Layton.\nTo get the most out of the workshop, you should have the essential software installed and running on your computer several days before the workshop to give you time to contact us with questions if anything goes amiss.\nIf you are trying R for the first time, it is vital that you attempt to set up your computer with the necessary software in advance or it will be difficult to keep up.\nAs you work your way through this pre-workshop assignment, you will encounter R code chunks to type. Clicking the Copy to Clipboard icon  in the top right corner of the code chunk copies the code to your clipboard, saving some typing time. For example:\n# sample code chunk\nx &lt;- 10",
    "crumbs": [
      "Before you arrive"
    ]
  },
  {
    "objectID": "before-you-arrive.html#already-use-r",
    "href": "before-you-arrive.html#already-use-r",
    "title": "Before you arrive",
    "section": "Already use R?",
    "text": "Already use R?\nIf you are already an R and RStudio integrated development environment (IDE) user, this is a great time to check for updates.\nUpdating RStudio\n\nRStudio menu Help &gt; Check for Updates will tell you if you are current or not.\nTo update, close RStudio on your machine, download the new version from Posit).\n\nUpdate your packages\nHow to upgrade all out-of-date packages in What They Forgot to Teach You About R by Jennifer Bryan and Jim Hester.\nUpdating R\nThe easiest way to update R is to simply download the newest version. RStudio will automatically use the latest you’ve installed.\nAlternatively, Windows users can use the installr package:\n\nInstall the installr package\nIf open, close R and RStudio\nNavigate to your most recent Rgui.exe file located in your Programs directory, e.g., C:\\Program Files\\R\\R-4.3.3\\bin\\x64\\Rgui.exe\n\nRight-click on Rgui.exe and run as administrator\nIn the R GUI window that appears, run the commands\n\n    # Windows users only\n    library(\"installr\")\n    updateR()\nUpdating your R library\nHow to transfer your library when updating R also by Bryan and Hester. Requires the fs package.",
    "crumbs": [
      "Before you arrive"
    ]
  },
  {
    "objectID": "before-you-arrive.html#new-to-r",
    "href": "before-you-arrive.html#new-to-r",
    "title": "Before you arrive",
    "section": "New to R?",
    "text": "New to R?\nThis section is for anyone who has not yet installed R or RStudio.\nThe first steps are to install R and RStudio. Both R and RStudio are free. Windows users may have to login as an Administrator before installing the software.\n\n\nInstall R and RStudio from the “Posit” website. Alternatively, you can download R directly from the R website.\n\nOnce the installation is complete, you can take a 2-minute tour of the RStudio interface.\n\n\nLet’s start (00:57–02:32) by R Ladies Sydney (Richmond, 2018)\n\n\nThe same video includes a longer (7 minute) tour of the four quadrants (panes) in RStudio if you are interested.\n\n\nThe RStudio quadrants (07:21–14:40) by R Ladies Sydney (Richmond, 2018)",
    "crumbs": [
      "Before you arrive"
    ]
  },
  {
    "objectID": "before-you-arrive.html#start-the-setup",
    "href": "before-you-arrive.html#start-the-setup",
    "title": "Before you arrive",
    "section": "Start the setup",
    "text": "Start the setup\nOnce you have R and RStudio up and running on your system, we have a short set of setup instructions to help prepare you for the workshop R tutorials.\nWe start by creating an RStudio Project file and directory. You can recognize an R project file by its .Rproj suffix.\n(Optional) If you prefer your instructions with commentary,\n\n\nStart with a Project (02:34–04:50) by R Ladies Sydney (Richmond, 2018)\n\nIf you follow the instructions on the video, then when finished, use File &gt; Close to close any open projects you created. Then create a new project for the Institute as follows.\n\nCreate an RStudio Project for the MIDFIELD Institute:\n\nRStudio, File &gt; New Project… &gt; New Directory &gt; New Project\n\nOr, click the New Project button in the Console ribbon,\n\n\nIn the dialog box that appears,\n\nType the workshop name as the directory name, for example, midfield-institute-2024\n\nUse the browse button to select a location on your computer to create the project folder\n\nClick the Create Project button\n\nYou now have the RStudio Project for the MIDFIELD Institute up and running. If you happen to close the project, simply click on the midfield-institute-2024.Rproj file to re-open your work.\n\n\n\n\n\n\nTip\n\n\n\nUsing RStudio projects. For more information about RStudio projects in general, see the RStudio Project support page.",
    "crumbs": [
      "Before you arrive"
    ]
  },
  {
    "objectID": "before-you-arrive.html#add-some-folders",
    "href": "before-you-arrive.html#add-some-folders",
    "title": "Before you arrive",
    "section": "Add some folders",
    "text": "Add some folders\nIf your Institute Project is still open, the “Files” pane should show one item in your project directory. If not, click on the midfield-institute-2024.Rproj file to re-open your work.\n\nAdd three folders to the main project folder. To create folders:\n\nuse your usual method of creating new folders on your machine\nor you can use the New Folder button in the Files pane\n\n\nWe use the folders as follows:\n\n\ndata data files (for data not included in an R package)\n\nscripts R scripts that operate on data to produce results\n\n\nresults publication-ready graphs and tabulated results\n\nFor a video guide,\n\n\nMake some folders (04:50–06:08) by R Ladies Sydney (Richmond, 2018)\n\n\n\n\n\n\n\n\nTip\n\n\n\nOrganizing a computational project. If you are interested in a comprehensive set of “good enough practices” for scientific computing, we highly recommend (Wilson et al., 2017). The sections on data management, software, collaboration, and project organization are particularly useful to consider at the beginning of a project.",
    "crumbs": [
      "Before you arrive"
    ]
  },
  {
    "objectID": "before-you-arrive.html#install-cran-packages",
    "href": "before-you-arrive.html#install-cran-packages",
    "title": "Before you arrive",
    "section": "Install CRAN packages",
    "text": "Install CRAN packages\nThe fundamental unit of shareable code in R is the package. For the R novice, an R package is like an “app” for R—a collection of functions, data, and documentation for doing work in R that is easily shared with others (Wickham, 2014).\nMost packages are obtained from the CRAN website (The Comprehensive R Archive Network, 2018-04-22). To install a CRAN package using RStudio:\n\nLaunch RStudio\n\nThe RStudio interface has several panes. We want the Files/Plots/Packages pane.\n\nSelect the Packages tab\n\n\nNext,\n\nClick Install on the ribbon\nIn the dialog box, type the name of the package. For our first package, type data.table to install the data.table package (Dowle & Srinivasan, 2021)\n\nCheck the Install dependencies box\nClick the Install button\n\n\nDuring the installation, Windows users might get a warning message about Rtools, something like:\nWARNING: Rtools is required to build R packages but is not currently installed. Please download etc.\n\nRtools is needed for packages with C/C++/FORTRAN code from source—which does not apply to us. You may ignore the warning and carry on.\nIn the RStudio Console, you should see a message like this one,\npackage 'data.table' successfully unpacked and MD5 sums checked\nIf successful, the package will appear in the Packages pane, e.g.,\n\nRepeat the process for the following packages:\ncheckmate\nggplot2\nwrapr\ncurl\nAlternatively, you can install them all at once by typing in the Console:\npackages_we_use &lt;- c(\"data.table\", \"ggplot2\", \"checkmate\", \"wrapr\", \"curl\")\ninstall.packages(packages_we_use)",
    "crumbs": [
      "Before you arrive"
    ]
  },
  {
    "objectID": "before-you-arrive.html#install-midfieldr",
    "href": "before-you-arrive.html#install-midfieldr",
    "title": "Before you arrive",
    "section": "Install midfieldr",
    "text": "Install midfieldr\nInstall with:\n# type in the RStudio Console \ninstall.packages(\"midfieldr\")\n\n\n\n\n\n\nTip\n\n\n\nIf you get an error message like the one below, it means that the packages in the dependencies list have not been installed.\n\nThe remedy is to install any packages listed in the error message and then install midfieldr again.\n\n\nOnce midfieldr is successfully installed, you can confirm the installation by running the following lines to bring up the package help page in the Help window.\n# type in the RStudio Console \nlibrary(\"midfieldr\")\n?midfieldr\nIf the installation is successful, the code chunk above should produce a view of the help page as shown here.",
    "crumbs": [
      "Before you arrive"
    ]
  },
  {
    "objectID": "before-you-arrive.html#install-midfielddata",
    "href": "before-you-arrive.html#install-midfielddata",
    "title": "Before you arrive",
    "section": "Install midfielddata",
    "text": "Install midfielddata\nBecause of its size, the data package is stored in a drat repository instead of CRAN. Installation takes time; please be patient and wait for the Console prompt “&gt;” to reappear.\nType (or copy and paste) the following lines in the RStudio Console.\n# type in the RStudio Console  \ninstall.packages(\"midfielddata\", \n                 repos = \"https://MIDFIELDR.github.io/drat/\", \n                 type = \"source\")\n# be patient\nOnce the Console prompt “&gt;” reappears, you can confirm a successful installation by viewing the package help page. In the Console, run:\n# type in the RStudio Console  \nlibrary(\"midfielddata\")\n?midfielddata\nIf the installation is successful, the code chunk above should produce a view of the help page as shown here.",
    "crumbs": [
      "Before you arrive"
    ]
  },
  {
    "objectID": "before-you-arrive.html#finish-the-setup",
    "href": "before-you-arrive.html#finish-the-setup",
    "title": "Before you arrive",
    "section": "Finish the setup",
    "text": "Finish the setup\nAs a final task, save your open files and close RStudio.\nIf you get a prompt about saving your workspace image, the answer is No. \nYou can turn this prompt off by reopening RStudio and use the pulldown menu:\n\nTools &gt; Global Options…\nIn the dialog box, Save workspace to .RData on exit: Select “Never”",
    "crumbs": [
      "Before you arrive"
    ]
  },
  {
    "objectID": "before-you-arrive.html#homework",
    "href": "before-you-arrive.html#homework",
    "title": "Before you arrive",
    "section": "Homework",
    "text": "Homework\nIf you are new to R (or new to the ggplot2 or data.table packages), we recommend you complete the three pre-workshop tutorials for an introduction to R including manipulating data and creating charts.\nCompleting these tutorials before attending the Institute will make your time with us that much more productive.",
    "crumbs": [
      "Before you arrive"
    ]
  },
  {
    "objectID": "data-basics.html",
    "href": "data-basics.html",
    "title": "R data basics",
    "section": "",
    "text": "Image: US Route 60 Large Array by Mobilus In Mobili is licensed under CC BY-SA 2.0\nUsing data.table to manipulate data in R.\nLicense. This material is adapted from Getting started in R: Tinyverse edition by Bashir and Eddelbuettel (2018) which was licensed under CC BY-SA by ilustat. This adaptation and extension, R data basics by Richard Layton, is licensed under CC BY-SA 2.0.",
    "crumbs": [
      "Tutorial links",
      "R data basics"
    ]
  },
  {
    "objectID": "data-basics.html#preface",
    "href": "data-basics.html#preface",
    "title": "R data basics",
    "section": "Preface",
    "text": "Preface\nMIDFIELD data are curated, that is, organized and integrated from multiple institutions, maintained over time, and available for reuse and preservation. Yet to address any specific research question, the data must be wrangled into a shape useful for analysis.\n\nThe basic concept of data wrangling is to visualize your data being structured to make your task easier, and then take the steps to add this structure to your data (Zumel & Mount, 2020, p. 113.).\n\nThis tutorial covers basic operations for data shaping with the goal of obtaining a simple “data matrix” where each row is an observation and each column is a measurement type.\nUsing data.table The rationale for manipulating data using the data.table package instead of base R or the dplyr package include speed, memory efficiency, and concise transforms via the []-indexing operator (e.g., the “by” grouping notation).\nTo mitigate the extra cognitive load for new R users of learning data.table syntax while also learning R, I use a “no-frills” approach as much as possible.\nConceptually, data.table operations can be viewed as\n    dt[i, j, by]\nwith some intentional similarity to SQL. Here i operates on rows, j operates on columns, and by is the grouping operator.\nBefore starting. Our tutorials assume that you\n\nHave completed the Before you arrive instructions\nHave completed the R basics guide\nHave completed the R chart basics guide\n\nStart your R session by launching the RStudio project you created, e.g., midfield-institute-2024.Rproj. If you are in your RStudio project, the project name appears in the upper left corner of the RStudio window, e.g.,\n\nAnd based on the work you did in the Before you arrive session, your project directory should have three folders:",
    "crumbs": [
      "Tutorial links",
      "R data basics"
    ]
  },
  {
    "objectID": "data-basics.html#getting-started",
    "href": "data-basics.html#getting-started",
    "title": "R data basics",
    "section": "Getting started",
    "text": "Getting started\nStart a new script. I recommend that you start a new script for this segment.\n\nUse File &gt; New File &gt; R Script to create a new R script\n\nFile &gt; Save As… to name the file (we suggest 03-data-basics.R), then save it to the scripts directory\nAt the top of the script, add a minimal header, something like:\n\n\n# R data basics\n# your name  \n# date \n\n\nUse library() to load packages used in the script.\n\n\n# load packages\nlibrary(\"data.table\")\n\n# set data.table printout options\noptions(\n  datatable.print.nrows = 20,\n  datatable.print.topn = 5,\n  datatable.print.class = TRUE\n)\n\nReminder: In a code chunk like the one above, you can click on the “Copy to clipboard” icon in the upper right corner to enable quick copy and paste from this document to your script.\nUse your script throughout the tutorial. When a new chunk of code is given,\n\nCopy the line(s) of code into your script, save, and run.\n\nCheck your result by comparing it to the result in the tutorial.\nCheck what you’ve learned using the Your turn exercises.",
    "crumbs": [
      "Tutorial links",
      "R data basics"
    ]
  },
  {
    "objectID": "data-basics.html#import-data",
    "href": "data-basics.html#import-data",
    "title": "R data basics",
    "section": "Import data",
    "text": "Import data\nRead the same data file we used in the previous tutorial. The data set is in block-record (or “data matrix”) form, that is, variables are columns and observations are rows.\n\n# import data\ncw &lt;- fread(\"data/chick_weight.csv\")\n\n# view\ncw\n#&gt;      Chick  Diet  Time weight\n#&gt;      &lt;int&gt; &lt;int&gt; &lt;int&gt;  &lt;int&gt;\n#&gt;   1:    18     1     0     39\n#&gt;   2:    18     1     2     35\n#&gt;   3:    16     1     0     41\n#&gt;   4:    16     1     2     45\n#&gt;   5:    16     1     4     49\n#&gt;  ---                         \n#&gt; 574:    48     4    14    170\n#&gt; 575:    48     4    16    222\n#&gt; 576:    48     4    18    261\n#&gt; 577:    48     4    20    303\n#&gt; 578:    48     4    21    322",
    "crumbs": [
      "Tutorial links",
      "R data basics"
    ]
  },
  {
    "objectID": "data-basics.html#changes-in-place",
    "href": "data-basics.html#changes-in-place",
    "title": "R data basics",
    "section": "Changes in place",
    "text": "Changes in place\nRename variables. Edit column names “in place.”\nBy in place we mean that the change is made using data.table reference semantics (or by reference) in which changes are made without assigning the result back to a name, that is, we write\n    setnames(cw, old, new)\nnot\n    cw &lt;- setnames(cw, old, new)\nFor example, changing the variable names in the cw data frame,\n\n# change column names in place\nsetnames(cw, \n         old = c(\"Chick\", \"Diet\", \"Time\", \"weight\"), \n         new = c(\"chick_id\", \"group\", \"day\", \"weight_g\"))\n\ncw\n#&gt;      chick_id group   day weight_g\n#&gt;         &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;\n#&gt;   1:       18     1     0       39\n#&gt;   2:       18     1     2       35\n#&gt;   3:       16     1     0       41\n#&gt;   4:       16     1     2       45\n#&gt;   5:       16     1     4       49\n#&gt;  ---                              \n#&gt; 574:       48     4    14      170\n#&gt; 575:       48     4    16      222\n#&gt; 576:       48     4    18      261\n#&gt; 577:       48     4    20      303\n#&gt; 578:       48     4    21      322\n\nThere’s much more to reference semantics than dropping the assignment operator—it’s really about speed and memory efficiency with large data sets. However, for our “basics” series, you need to recall only that the := operator and all data.table functions with names starting with set work by reference.\nExercises are written such that the question is displayed under the tab to the left; the answer is displayed by clicking on the tab to the right.\n\n\nExercise 3.1\nAnswer\n\n\n\n\nCreate a copy of cw using x &lt;- copy(cw)\n\nIn x, rename the ID variable to ID.\n\n\n\n\nx &lt;- copy(cw)\nsetnames(x, old = c(\"chick_id\"), new = c(\"ID\"))\nx\n#&gt;         ID group   day weight_g\n#&gt;      &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;\n#&gt;   1:    18     1     0       39\n#&gt;   2:    18     1     2       35\n#&gt;   3:    16     1     0       41\n#&gt;   4:    16     1     2       45\n#&gt;   5:    16     1     4       49\n#&gt;  ---                           \n#&gt; 574:    48     4    14      170\n#&gt; 575:    48     4    16      222\n#&gt; 576:    48     4    18      261\n#&gt; 577:    48     4    20      303\n#&gt; 578:    48     4    21      322\n\n\n\n\nReorder variables. Another example of an operation in-place. The columns listed are moved to the left-hand side of the data frame and other columns appear to the right in their original order. Here we move dayand group to the first two column positions.\n\n# reorder column positions in place\nsetcolorder(cw, c(\"day\", \"group\"))\n\n# view\ncw\n#&gt;        day group chick_id weight_g\n#&gt;      &lt;int&gt; &lt;int&gt;    &lt;int&gt;    &lt;int&gt;\n#&gt;   1:     0     1       18       39\n#&gt;   2:     2     1       18       35\n#&gt;   3:     0     1       16       41\n#&gt;   4:     2     1       16       45\n#&gt;   5:     4     1       16       49\n#&gt;  ---                              \n#&gt; 574:    14     4       48      170\n#&gt; 575:    16     4       48      222\n#&gt; 576:    18     4       48      261\n#&gt; 577:    20     4       48      303\n#&gt; 578:    21     4       48      322\n\nIf you want to make a change without affecting the source data frame, assign a copy of the data frame to a new name with the copy() function. Assignment to a new name is not enough; you have to deliberately use the copy() function.\n\n# create an new object in memory\nx &lt;- copy(cw)\n\n# edit in place\nsetcolorder(x, c(\"group\", \"day\"))\n\n# view\nx\n#&gt;      group   day chick_id weight_g\n#&gt;      &lt;int&gt; &lt;int&gt;    &lt;int&gt;    &lt;int&gt;\n#&gt;   1:     1     0       18       39\n#&gt;   2:     1     2       18       35\n#&gt;   3:     1     0       16       41\n#&gt;   4:     1     2       16       45\n#&gt;   5:     1     4       16       49\n#&gt;  ---                              \n#&gt; 574:     4    14       48      170\n#&gt; 575:     4    16       48      222\n#&gt; 576:     4    18       48      261\n#&gt; 577:     4    20       48      303\n#&gt; 578:     4    21       48      322\n\n# source remains unchanged\ncw\n#&gt;        day group chick_id weight_g\n#&gt;      &lt;int&gt; &lt;int&gt;    &lt;int&gt;    &lt;int&gt;\n#&gt;   1:     0     1       18       39\n#&gt;   2:     2     1       18       35\n#&gt;   3:     0     1       16       41\n#&gt;   4:     2     1       16       45\n#&gt;   5:     4     1       16       49\n#&gt;  ---                              \n#&gt; 574:    14     4       48      170\n#&gt; 575:    16     4       48      222\n#&gt; 576:    18     4       48      261\n#&gt; 577:    20     4       48      303\n#&gt; 578:    21     4       48      322\n\n\n\nExercise 3.2\nAnswer\n\n\n\n\nCreate a copy of cw using x &lt;- copy(cw)\n\nIn x, reorder the columns from left to right ID, group, day, weight.\n\n\n\n\nx &lt;- copy(cw)\nsetcolorder(x, c(\"chick_id\", \"group\", \"day\", \"weight_g\"))\nx\n#&gt;      chick_id group   day weight_g\n#&gt;         &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;\n#&gt;   1:       18     1     0       39\n#&gt;   2:       18     1     2       35\n#&gt;   3:       16     1     0       41\n#&gt;   4:       16     1     2       45\n#&gt;   5:       16     1     4       49\n#&gt;  ---                              \n#&gt; 574:       48     4    14      170\n#&gt; 575:       48     4    16      222\n#&gt; 576:       48     4    18      261\n#&gt; 577:       48     4    20      303\n#&gt; 578:       48     4    21      322",
    "crumbs": [
      "Tutorial links",
      "R data basics"
    ]
  },
  {
    "objectID": "data-basics.html#column-operations",
    "href": "data-basics.html#column-operations",
    "title": "R data basics",
    "section": "Column operations",
    "text": "Column operations\nj to transform a variable. Use := to transform column values in place, here, converting an integer to a double-precision number.\n\n# modify values in an existing column\ncw[, weight_g := as.numeric(weight_g)]\n\n# view\ncw\n#&gt;        day group chick_id weight_g\n#&gt;      &lt;int&gt; &lt;int&gt;    &lt;int&gt;    &lt;num&gt;\n#&gt;   1:     0     1       18       39\n#&gt;   2:     2     1       18       35\n#&gt;   3:     0     1       16       41\n#&gt;   4:     2     1       16       45\n#&gt;   5:     4     1       16       49\n#&gt;  ---                              \n#&gt; 574:    14     4       48      170\n#&gt; 575:    16     4       48      222\n#&gt; 576:    18     4       48      261\n#&gt; 577:    20     4       48      303\n#&gt; 578:    21     4       48      322\n\nHere we use paste0() to add a prefix to the group number, converting the variable to a character type at the same time.\n\n# modify values in an existing column\ncw[, group := paste0(\"diet \", group)]\n\n# view\ncw\n#&gt;        day  group chick_id weight_g\n#&gt;      &lt;int&gt; &lt;char&gt;    &lt;int&gt;    &lt;num&gt;\n#&gt;   1:     0 diet 1       18       39\n#&gt;   2:     2 diet 1       18       35\n#&gt;   3:     0 diet 1       16       41\n#&gt;   4:     2 diet 1       16       45\n#&gt;   5:     4 diet 1       16       49\n#&gt;  ---                               \n#&gt; 574:    14 diet 4       48      170\n#&gt; 575:    16 diet 4       48      222\n#&gt; 576:    18 diet 4       48      261\n#&gt; 577:    20 diet 4       48      303\n#&gt; 578:    21 diet 4       48      322\n\n\n\nExercise 3.3\nAnswer\n\n\n\n\nCreate a copy of cw using x &lt;- copy(cw)\n\nIn x, add the prefix “day” to the day number, converting the variable to type character.\n\n\n\n\nx &lt;- copy(cw)\nx[, day := paste0(\"day \", day)]\nx\n#&gt;         day  group chick_id weight_g\n#&gt;      &lt;char&gt; &lt;char&gt;    &lt;int&gt;    &lt;num&gt;\n#&gt;   1:  day 0 diet 1       18       39\n#&gt;   2:  day 2 diet 1       18       35\n#&gt;   3:  day 0 diet 1       16       41\n#&gt;   4:  day 2 diet 1       16       45\n#&gt;   5:  day 4 diet 1       16       49\n#&gt;  ---                                \n#&gt; 574: day 14 diet 4       48      170\n#&gt; 575: day 16 diet 4       48      222\n#&gt; 576: day 18 diet 4       48      261\n#&gt; 577: day 20 diet 4       48      303\n#&gt; 578: day 21 diet 4       48      322\n\n\n\n\nj to select variables. Variables not listed are dropped. Here, for example, we drop the chick_id variable by not listing it.\n\n# select columns \nx &lt;- cw[, .(day, group, weight_g)]\n\n# view\nx\n#&gt;        day  group weight_g\n#&gt;      &lt;int&gt; &lt;char&gt;    &lt;num&gt;\n#&gt;   1:     0 diet 1       39\n#&gt;   2:     2 diet 1       35\n#&gt;   3:     0 diet 1       41\n#&gt;   4:     2 diet 1       45\n#&gt;   5:     4 diet 1       49\n#&gt;  ---                      \n#&gt; 574:    14 diet 4      170\n#&gt; 575:    16 diet 4      222\n#&gt; 576:    18 diet 4      261\n#&gt; 577:    20 diet 4      303\n#&gt; 578:    21 diet 4      322\n\n\n\nExercise 3.4\nAnswer\n\n\n\n\nCreate a copy of cw using x &lt;- copy(cw)\n\nIn x, select all columns except day.\n\n\n\n\nx &lt;- copy(cw)\nx &lt;- x[, .(chick_id, group, weight_g)]\nx\n#&gt;      chick_id  group weight_g\n#&gt;         &lt;int&gt; &lt;char&gt;    &lt;num&gt;\n#&gt;   1:       18 diet 1       39\n#&gt;   2:       18 diet 1       35\n#&gt;   3:       16 diet 1       41\n#&gt;   4:       16 diet 1       45\n#&gt;   5:       16 diet 1       49\n#&gt;  ---                         \n#&gt; 574:       48 diet 4      170\n#&gt; 575:       48 diet 4      222\n#&gt; 576:       48 diet 4      261\n#&gt; 577:       48 diet 4      303\n#&gt; 578:       48 diet 4      322\n\n\n\n\nj to add a variable. The new variable is added to the right of the other columns. Here, for example, we add the weight_kg variable.\n\n# add a column\ncw[, weight_kg := weight_g / 1000]\n\n# view\ncw\n#&gt;        day  group chick_id weight_g weight_kg\n#&gt;      &lt;int&gt; &lt;char&gt;    &lt;int&gt;    &lt;num&gt;     &lt;num&gt;\n#&gt;   1:     0 diet 1       18       39     0.039\n#&gt;   2:     2 diet 1       18       35     0.035\n#&gt;   3:     0 diet 1       16       41     0.041\n#&gt;   4:     2 diet 1       16       45     0.045\n#&gt;   5:     4 diet 1       16       49     0.049\n#&gt;  ---                                         \n#&gt; 574:    14 diet 4       48      170     0.170\n#&gt; 575:    16 diet 4       48      222     0.222\n#&gt; 576:    18 diet 4       48      261     0.261\n#&gt; 577:    20 diet 4       48      303     0.303\n#&gt; 578:    21 diet 4       48      322     0.322\n\n\n\nExercise 3.5\nAnswer\n\n\n\n\nCreate a copy of cw using x &lt;- copy(cw)\n\nIn x, add a weight variable weight_oz in ounces (28.35 grams per ounce). Round the answer to the nearest tenth.\n\n\n\n\nx &lt;- copy(cw)\nx[, weight_oz := round(weight_g / 28.35, 1)]\nx\n#&gt;        day  group chick_id weight_g weight_kg weight_oz\n#&gt;      &lt;int&gt; &lt;char&gt;    &lt;int&gt;    &lt;num&gt;     &lt;num&gt;     &lt;num&gt;\n#&gt;   1:     0 diet 1       18       39     0.039       1.4\n#&gt;   2:     2 diet 1       18       35     0.035       1.2\n#&gt;   3:     0 diet 1       16       41     0.041       1.4\n#&gt;   4:     2 diet 1       16       45     0.045       1.6\n#&gt;   5:     4 diet 1       16       49     0.049       1.7\n#&gt;  ---                                                   \n#&gt; 574:    14 diet 4       48      170     0.170       6.0\n#&gt; 575:    16 diet 4       48      222     0.222       7.8\n#&gt; 576:    18 diet 4       48      261     0.261       9.2\n#&gt; 577:    20 diet 4       48      303     0.303      10.7\n#&gt; 578:    21 diet 4       48      322     0.322      11.4\n\n\n\n\nj to delete a variable. Assigning NULL by reference deletes the variable.\n\n# delete a column\ncw[, weight_kg := NULL]\n\n# view\ncw\n#&gt;        day  group chick_id weight_g\n#&gt;      &lt;int&gt; &lt;char&gt;    &lt;int&gt;    &lt;num&gt;\n#&gt;   1:     0 diet 1       18       39\n#&gt;   2:     2 diet 1       18       35\n#&gt;   3:     0 diet 1       16       41\n#&gt;   4:     2 diet 1       16       45\n#&gt;   5:     4 diet 1       16       49\n#&gt;  ---                               \n#&gt; 574:    14 diet 4       48      170\n#&gt; 575:    16 diet 4       48      222\n#&gt; 576:    18 diet 4       48      261\n#&gt; 577:    20 diet 4       48      303\n#&gt; 578:    21 diet 4       48      322\n\n\n\nExercise 3.6\nAnswer\n\n\n\nUsing the x data frame from the previous exercise, delete the weight variables in grams and kilograms.\n\n\n\nx[, weight_g := NULL]\nx[, weight_kg := NULL]\nx\n#&gt;        day  group chick_id weight_oz\n#&gt;      &lt;int&gt; &lt;char&gt;    &lt;int&gt;     &lt;num&gt;\n#&gt;   1:     0 diet 1       18       1.4\n#&gt;   2:     2 diet 1       18       1.2\n#&gt;   3:     0 diet 1       16       1.4\n#&gt;   4:     2 diet 1       16       1.6\n#&gt;   5:     4 diet 1       16       1.7\n#&gt;  ---                                \n#&gt; 574:    14 diet 4       48       6.0\n#&gt; 575:    16 diet 4       48       7.8\n#&gt; 576:    18 diet 4       48       9.2\n#&gt; 577:    20 diet 4       48      10.7\n#&gt; 578:    21 diet 4       48      11.4",
    "crumbs": [
      "Tutorial links",
      "R data basics"
    ]
  },
  {
    "objectID": "data-basics.html#row-operations",
    "href": "data-basics.html#row-operations",
    "title": "R data basics",
    "section": "Row operations",
    "text": "Row operations\ni to filter by values. Use relational operators to compare values.\n\n# subset by observation\ny &lt;- cw[day == 21 & weight_g &gt; 300]\n\n# view\ny\n#&gt;      day  group chick_id weight_g\n#&gt;    &lt;int&gt; &lt;char&gt;    &lt;int&gt;    &lt;num&gt;\n#&gt; 1:    21 diet 1        7      305\n#&gt; 2:    21 diet 2       29      309\n#&gt; 3:    21 diet 2       21      331\n#&gt; 4:    21 diet 3       32      305\n#&gt; 5:    21 diet 3       40      321\n#&gt; 6:    21 diet 3       34      341\n#&gt; 7:    21 diet 3       35      373\n#&gt; 8:    21 diet 4       48      322\n\nFor comparing values in vectors use: &lt; (less than), &gt; (greater than), &lt;= (less than or equal to), &gt;= (greater than or equal to), == (equal to), and != (not equal to). These can be combined logically using & (and) and | (or).\n\n\nExercise 3.7\nAnswer\n\n\n\n\nCreate a copy of cw using x &lt;- copy(cw)\n\nFilter x to retain all observations on day 4, diet 3\n\n\n\n\nx &lt;- copy(cw)\nx &lt;- x[day == 4 & group == \"diet 3\"]\nx\n#&gt;       day  group chick_id weight_g\n#&gt;     &lt;int&gt; &lt;char&gt;    &lt;int&gt;    &lt;num&gt;\n#&gt;  1:     4 diet 3       33       63\n#&gt;  2:     4 diet 3       37       56\n#&gt;  3:     4 diet 3       36       61\n#&gt;  4:     4 diet 3       31       62\n#&gt;  5:     4 diet 3       39       61\n#&gt;  6:     4 diet 3       38       61\n#&gt;  7:     4 diet 3       32       65\n#&gt;  8:     4 diet 3       40       66\n#&gt;  9:     4 diet 3       34       63\n#&gt; 10:     4 diet 3       35       64\n\n\n\n\ni to arrange rows.\n\n# order rows by values in columns\ny &lt;- cw[order(weight_g, day)]\n\n# view\ny\n#&gt;        day  group chick_id weight_g\n#&gt;      &lt;int&gt; &lt;char&gt;    &lt;int&gt;    &lt;num&gt;\n#&gt;   1:     2 diet 1       18       35\n#&gt;   2:     0 diet 1       18       39\n#&gt;   3:     0 diet 2       27       39\n#&gt;   4:     0 diet 2       28       39\n#&gt;   5:     0 diet 2       29       39\n#&gt;  ---                               \n#&gt; 574:    21 diet 2       21      331\n#&gt; 575:    18 diet 3       35      332\n#&gt; 576:    21 diet 3       34      341\n#&gt; 577:    20 diet 3       35      361\n#&gt; 578:    21 diet 3       35      373\n\n\n\nExercise 3.8\nAnswer\n\n\n\n\nCreate a copy of cw using x &lt;- copy(cw)\n\nArrange rows of x by group and day\n\n\n\n\nx &lt;- copy(cw)\nx &lt;- x[order(group, day)]\nx\n#&gt;        day  group chick_id weight_g\n#&gt;      &lt;int&gt; &lt;char&gt;    &lt;int&gt;    &lt;num&gt;\n#&gt;   1:     0 diet 1       18       39\n#&gt;   2:     0 diet 1       16       41\n#&gt;   3:     0 diet 1       15       41\n#&gt;   4:     0 diet 1       13       41\n#&gt;   5:     0 diet 1        9       42\n#&gt;  ---                               \n#&gt; 574:    21 diet 4       49      237\n#&gt; 575:    21 diet 4       46      238\n#&gt; 576:    21 diet 4       50      264\n#&gt; 577:    21 diet 4       42      281\n#&gt; 578:    21 diet 4       48      322\n\n\n\n\ni to filter by index.\n\n# subset by position\ny &lt;- cw[1:10]\n\n# view\ny\n#&gt;       day  group chick_id weight_g\n#&gt;     &lt;int&gt; &lt;char&gt;    &lt;int&gt;    &lt;num&gt;\n#&gt;  1:     0 diet 1       18       39\n#&gt;  2:     2 diet 1       18       35\n#&gt;  3:     0 diet 1       16       41\n#&gt;  4:     2 diet 1       16       45\n#&gt;  5:     4 diet 1       16       49\n#&gt;  6:     6 diet 1       16       51\n#&gt;  7:     8 diet 1       16       57\n#&gt;  8:    10 diet 1       16       51\n#&gt;  9:    12 diet 1       16       54\n#&gt; 10:     0 diet 1       15       41\n\n\n\nExercise 3.9\nAnswer\n\n\n\nUsing the x data frame from the previous exercise, filter to retain the last 10 rows.\n\n\n\nx &lt;- x[569:578]\nx\n#&gt;       day  group chick_id weight_g\n#&gt;     &lt;int&gt; &lt;char&gt;    &lt;int&gt;    &lt;num&gt;\n#&gt;  1:    20 diet 4       48      303\n#&gt;  2:    21 diet 4       45      196\n#&gt;  3:    21 diet 4       43      200\n#&gt;  4:    21 diet 4       41      204\n#&gt;  5:    21 diet 4       47      205\n#&gt;  6:    21 diet 4       49      237\n#&gt;  7:    21 diet 4       46      238\n#&gt;  8:    21 diet 4       50      264\n#&gt;  9:    21 diet 4       42      281\n#&gt; 10:    21 diet 4       48      322",
    "crumbs": [
      "Tutorial links",
      "R data basics"
    ]
  },
  {
    "objectID": "data-basics.html#group-and-summarize",
    "href": "data-basics.html#group-and-summarize",
    "title": "R data basics",
    "section": "Group and summarize",
    "text": "Group and summarize\nby to count. .N is a data.table function that yields the number of observations (rows) in a group identified with the by argument.\n\n# count number of chicks by diet group\ny &lt;- cw[, .(N_chicks = .N), by = c(\"group\")]\n\n# view\ny\n#&gt;     group N_chicks\n#&gt;    &lt;char&gt;    &lt;int&gt;\n#&gt; 1: diet 1      220\n#&gt; 2: diet 2      120\n#&gt; 3: diet 3      120\n#&gt; 4: diet 4      118\n\n\n\nExercise 3.10\nAnswer\n\n\n\n\nCreate a copy of cw using x &lt;- copy(cw)\n\nCount the number of observations by day. Name the variable count\n\n\n\n\n\nx &lt;- copy(cw)\nx &lt;- x[, .(count = .N), by = c(\"day\")]\nx\n#&gt;       day count\n#&gt;     &lt;int&gt; &lt;int&gt;\n#&gt;  1:     0    50\n#&gt;  2:     2    50\n#&gt;  3:     4    49\n#&gt;  4:     6    49\n#&gt;  5:     8    49\n#&gt;  6:    10    49\n#&gt;  7:    12    49\n#&gt;  8:    14    48\n#&gt;  9:    16    47\n#&gt; 10:    18    47\n#&gt; 11:    20    46\n#&gt; 12:    21    45\n\n\n\n\nby to summarize. Yields three new variables for count, mean, and standard deviation by the two grouping variables group and day.\n\n# compute summary statistics grouped by two variables\ny &lt;- cw[,                                         # i (empty)\n        .(N_chicks = .N,                          # j\n          mean_wt_g = round(mean(weight_g), 1),   # j (cont.)\n          std_dev_wt_g = round(sd(weight_g), 1)), # j (cont.)\n        by = c(\"group\", \"day\")]                   # by\n\n# view\ny\n#&gt;      group   day N_chicks mean_wt_g std_dev_wt_g\n#&gt;     &lt;char&gt; &lt;int&gt;    &lt;int&gt;     &lt;num&gt;        &lt;num&gt;\n#&gt;  1: diet 1     0       20      41.4          1.0\n#&gt;  2: diet 1     2       20      47.2          4.3\n#&gt;  3: diet 1     4       19      56.5          4.1\n#&gt;  4: diet 1     6       19      66.8          7.8\n#&gt;  5: diet 1     8       19      79.7         13.8\n#&gt; ---                                             \n#&gt; 44: diet 4    14       10     161.8         15.7\n#&gt; 45: diet 4    16       10     182.0         25.3\n#&gt; 46: diet 4    18       10     202.9         33.6\n#&gt; 47: diet 4    20        9     233.9         37.6\n#&gt; 48: diet 4    21        9     238.6         43.3\n\n\n\nExercise 3.11\nAnswer\n\n\n\n\nCreate a copy of cw using x &lt;- copy(cw)\n\nCount the number of chicks in x by group and day. Name the variable count\n\n\n\n\n\nx &lt;- copy(cw)\nx &lt;- x[, .(count = .N), by = c(\"group\", \"day\")]\nx\n#&gt;      group   day count\n#&gt;     &lt;char&gt; &lt;int&gt; &lt;int&gt;\n#&gt;  1: diet 1     0    20\n#&gt;  2: diet 1     2    20\n#&gt;  3: diet 1     4    19\n#&gt;  4: diet 1     6    19\n#&gt;  5: diet 1     8    19\n#&gt; ---                   \n#&gt; 44: diet 4    14    10\n#&gt; 45: diet 4    16    10\n#&gt; 46: diet 4    18    10\n#&gt; 47: diet 4    20     9\n#&gt; 48: diet 4    21     9",
    "crumbs": [
      "Tutorial links",
      "R data basics"
    ]
  },
  {
    "objectID": "data-basics.html#combine-operations",
    "href": "data-basics.html#combine-operations",
    "title": "R data basics",
    "section": "Combine operations",
    "text": "Combine operations\n[i, j, by] in combination. In this example, we use i to filter for two specific days, j to create new summary variables grouped by variables group and day. The results are the count N plus weight statistics: mean, standard deviation, median, minimum, and maximum.\n\n# grouped summaries of specific observations\ncw_stats &lt;- cw[day %in% c(0, 21),                         # i\n               .(N = .N,                                  # j\n                 mean_wt_g    = round(mean(weight_g), 0), # j (cont.)\n                 std_dev_wt_g = round(sd(weight_g), 1),   # j (cont.)\n                 median_wt_g  = median(weight_g),         # j (cont.)\n                 min_wt_g     = min(weight_g),            # j (cont.)\n                 max_wt_g     = max(weight_g)),           # j (cont.)\n               by = .(group, day)]                        # by\n\n# view\ncw_stats\n#&gt;     group   day     N mean_wt_g std_dev_wt_g median_wt_g min_wt_g max_wt_g\n#&gt;    &lt;char&gt; &lt;int&gt; &lt;int&gt;     &lt;num&gt;        &lt;num&gt;       &lt;num&gt;    &lt;num&gt;    &lt;num&gt;\n#&gt; 1: diet 1     0    20        41          1.0        41.0       39       43\n#&gt; 2: diet 1    21    16       178         58.7       166.0       96      305\n#&gt; 3: diet 2     0    10        41          1.5        40.5       39       43\n#&gt; 4: diet 2    21    10       215         78.1       212.5       74      331\n#&gt; 5: diet 3     0    10        41          1.0        41.0       39       42\n#&gt; 6: diet 3    21    10       270         71.6       281.0      147      373\n#&gt; 7: diet 4     0    10        41          1.1        41.0       39       42\n#&gt; 8: diet 4    21     9       239         43.3       237.0      196      322",
    "crumbs": [
      "Tutorial links",
      "R data basics"
    ]
  },
  {
    "objectID": "data-basics.html#create-a-table",
    "href": "data-basics.html#create-a-table",
    "title": "R data basics",
    "section": "Create a table",
    "text": "Create a table\nFinally, we can make the summaries “prettier” for a possible report or publication where we format the numeric values as text and edit the column names for readability just before printing.\n\n# combine mean and std dev into a single character column\ncw_stats[, mean_sd := paste0(mean_wt_g, \" (\", std_dev_wt_g, \")\")]\n\n# combine min and max into a range column\ncw_stats[, range := paste0(min_wt_g, \"--\", max_wt_g)]\n\n# retain specific columns\ncw_stats &lt;- cw_stats[ , .(group, day, N, mean_sd, median_wt_g, range)]\n\n# order the rows\ncw_stats &lt;- cw_stats[order(group, day)]\n\n# edit the column names for readability \nsetnames(cw_stats,\n         old = c(\"group\", \"day\", \"median_wt_g\",\"mean_sd\", \"range\"),\n         new = c(\"Group\", \"Day\", \"Median\", \"Mean [SD]\", \"Range\"))\n\n# view\ncw_stats\n#&gt;     Group   Day     N  Mean [SD] Median    Range\n#&gt;    &lt;char&gt; &lt;int&gt; &lt;int&gt;     &lt;char&gt;  &lt;num&gt;   &lt;char&gt;\n#&gt; 1: diet 1     0    20     41 (1)   41.0   39--43\n#&gt; 2: diet 1    21    16 178 (58.7)  166.0  96--305\n#&gt; 3: diet 2     0    10   41 (1.5)   40.5   39--43\n#&gt; 4: diet 2    21    10 215 (78.1)  212.5  74--331\n#&gt; 5: diet 3     0    10     41 (1)   41.0   39--42\n#&gt; 6: diet 3    21    10 270 (71.6)  281.0 147--373\n#&gt; 7: diet 4     0    10   41 (1.1)   41.0   39--42\n#&gt; 8: diet 4    21     9 239 (43.3)  237.0 196--322\n\nEventually you should be able to produce a publication-ready version such as the following table, using Rmarkdown and the knitr package. Full details are available in other sources.\n\n\n\nTable 1. Chick weight summary statistics (grams).\n\nGroup\nDay\nN\nMean [SD]\nMedian\nRange\n\n\n\ndiet 1\n0\n20\n41 (1)\n41.0\n39–43\n\n\ndiet 1\n21\n16\n178 (58.7)\n166.0\n96–305\n\n\ndiet 2\n0\n10\n41 (1.5)\n40.5\n39–43\n\n\ndiet 2\n21\n10\n215 (78.1)\n212.5\n74–331\n\n\ndiet 3\n0\n10\n41 (1)\n41.0\n39–42\n\n\ndiet 3\n21\n10\n270 (71.6)\n281.0\n147–373\n\n\ndiet 4\n0\n10\n41 (1.1)\n41.0\n39–42\n\n\ndiet 4\n21\n9\n239 (43.3)\n237.0\n196–322\n\n\n\n\n\nInterpretation. This summary table offers similar results to those revealed in the charts,\n\nin day 21, diet 3 has the highest mean and median weights\nin day 21, diet 4 has the least variability in weight\n\nIn addition, we note that by day 21, diet 1 lost 4 chicks of 20 that started and diet 4 lost 1 of 10. This could be a sign of unsafe conditions.",
    "crumbs": [
      "Tutorial links",
      "R data basics"
    ]
  },
  {
    "objectID": "data-basics.html#conclusion",
    "href": "data-basics.html#conclusion",
    "title": "R data basics",
    "section": "Conclusion",
    "text": "Conclusion\nThe R basics, R chart basics, and R data basics guides introduced you to some of the basic concepts for using R and the data.table and ggplot2 packages to manipulate data and create charts. It is only an introduction to what R can do but hopefully you have seen some of the potential of using R for data science.\nNext steps. There are plenty of R courses, books, and online resources that you can learn from. Find things that work for you and don’t be afraid to make mistakes or ask questions.\nDuring the MIDFIELD workshops, you will build on what you’ve learned here, and use the midfieldr package to study student unit records. You can preview that material on the midfieldr website.",
    "crumbs": [
      "Tutorial links",
      "R data basics"
    ]
  },
  {
    "objectID": "data-shaping-01-data-selection.html",
    "href": "data-shaping-01-data-selection.html",
    "title": "Data selection",
    "section": "",
    "text": "Image: Select by Mike Lawrence is licensed under CC BY 2.0\nUsing base R, data.table, and dplyr/tidyr to transform MIDFIELD data as needed for your analysis.\nIn this section we demonstrate subsetting rows and columns in various configurations, removing records with incomplete data, and reordering rows and columns.",
    "crumbs": [
      "Shaping data 3 ways",
      "Data selection"
    ]
  },
  {
    "objectID": "data-shaping-01-data-selection.html#setup",
    "href": "data-shaping-01-data-selection.html#setup",
    "title": "Data selection",
    "section": "Setup",
    "text": "Setup\nLoad packages.\n\nlibrary(\"midfielddata\")\nlibrary(\"data.table\")\nlibrary(\"dplyr\", warn.conflicts = FALSE)\nlibrary(\"tidyr\")\nlibrary(\"wrapr\")\n\nFormat data as described in the Introduction.\n\ndata(student, term)\n\n\n# base R\nstudent_df &lt;- data.frame(student)\nterm_df &lt;- data.frame(term)\n\n\n# data.table\nstudent_dt &lt;- copy(student)\nterm_dt &lt;- copy(term)\n\n\n# dplyr\nstudent_tbl &lt;- tibble(student)\nterm_tbl &lt;- tibble(term)",
    "crumbs": [
      "Shaping data 3 ways",
      "Data selection"
    ]
  },
  {
    "objectID": "data-shaping-01-data-selection.html#subsetting-rows-and-columns",
    "href": "data-shaping-01-data-selection.html#subsetting-rows-and-columns",
    "title": "Data selection",
    "section": "Subsetting rows and columns",
    "text": "Subsetting rows and columns\nA common task when working with data is selecting a subset of rows, columns, or both.\nIndirect indexing\nUsing intermediate variables columns_we_want and rows_we_want that refer to the values used to subset rows and columns.\nTask. Prepare data to summarize domestic students by race, sex, and institution.\nOur first step might be to subset columns (institution, race, sex, and us_citizen) and subset rows such that US citizenship is true.\n\n# character vector of column names\ncolumns_we_want &lt;- c(\"institution\", \"race\", \"sex\", \"us_citizen\")\n\n\n# base R\nrows_we_want &lt;- student_df$us_citizen == \"Yes\"\nresult_df &lt;- student_df[rows_we_want, columns_we_want, drop = FALSE]\n\n\n# data.table\nrows_we_want &lt;- student_dt$us_citizen == \"Yes\"\nresult_dt &lt;- student_dt[rows_we_want, ..columns_we_want]\n\n\n# dplyr\nrows_we_want &lt;- student_tbl$us_citizen == \"Yes\"\nresult_tbl &lt;- student_tbl %&gt;%\n  select(all_of(columns_we_want)) %&gt;%\n  filter(rows_we_want)\n\n\nresult_dt\n#&gt;          institution          race    sex us_citizen\n#&gt;               &lt;char&gt;        &lt;char&gt; &lt;char&gt;     &lt;char&gt;\n#&gt;     1: Institution B         Asian   Male        Yes\n#&gt;     2: Institution J         Asian Female        Yes\n#&gt;     3: Institution J         Asian   Male        Yes\n#&gt;     4: Institution J         Asian   Male        Yes\n#&gt;     5: Institution J         Asian   Male        Yes\n#&gt;    ---                                              \n#&gt; 90387: Institution B         White Female        Yes\n#&gt; 90388: Institution B         White Female        Yes\n#&gt; 90389: Institution B         White Female        Yes\n#&gt; 90390: Institution B         White Female        Yes\n#&gt; 90391: Institution B Other/Unknown   Male        Yes\n\ncheck_equiv_frames(result_df, result_dt)\n#&gt; [1] TRUE\ncheck_equiv_frames(result_dt, result_tbl)\n#&gt; [1] TRUE\n\nComments\n\nbase R. Base R’s default behavior when selecting a single column is to return a vector. Thus, when working with [,] always add a third argument drop = FALSE to ensure a data frame is returned.\ndata.table. The .. notation indicates that columns_we_want refers to a character vector of column names and is not itself a column name.\ndplyr. The added notation all_of() in effect serves the same purpose in dplyr as .. does in data.table.\nDirect indexing\nColumn and row selection that is typed directly into the subsetting operators [,] or filter() and select() without using intermediate variables.\nTask. Same as previous example.\n\n# base R\nresult_df &lt;- student_df[student_df$us_citizen == \"Yes\",\n  c(\"institution\", \"race\", \"sex\", \"us_citizen\"),\n  drop = FALSE\n]\n\n\n# data.table\nresult_dt &lt;- student_dt[us_citizen == \"Yes\", .(institution, race, sex, us_citizen)]\n\n\n# dplyr\nresult_tbl &lt;- student_tbl %&gt;%\n  select(institution, race, sex, us_citizen) %&gt;%\n  filter(us_citizen == \"Yes\")\n\n\nresult_dt\n#&gt;          institution          race    sex us_citizen\n#&gt;               &lt;char&gt;        &lt;char&gt; &lt;char&gt;     &lt;char&gt;\n#&gt;     1: Institution B         Asian   Male        Yes\n#&gt;     2: Institution J         Asian Female        Yes\n#&gt;     3: Institution J         Asian   Male        Yes\n#&gt;     4: Institution J         Asian   Male        Yes\n#&gt;     5: Institution J         Asian   Male        Yes\n#&gt;    ---                                              \n#&gt; 90387: Institution B         White Female        Yes\n#&gt; 90388: Institution B         White Female        Yes\n#&gt; 90389: Institution B         White Female        Yes\n#&gt; 90390: Institution B         White Female        Yes\n#&gt; 90391: Institution B Other/Unknown   Male        Yes\n\ncheck_equiv_frames(result_df, result_dt)\n#&gt; [1] TRUE\ncheck_equiv_frames(result_dt, result_tbl)\n#&gt; [1] TRUE\n\nComments\n\nbase R. For direct indexing, intermediate variable names in [,] are replaced verbatim by their values.\ndata.table. The notation .() subsets columns by name without quotation marks; rows are subset without the $ operator.\ndplyr. Similarly, select() operates on unquoted column names; rows are subset without the $ operator.\nSubset rows with multiple conditions\nMultiple logical conditions are combined with operators such as & (and), | (or), ! (not), etc.\nTask. Find IDs of transfer students with 15 or more credit hours transferred.\nWhen a variable is overwritten multiple times to get to a result, we will sometimes employ the variable DF as an intermediate variable.\n\ncolumns_we_want &lt;- c(\"mcid\", \"transfer\", \"hours_transfer\")\n\n\n# base R\nrows_we_want &lt;- student_df$transfer == \"First-Time Transfer\" & student_df$hours_transfer &gt;= 15\nDF &lt;- student_df[rows_we_want, columns_we_want, drop = FALSE]\n\n# remove rows with NA in every column\nrows_we_want &lt;- rowSums(is.na(DF)) &lt; ncol(DF)\nresult_df &lt;- DF[rows_we_want, , drop = FALSE]\n\n\n# data.table\nresult_dt &lt;- student_dt[transfer == \"First-Time Transfer\" & hours_transfer &gt;= 15, ..columns_we_want]\n\n\n# dplyr\nresult_tbl &lt;- student_tbl %&gt;%\n  select(mcid, transfer, hours_transfer) %&gt;%\n  filter(transfer == \"First-Time Transfer\" & hours_transfer &gt;= 15)\n\n\nresult_dt\n#&gt;                 mcid            transfer hours_transfer\n#&gt;               &lt;char&gt;              &lt;char&gt;          &lt;num&gt;\n#&gt;    1: MCID3111142840 First-Time Transfer             44\n#&gt;    2: MCID3111142895 First-Time Transfer             16\n#&gt;    3: MCID3111142910 First-Time Transfer             41\n#&gt;    4: MCID3111142914 First-Time Transfer            156\n#&gt;    5: MCID3111142983 First-Time Transfer             24\n#&gt;   ---                                                  \n#&gt; 9458: MCID3112898091 First-Time Transfer            110\n#&gt; 9459: MCID3112898410 First-Time Transfer             71\n#&gt; 9460: MCID3112898411 First-Time Transfer             68\n#&gt; 9461: MCID3112898412 First-Time Transfer             30\n#&gt; 9462: MCID3112898801 First-Time Transfer            218\n\ncheck_equiv_frames(result_df, result_dt)\n#&gt; [1] TRUE\ncheck_equiv_frames(result_dt, result_tbl)\n#&gt; [1] TRUE\n\nComments\n\nbase R. Two steps required. Subset rows by the original logical conditions; then subset to remove rows with NA across all columns. rowSums() assigns 1 to TRUE and 0 to FALSE. If the number of NAs in a row is less than the number of columns, then that row contains non-NA data and we keep it.\ndata.table. Multiple conditions separated by logical AND &. Does not generate all-NA rows as in base R.\ndplyr. Similar.\nSubset rows to omit values\nSometimes the intention of a row subset is to keep all rows except those that contain a particular value—implemented with a logical NOT (!).\nTask. Retain all rows of the student data except those with an “unknown” value (case-insensitive) in the sex column.\n\n# base R\nrows_we_want &lt;- !grepl(\"unknown\", student_df$sex, ignore.case = TRUE)\nresult_df &lt;- student_df[rows_we_want, , drop = FALSE]\n\n\n# data.table\nresult_dt &lt;- student_dt[!sex %ilike% \"unknown\"]\n\n\n# dplyr\nresult_tbl &lt;- student_tbl %&gt;%\n  filter(!grepl(\"unknown\", sex, ignore.case = TRUE))\n\n\nglimpse(result_dt)\n#&gt; Rows: 97,554\n#&gt; Columns: 13\n#&gt; $ mcid           &lt;chr&gt; \"MCID3111142225\", \"MCID3111142283\", \"MCID3111142290\", \"…\n#&gt; $ institution    &lt;chr&gt; \"Institution B\", \"Institution J\", \"Institution J\", \"Ins…\n#&gt; $ transfer       &lt;chr&gt; \"First-Time Transfer\", \"First-Time Transfer\", \"First-Ti…\n#&gt; $ hours_transfer &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n#&gt; $ race           &lt;chr&gt; \"Asian\", \"Asian\", \"Asian\", \"Asian\", \"Asian\", \"Asian\", \"…\n#&gt; $ sex            &lt;chr&gt; \"Male\", \"Female\", \"Male\", \"Male\", \"Male\", \"Male\", \"Male…\n#&gt; $ age_desc       &lt;chr&gt; \"Under 25\", \"Under 25\", \"Under 25\", \"Under 25\", \"Under …\n#&gt; $ us_citizen     &lt;chr&gt; \"Yes\", \"Yes\", \"Yes\", \"Yes\", \"Yes\", \"Yes\", \"Yes\", \"Yes\",…\n#&gt; $ home_zip       &lt;chr&gt; NA, \"22020\", \"23233\", \"20853\", \"22003\", \"23234\", \"24148…\n#&gt; $ high_school    &lt;chr&gt; NA, NA, \"471872\", NA, \"470080\", \"471877\", NA, NA, NA, N…\n#&gt; $ sat_math       &lt;dbl&gt; NA, 560, 510, 640, 600, 570, 480, NA, NA, NA, 520, 430,…\n#&gt; $ sat_verbal     &lt;dbl&gt; NA, 230, 380, 460, 500, 530, 530, NA, NA, NA, 490, 490,…\n#&gt; $ act_comp       &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n\ncheck_equiv_frames(result_df, result_dt)\n#&gt; [1] TRUE\ncheck_equiv_frames(result_dt, result_tbl)\n#&gt; [1] TRUE\n\nComments\n\nbase R. Uses grepl()\ndata.table. %ilike% is shorthand for grepl() with ignore.case = TRUE\ndplyr. Also uses grepl()\n\nConfirm that the correct rows have been deleted.\n\n# Before deletions\nsort(unique(student_dt$sex))\n#&gt; [1] \"Female\"  \"Male\"    \"Unknown\"\n# After deletions \nsort(unique(result_dt$sex))\n#&gt; [1] \"Female\" \"Male\"\n\nSubset one column as a vector\nTask. Obtain a vector (vec) of unique IDs in the term dataset.\nBecause results are vectors, we compare using all.equal() instead of check_equiv_frames().\n\n# base R\nvec_base &lt;- term_df[, \"mcid\"]\nvec_base &lt;- unique(vec_base)\n\n\n# data.table\nvec_dtbl &lt;- term_dt[, mcid]\nvec_dtbl &lt;- unique(vec_dtbl)\n\n\n# dplyr\nvec_dplyr &lt;- term_tbl %&gt;%\n  pull(mcid) %&gt;%\n  unique()\n\n\nstr(vec_dtbl)\n#&gt;  chr [1:97555] \"MCID3111142225\" \"MCID3111142283\" \"MCID3111142290\" ...\n\nall.equal(vec_base, vec_dtbl)\n#&gt; [1] TRUE\nall.equal(vec_dtbl, vec_dplyr)\n#&gt; [1] TRUE\n\nComments\n\nbase R. For clarity, we deliberately write these steps in two lines of code. One could just as easily write the single line result_df &lt;- unique(term_df[, \"mcid\"]).\ndata.table.\ndplyr. pull(mcid) is safe as long as the mcid column exists in the data frame from which it is pulled. Safer to use pull(.data$mcid) as described in (Layton, 2024).",
    "crumbs": [
      "Shaping data 3 ways",
      "Data selection"
    ]
  },
  {
    "objectID": "data-shaping-01-data-selection.html#removing-rows-with-incomplete-records",
    "href": "data-shaping-01-data-selection.html#removing-rows-with-incomplete-records",
    "title": "Data selection",
    "section": "Removing rows with incomplete records",
    "text": "Removing rows with incomplete records\nAn important variation of subsetting data is removing rows of data that have missing values. If appropriate, limit the dropped rows to those with missing values in specific columns.\nTask. We are asked to compare SAT scores by institution. Before doing any analysis, we first remove rows with missing SAT scores.\nDelete rows with a missing value in any column.\n\n# base R\nDF &lt;- student_df[, c(\"institution\", \"sat_math\", \"sat_verbal\"), drop = FALSE]\nresult_df &lt;- na.omit(DF)\n\n\n# data.table\nDT &lt;- student_dt[, .(institution, sat_math, sat_verbal)]\nresult_dt &lt;- na.omit(DT)\n\n\n# dplyr\nresult_tbl &lt;- student_tbl %&gt;%\n  select(institution, sat_math, sat_verbal) %&gt;%\n  drop_na()\n\n\nresult_dt\n#&gt;          institution sat_math sat_verbal\n#&gt;               &lt;char&gt;    &lt;num&gt;      &lt;num&gt;\n#&gt;     1: Institution J      560        230\n#&gt;     2: Institution J      510        380\n#&gt;     3: Institution J      640        460\n#&gt;     4: Institution J      600        500\n#&gt;     5: Institution J      570        530\n#&gt;    ---                                  \n#&gt; 77096: Institution B      530        560\n#&gt; 77097: Institution B      570        580\n#&gt; 77098: Institution B      510        590\n#&gt; 77099: Institution B      420        590\n#&gt; 77100: Institution B      470        540\n\ncheck_equiv_frames(result_df, result_dt)\n#&gt; [1] TRUE\ncheck_equiv_frames(result_dt, result_tbl)\n#&gt; [1] TRUE\n\nComments\n\nbase R. Where before we used the name columns_we_want to reference a character vector of column names, here we use the character vector itself.\ndata.table.\ndplyr. drop_na() is from the tidyr package.\nDelete rows with a missing value in specified colums.\nTask.\n\n# base R\nrows_we_want &lt;- !(is.na(student_df$institution) |\n  is.na(student_df$sat_math) |\n  is.na(student_df$sat_verbal))\nresult_df &lt;- student_df[rows_we_want, , drop = FALSE]\n\n\n# data.table\nresult_dt &lt;- na.omit(student_dt, cols = c(\"institution\", \"sat_math\", \"sat_verbal\"))\n\n\n# dplyr\nresult_tbl &lt;- student_tbl %&gt;%\n  drop_na(institution, sat_math, sat_verbal)\n\n\nresult_dt\n#&gt;                  mcid   institution              transfer hours_transfer\n#&gt;                &lt;char&gt;        &lt;char&gt;                &lt;char&gt;          &lt;num&gt;\n#&gt;     1: MCID3111142283 Institution J   First-Time Transfer             NA\n#&gt;     2: MCID3111142290 Institution J   First-Time Transfer             NA\n#&gt;     3: MCID3111142294 Institution J   First-Time Transfer             NA\n#&gt;     4: MCID3111142299 Institution J   First-Time Transfer             NA\n#&gt;     5: MCID3111142303 Institution J   First-Time Transfer             NA\n#&gt;    ---                                                                  \n#&gt; 77096: MCID3112898886 Institution B First-Time in College             NA\n#&gt; 77097: MCID3112898890 Institution B First-Time in College             NA\n#&gt; 77098: MCID3112898894 Institution B First-Time in College             NA\n#&gt; 77099: MCID3112898895 Institution B First-Time in College             NA\n#&gt; 77100: MCID3112898940 Institution B First-Time in College             NA\n#&gt;                 race    sex age_desc us_citizen home_zip high_school sat_math\n#&gt;               &lt;char&gt; &lt;char&gt;   &lt;char&gt;     &lt;char&gt;   &lt;char&gt;      &lt;char&gt;    &lt;num&gt;\n#&gt;     1:         Asian Female Under 25        Yes    22020        &lt;NA&gt;      560\n#&gt;     2:         Asian   Male Under 25        Yes    23233      471872      510\n#&gt;     3:         Asian   Male Under 25        Yes    20853        &lt;NA&gt;      640\n#&gt;     4:         Asian   Male Under 25        Yes    22003      470080      600\n#&gt;     5:         Asian   Male Under 25        Yes    23234      471877      570\n#&gt;    ---                                                                       \n#&gt; 77096:         White Female Under 25        Yes    53711      501165      530\n#&gt; 77097:         White Female Under 25        Yes    54956      501275      570\n#&gt; 77098:         White Female Under 25        Yes    53716      501160      510\n#&gt; 77099:         White Female Under 25        Yes    53029      500853      420\n#&gt; 77100: Other/Unknown   Male Under 25        Yes    20016      090073      470\n#&gt;        sat_verbal act_comp\n#&gt;             &lt;num&gt;    &lt;num&gt;\n#&gt;     1:        230       NA\n#&gt;     2:        380       NA\n#&gt;     3:        460       NA\n#&gt;     4:        500       NA\n#&gt;     5:        530       NA\n#&gt;    ---                    \n#&gt; 77096:        560       29\n#&gt; 77097:        580       25\n#&gt; 77098:        590       24\n#&gt; 77099:        590       32\n#&gt; 77100:        540       32\n\ncheck_equiv_frames(result_df, result_dt)\n#&gt; [1] TRUE\ncheck_equiv_frames(result_dt, result_tbl)\n#&gt; [1] TRUE\n\nComments\n\nbase R. Using logical operators ! NOT and | OR to create a logical vector used as a row index.\ndata.table. The same function name na.omit() as base R but with an argument to drops rows with missing values in specified columns. Retains all columns.\ndplyr. Similarly, drop_na() drops rows with missing values in specified columns, retaining all columns.",
    "crumbs": [
      "Shaping data 3 ways",
      "Data selection"
    ]
  },
  {
    "objectID": "data-shaping-01-data-selection.html#ordering-rows-or-columns",
    "href": "data-shaping-01-data-selection.html#ordering-rows-or-columns",
    "title": "Data selection",
    "section": "Ordering rows or columns",
    "text": "Ordering rows or columns\nWe sometimes using the intermediate variables order_index (integer vector) or order_cols (character vector) to emphasize the steps of the ordering process.\nAscending rows\nIn all three systems, the default sort order is increasing (ascending) from rows 1 to N.\nTask. Suppose we want to know a student’s level and declared major in their first term at their institution. We use the term dataset.\nWe decide to order the rows first by institution, then by ID, then by term. In each case, we select columns in a separate operation so we can highlight the row-ordering operation.\n\ncolumns_we_want &lt;- c(\"institution\", \"mcid\", \"term\", \"level\", \"cip6\")\n\n\n# base R\nDF &lt;- term_df[, columns_we_want, drop = FALSE]\norder_index &lt;- with(DF, order(institution, mcid, term))\nresult_df &lt;- DF[order_index, , drop = FALSE]\n\n\n# data.table\nresult_dt &lt;- term_dt[, ..columns_we_want]\norder_cols &lt;- c(\"institution\", \"mcid\", \"term\")\nsetorderv(result_dt, order_cols)\n\n\n# dplyr\nresult_tbl &lt;- term_tbl %&gt;%\n  select(institution, mcid, term, level, cip6) %&gt;%\n  arrange(institution, mcid, term)\n\n\nresult_dt\n#&gt;           institution           mcid   term         level   cip6\n#&gt;                &lt;char&gt;         &lt;char&gt; &lt;char&gt;        &lt;char&gt; &lt;char&gt;\n#&gt;      1: Institution B MCID3111142225  19881 01 First-year 140901\n#&gt;      2: Institution B MCID3111142689  19883 01 First-year 090401\n#&gt;      3: Institution B MCID3111142729  19881 01 First-year 141901\n#&gt;      4: Institution B MCID3111142729  19883 01 First-year 141901\n#&gt;      5: Institution B MCID3111142819  19881 01 First-year 230101\n#&gt;     ---                                                         \n#&gt; 639911: Institution J MCID3112447745  20096 01 First-year 040201\n#&gt; 639912: Institution J MCID3112447746  20096 01 First-year 190501\n#&gt; 639913: Institution J MCID3112447751  20096 01 First-year 240102\n#&gt; 639914: Institution J MCID3112447753  20096 01 First-year 520201\n#&gt; 639915: Institution J MCID3112447754  20096 01 First-year 240102\n\nall.equal(result_df, result_dt, check.attributes = FALSE)\n#&gt; [1] TRUE\nall.equal(result_dt, result_tbl, check.attributes = FALSE)\n#&gt; [1] TRUE\n\nComments\n\nbase R. Using with(), we can list the variables to order by without using the $ operator.\ndata.table. setorderv() reorders data in place—hence no assignment operator &lt;- is required—and it operates on a character vector of column names.\ndplyr. arrange() orders the rows of a data frame by the values of selected columns.\nDescending rows\nWhen we want a decreasing (descending) row order, it is typically needed for some but not all of our columns.\nTask. Sort students by institution and descending transfer hours.\n\ncolumns_we_want &lt;- c(\"institution\", \"mcid\", \"hours_transfer\")\n\n\n# base R\nDF &lt;- student_df[, columns_we_want, drop = FALSE]\nDF &lt;- na.omit(DF)\norder_index &lt;- with(DF, order(institution, -hours_transfer, mcid))\nresult_df &lt;- DF[order_index, , drop = FALSE]\n\n\n# data.table\nDT &lt;- student_dt[, ..columns_we_want]\nresult_dt &lt;- na.omit(DT)\norder_cols &lt;- c(\"institution\", \"hours_transfer\", \"mcid\")\nsetorderv(result_dt, order_cols, order = c(1, -1, 1))\n\n\n# dplyr\nresult_tbl &lt;- student_tbl %&gt;%\n  select(institution, mcid, hours_transfer) %&gt;%\n  drop_na() %&gt;%\n  arrange(institution, desc(hours_transfer), mcid)\n\n\nresult_dt\n#&gt;          institution           mcid hours_transfer\n#&gt;               &lt;char&gt;         &lt;char&gt;          &lt;num&gt;\n#&gt;     1: Institution B MCID3112694097            278\n#&gt;     2: Institution B MCID3112788655            271\n#&gt;     3: Institution B MCID3112693474            238\n#&gt;     4: Institution B MCID3112500991            229\n#&gt;     5: Institution B MCID3112879516            228\n#&gt;    ---                                            \n#&gt; 13925: Institution C MCID3112785098              1\n#&gt; 13926: Institution C MCID3112785144              1\n#&gt; 13927: Institution C MCID3112785478              1\n#&gt; 13928: Institution C MCID3112785480              1\n#&gt; 13929: Institution C MCID3112785484              1\n\nall.equal(result_df, result_dt, check.attributes = FALSE)\n#&gt; [1] TRUE\nall.equal(result_dt, result_tbl, check.attributes = FALSE)\n#&gt; [1] TRUE\n\nComments\n\nbase R. Base R does not provide a general way to sort individual variables in descending order, but a minus sign works with numerical variables. The decreasing argument, if used, applies to all variables.\ndata.table. In setorderv(), add the order argument with 1 for ascending and -1 for descending.\ndplyr. In arrange() apply desc() to the descending variable.\nOrdering columns\nWhenever we’ve subset columns using indirect or direct indexing, the placement of column names implicitly orders those columns. For example, using\n    columns_we_want &lt;- c(\"institution\", \"race\", \"sex\", \"us_citizen\")\nas a column index yields a data frame with the columns in the order given. Sometimes however we want to move one or more columns to the left in a data frame.\nTask. Using the result from the previous example, move transfer hours to the leftmost column followed by ID.\n\n# base R\ncolumn_order &lt;- union(c(\"hours_transfer\", \"mcid\"), names(result_df))\nresult_df &lt;- result_df[, column_order, drop = FALSE]\n\n\n# data.table\nsetcolorder(result_dt, c(\"hours_transfer\", \"mcid\"))\n\n\n# dplyr\nresult_tbl &lt;- result_tbl %&gt;%\n  relocate(hours_transfer, mcid)\n\n\nresult_dt\n#&gt;        hours_transfer           mcid   institution\n#&gt;                 &lt;num&gt;         &lt;char&gt;        &lt;char&gt;\n#&gt;     1:            278 MCID3112694097 Institution B\n#&gt;     2:            271 MCID3112788655 Institution B\n#&gt;     3:            238 MCID3112693474 Institution B\n#&gt;     4:            229 MCID3112500991 Institution B\n#&gt;     5:            228 MCID3112879516 Institution B\n#&gt;    ---                                            \n#&gt; 13925:              1 MCID3112785098 Institution C\n#&gt; 13926:              1 MCID3112785144 Institution C\n#&gt; 13927:              1 MCID3112785478 Institution C\n#&gt; 13928:              1 MCID3112785480 Institution C\n#&gt; 13929:              1 MCID3112785484 Institution C\n\nall.equal(result_df, result_dt, check.attributes = FALSE)\n#&gt; [1] TRUE\nall.equal(result_dt, result_tbl, check.attributes = FALSE)\n#&gt; [1] TRUE\n\nComments\n\nbase R. union() is a set operation that discards duplicated values. The resulting character vector contains all the column names, reordered, and sorting is performed by [.\ndata.table. setcolorder() changes the position of columns in a data frame, by reference, moving the specified columns to the “front”.\ndplyr. relocate() changes the position of columns in a data frame moving the specified columns to the “front”.",
    "crumbs": [
      "Shaping data 3 ways",
      "Data selection"
    ]
  },
  {
    "objectID": "data-shaping-01-data-selection.html#references",
    "href": "data-shaping-01-data-selection.html#references",
    "title": "Data selection",
    "section": "References",
    "text": "References\n\n\nLayton, R. (2024). A subtle flaw in pull(). Blog post. https://graphdr.github.io/data-stories/posts/2024-08-01-subtle-flaw-pull/",
    "crumbs": [
      "Shaping data 3 ways",
      "Data selection"
    ]
  },
  {
    "objectID": "data-shaping-03-aggregating-transforms.html",
    "href": "data-shaping-03-aggregating-transforms.html",
    "title": "Aggregating transforms",
    "section": "",
    "text": "Image: Our daily challenge: Too many to count by Sue Thompson is licensed under CC BY-ND 2.0\nUsing base R, data.table, and dplyr/tidyr to transform MIDFIELD data as needed for your analysis.\nIn this section we demonstrate aggregating many observations of a variable into a set of summary observations, typically grouped by one or more grouping variables. Summaries include counts as well as means, medians, quartiles, etc.",
    "crumbs": [
      "Shaping data 3 ways",
      "Aggregating transforms"
    ]
  },
  {
    "objectID": "data-shaping-03-aggregating-transforms.html#setup",
    "href": "data-shaping-03-aggregating-transforms.html#setup",
    "title": "Aggregating transforms",
    "section": "Setup",
    "text": "Setup\nLoad packages.\n\nlibrary(\"midfielddata\")\nlibrary(\"data.table\")\nlibrary(\"dplyr\", warn.conflicts = FALSE)\nlibrary(\"tidyr\")\nlibrary(\"wrapr\")\n\nFormat data as described in the Introduction.\n\ndata(student, term)\n\n\n# base R\nstudent_df &lt;- data.frame(student)\nterm_df &lt;- data.frame(term)\n\n\n# data.table\nstudent_dt &lt;- copy(student)\nterm_dt &lt;- copy(term)\n\n\n# dplyr\nstudent_tbl &lt;- tibble(student)\nterm_tbl &lt;- tibble(term)",
    "crumbs": [
      "Shaping data 3 ways",
      "Aggregating transforms"
    ]
  },
  {
    "objectID": "data-shaping-03-aggregating-transforms.html#counting",
    "href": "data-shaping-03-aggregating-transforms.html#counting",
    "title": "Aggregating transforms",
    "section": "Counting",
    "text": "Counting\nBase R offers several approaches to the task of counting by groups, for example, by(), aggregate(), table(), tapply(), or a split-apply-combine strategy. For counting, I think table() requires the least amount of cognitive overhead when the desired result is a data frame.\nWith one grouping variable\nTask. Count the number of students in the student dataset grouped by race.\n\n# base R\nfreq_table &lt;- table(student_df$race, dnn = \"race\")\nresult_df &lt;- as.data.frame(freq_table,\n                           responseName = \"N\", \n                           stringsAsFactors = FALSE)\n\n\n# data.table\nresult_dt &lt;- student_dt[, .N, by = c(\"race\")]\nsetorderv(result_dt, \"race\")\n\n\n# dplyr\nresult_tbl &lt;- student_tbl %&gt;%\n count(race, name = \"N\")\n\n\nresult_dt\n#&gt;               race     N\n#&gt;             &lt;char&gt; &lt;int&gt;\n#&gt; 1:           Asian  4193\n#&gt; 2:           Black  1860\n#&gt; 3:   International  7354\n#&gt; 4:          Latine  5386\n#&gt; 5: Native American   403\n#&gt; 6:   Other/Unknown  4509\n#&gt; 7:           White 73850\n\ncheck_equiv_frames(result_df, result_dt)\n#&gt; [1] TRUE\ncheck_equiv_frames(result_dt, result_tbl)\n#&gt; [1] TRUE\n\nComments\n\nbase R. table() creates a contingency table—counts of every combination of the grouping variables—that we convert to a data frame. Column names are assigned using the dnn and responseName arguments.\ndata.table. The .N function is an integer containing the number of rows in each group, with grouping variables assigned using the by argument. setorderv() is optional.\ndplyr. count() counts the number of unique values in a group. The response column name is assigned using the name argument (default is lower case n).\nWith two or more grouping variables\nData.table and dplyr count the frequency of each grouping-variable combination present in the data; base R counts the frequencies of all combinations, inserting counts of zero as needed.\nTask. Count the number of students in the student dataset grouped by institution, sex, and transfer status.\n\ngrouping_variables &lt;- c(\"institution\", \"sex\", \"transfer\")\n\n\n# base R\nfreq_table &lt;- table(student_df$institution,\n                    student_df$sex,\n                    student_df$transfer,\n                    dnn = grouping_variables)\nresult_df &lt;- as.data.frame(freq_table, \n                           responseName = \"N\", \n                           stringsAsFactors = FALSE)\nresult_df &lt;- result_df[result_df$N &gt; 0, , drop = FALSE]\n\n\n# data.table\nresult_dt &lt;- student_dt[, .N, by = grouping_variables]\nsetorderv(result_dt, c(\"institution\", \"N\"), order = c(1, -1))\n\n\n# dplyr\nresult_tbl &lt;- student_tbl %&gt;%\n count(institution, sex, transfer, name = \"N\") %&gt;%\n arrange(institution, desc(N))\n\n\nresult_dt\n#&gt;       institution     sex              transfer     N\n#&gt;            &lt;char&gt;  &lt;char&gt;                &lt;char&gt; &lt;int&gt;\n#&gt;  1: Institution B    Male First-Time in College 16998\n#&gt;  2: Institution B  Female First-Time in College 15689\n#&gt;  3: Institution B    Male   First-Time Transfer  6946\n#&gt;  4: Institution B  Female   First-Time Transfer  6026\n#&gt;  5: Institution B Unknown First-Time in College     1\n#&gt;  6: Institution C  Female First-Time in College  9991\n#&gt;  7: Institution C    Male First-Time in College  8779\n#&gt;  8: Institution C  Female   First-Time Transfer  3978\n#&gt;  9: Institution C    Male   First-Time Transfer  3964\n#&gt; 10: Institution J    Male First-Time in College 12051\n#&gt; 11: Institution J  Female First-Time in College  9180\n#&gt; 12: Institution J    Male   First-Time Transfer  2413\n#&gt; 13: Institution J  Female   First-Time Transfer  1539\n\ncheck_equiv_frames(result_df, result_dt)\n#&gt; [1] TRUE\ncheck_equiv_frames(result_dt, result_tbl)\n#&gt; [1] TRUE\n\nComments\n\nbase R. Similar to the previous case with more grouping variables plus dropping rows with a count of zero to match the other systems’ outputs.\ndata.table. Similar to the previous case with more grouping variables plus ordering rows by ascending institution (order = 1) and descending N (order = -1).\ndplyr. Similar to the previous case with more grouping variables plus arranging rows with ascending institution (default) and descending N using desc().",
    "crumbs": [
      "Shaping data 3 ways",
      "Aggregating transforms"
    ]
  },
  {
    "objectID": "data-shaping-03-aggregating-transforms.html#summarizing",
    "href": "data-shaping-03-aggregating-transforms.html#summarizing",
    "title": "Aggregating transforms",
    "section": "Summarizing",
    "text": "Summarizing\nStatistical summaries are commonly encountered to help describe trends in data, e.g., mean, median, standard deviation, minima, maxima, etc.\nOf the several summarizing options available in base R, by() seems the simplest to provide here. It generalizes easily to multiple and different summaries and the only cognitive overhead is the need to know about do.call(), rbind(), and anonymous functions.\nWith one grouping variable\nTask. Using the term data table, determine the 10% quantile, median, and 90% quantile of term GPA by academic standing (good standing, academic warning, etc.) plus the number of observations used in the summary. In all systems, we use the base R quanitile() function to determine the 10% and 90% quantiles.\n\n# base R\nDF &lt;- term_df[!is.na(term_df$gpa_term), , drop = FALSE]\nDF_by &lt;- by(DF, list(DF$standing), function(df) {\n  data.frame(standing = unique(df$standing), \n             N = nrow(df), \n             quant_10 = quantile(df$gpa_term, 0.10), \n             median_gpa = median(df$gpa_term), \n             quant_90 = quantile(df$gpa_term, 0.90))\n  })\nresult_df &lt;- do.call(rbind, DF_by)\n\n\n# data.table\nDT &lt;- na.omit(term_dt, \"gpa_term\")\nresult_dt &lt;- DT[, .(.N, \n                    quant_10 = quantile(gpa_term, 0.10), \n                    median_gpa = median(gpa_term), \n                    quant_90 = quantile(gpa_term, 0.90)), \n                by = c(\"standing\")]\nsetorder(result_dt, -median_gpa)\n\n\n# dplyr\nresult_tbl &lt;- term_tbl %&gt;%\n  drop_na(gpa_term) %&gt;%\n  group_by(standing) %&gt;%\n  summarise(N = n(),\n         quant_10 = quantile(gpa_term, 0.10), \n         median_gpa = median(gpa_term), \n         quant_90 = quantile(gpa_term, 0.90)) %&gt;%\n  arrange(-median_gpa)\n\n\nresult_dt\n#&gt;              standing      N quant_10 median_gpa quant_90\n#&gt;                &lt;char&gt;  &lt;int&gt;    &lt;num&gt;      &lt;num&gt;    &lt;num&gt;\n#&gt; 1:      Good Standing 589883     2.33       3.14     3.90\n#&gt; 2: Academic Probation  18489     1.27       1.79     2.30\n#&gt; 3:   Academic Warning  25961     1.14       1.72     1.93\n#&gt; 4: Academic Dismissal   2208     1.00       1.53     1.89\n\ncheck_equiv_frames(result_df, result_dt)\n#&gt; [1] TRUE\ncheck_equiv_frames(result_dt, result_tbl)\n#&gt; [1] TRUE\n\nComments\n\nbase R. by() is an implementation of split() + lapply() (the first two parts of the well-known split-apply-combine method) that yields a list of data frames, one per each combination the grouping variables. rbind() combines those results into a single data frame. function(df) is an anonymous function, that is, a function used without assigning it a name in the workspace.\ndata.table.\ndplyr.\nWith two or more grouping variables\nTask. Same as the previous example except grouped by academic standing and level.\n\n# base R\nDF &lt;- term_df[!is.na(term_df$gpa_term), , drop = FALSE]\nDF_by &lt;- by(DF, list(DF$standing, DF$level), FUN = function(df) {\n  data.frame(standing = unique(df$standing), \n             level = unique(df$level),\n             N = nrow(df), \n             quant_10 = quantile(df$gpa_term, 0.10), \n             median_gpa = median(df$gpa_term), \n             quant_90 = quantile(df$gpa_term, 0.90))\n  })\nresult_df &lt;- do.call(rbind, DF_by)\norder_index &lt;- order(-result_df$median_gpa, -result_df$quant_90)\nresult_df &lt;- result_df[order_index, , drop = FALSE]\n\n\n# data.table\nDT &lt;- na.omit(term_dt, \"gpa_term\")\nresult_dt &lt;- DT[, .(.N, \n                    quant_10 = quantile(gpa_term, 0.10), \n                    median_gpa = median(gpa_term), \n                    quant_90 = quantile(gpa_term, 0.90)), \n                by = c(\"standing\", \"level\")]\nsetorder(result_dt, -median_gpa, -quant_90)\n\n\n# dplyr\nresult_tbl &lt;- term_tbl %&gt;%\n  drop_na(gpa_term) %&gt;%\n  group_by(standing, level) %&gt;%\n  summarise(N = n(),\n         quant_10 = quantile(gpa_term, 0.10), \n         median_gpa = median(gpa_term), \n         quant_90 = quantile(gpa_term, 0.90)) %&gt;%\n  arrange(desc(median_gpa), desc(quant_90))\n\n\nresult_dt\n#&gt;               standing              level      N quant_10 median_gpa quant_90\n#&gt;                 &lt;char&gt;             &lt;char&gt;  &lt;int&gt;    &lt;num&gt;      &lt;num&gt;    &lt;num&gt;\n#&gt;  1:      Good Standing 05 Fifth-year Plus  38498    2.500       3.35    4.000\n#&gt;  2:      Good Standing     04 Fourth-year 105146    2.440       3.28    3.940\n#&gt;  3:      Good Standing      03 Third-year 140593    2.380       3.18    3.910\n#&gt;  4:      Good Standing     02 Second-year 161786    2.310       3.08    3.850\n#&gt;  5:      Good Standing      01 First-year 143860    2.250       3.00    3.820\n#&gt;  6: Academic Probation      03 Third-year   1030    1.309       2.00    2.670\n#&gt;  7: Academic Probation     04 Fourth-year    226    1.370       1.98    2.870\n#&gt;  8: Academic Probation     02 Second-year   4318    1.300       1.90    2.560\n#&gt;  9: Academic Probation 05 Fifth-year Plus     37    1.442       1.80    3.000\n#&gt; 10: Academic Probation      01 First-year  12878    1.250       1.75    2.080\n#&gt; 11:   Academic Warning      01 First-year   3931    1.260       1.75    1.940\n#&gt; 12:   Academic Warning     02 Second-year   9911    1.200       1.74    1.940\n#&gt; 13:   Academic Warning      03 Third-year   6831    1.030       1.70    1.930\n#&gt; 14:   Academic Warning     04 Fourth-year   4078    1.000       1.70    1.930\n#&gt; 15:   Academic Warning 05 Fifth-year Plus   1210    1.000       1.70    1.920\n#&gt; 16: Academic Dismissal      01 First-year   1671    1.000       1.54    1.900\n#&gt; 17: Academic Dismissal      03 Third-year     75    1.000       1.53    1.866\n#&gt; 18: Academic Dismissal     02 Second-year    440    1.000       1.50    1.860\n#&gt; 19: Academic Dismissal     04 Fourth-year     20    0.700       1.42    1.692\n#&gt; 20: Academic Dismissal 05 Fifth-year Plus      2    1.062       1.31    1.558\n#&gt;               standing              level      N quant_10 median_gpa quant_90\n\nall.equal(result_df, result_dt, check.attributes = FALSE)\n#&gt; [1] TRUE\nall.equal(result_dt, result_tbl, check.attributes = FALSE)\n#&gt; [1] TRUE\n\nComments\n\nbase R. Add the second grouping variable level in two places.\ndata.table. Add a second grouping variable to the by argument. Order by descending median GPA with the 90% quantile used to break ties.\ndplyr. Add a second grouping variable to group_by().",
    "crumbs": [
      "Shaping data 3 ways",
      "Aggregating transforms"
    ]
  },
  {
    "objectID": "data-shaping-03-aggregating-transforms.html#references",
    "href": "data-shaping-03-aggregating-transforms.html#references",
    "title": "Aggregating transforms",
    "section": "References",
    "text": "References",
    "crumbs": [
      "Shaping data 3 ways",
      "Aggregating transforms"
    ]
  },
  {
    "objectID": "data-shaping-05-reshaping-transforms.html",
    "href": "data-shaping-05-reshaping-transforms.html",
    "title": "Reshaping transforms",
    "section": "",
    "text": "Image: SAREC field day 2018 by Univ Wyoming Extension CT is licensed under CC BY-NC-ND 2.0\nUsing cdata, data.table, and dplyr/tidyr to transform MIDFIELD data as needed for your analysis (no base R transforms in this section).\nIn this section, we cover reshaping data frames by moving data between rows and columns, often called pivoting.",
    "crumbs": [
      "Shaping data 3 ways",
      "Reshaping transforms"
    ]
  },
  {
    "objectID": "data-shaping-05-reshaping-transforms.html#terminology",
    "href": "data-shaping-05-reshaping-transforms.html#terminology",
    "title": "Reshaping transforms",
    "section": "Terminology",
    "text": "Terminology\nPivoting operations go by a number of different names, as listed in Table 1 (Mount & Zumel, 2019).\n\n\n\n\n\nTable 1: Reshaping operations\n\nSystem\nPivot \"wider\"\nPivot \"longer\"\n\n\n\ncolloquially called\n\"tall to wide\"\n\"wide to tall\"\n\n\nMicrosoft Excel\npivot\nun-pivot\n\n\ndatabases\npivot\nanti-pivot\n\n\ndatabases\ncrosstab\nshred\n\n\nR\nunstack\nstack\n\n\nreshape, reshape2\ncast\nmelt\n\n\n\n\n\n\n\nPivoting is possible in base R but the package versions in data.table, tidyr, and cdata are significantly better tools. Table 2 lists the reshaping functions we use in this work.\n\n\n\n\n\nTable 2: Reshaping functions we use\n\nR package\nPivot \"wider\"\nPivot \"longer\"\n\n\n\ndata.table\ndcast()\nmelt()\n\n\ntidyr\npivot_wider()\npivot_longer()\n\n\ncdata\npivot_to_rowrecs()\nunpivot_to_blocks()\n\n\n\n\n\n\n\nThe data set we use in this section is shown in Table 3, where “starters” is the number of students starting in an engineering program, “ever enrolled” is the number who were enrolled at least one term in the program, and “graduates” is the number graduating from that program.\n\n\n\n\n\nTable 3. Row-records form\n\nprogram\nstarters\never_enrolled\ngraduates\n\n\n\nCivil\n983\n1504\n936\n\n\nElectrical\n1080\n1490\n736\n\n\nIndustrial\n285\n353\n238\n\n\nMechanical\n1705\n2306\n1354\n\n\n\n\n\n\n\nThese data are in “wide” format, with one row per program. In this form, the “coordinates” of a measurement (a count of students) are the value of the primary key (program) and a column name.1\n1 We refer again to Mount & Zumel (2019) for the concept of coordinatized data.In Table 4, these data are transformed to “tall” format, with three rows per program. As indicated by the cell color-coding, the names of three columns in Table 3 are now values in the peer-group column in Table 4 and all counts of students are collected in the N column. In this form, the coordinates of a measurement (N) are given by the composite key (program + peer_group).\n\n\n\n\n\nTable 4. Blocks form\n\nprogram\npeer_group\nN\n\n\n\nCivil\nstarters\n983\n\n\nElectrical\nstarters\n1080\n\n\nIndustrial\nstarters\n285\n\n\nMechanical\nstarters\n1705\n\n\nCivil\never_enrolled\n1504\n\n\nElectrical\never_enrolled\n1490\n\n\nIndustrial\never_enrolled\n353\n\n\nMechanical\never_enrolled\n2306\n\n\nCivil\ngraduates\n936\n\n\nElectrical\ngraduates\n736\n\n\nIndustrial\ngraduates\n238\n\n\nMechanical\ngraduates\n1354\n\n\n\n\n\n\n\nYou can see why “wide” and “tall” are commonly used to describe these two formats. Yet “wider” implies having more columns, and (while true here) that is not always the case.\nWhat is always true is that the first format comprises row records, or one row per primary key, and the second format comprises blocks, or multiple rows per primary key (Mount & Zumel, 2021). As long as the data are properly “coordinatized”, the transformations are invertible.\nIn our opinion, blocks and row records describe these data formats more memorably than the alternatives, so we use them to define our transforms as well:\n\nblocks to row-records (i.e., pivoting or “tall to wide”)\nrow-records to blocks (i.e., un-pivoting or “wide to tall”)",
    "crumbs": [
      "Shaping data 3 ways",
      "Reshaping transforms"
    ]
  },
  {
    "objectID": "data-shaping-05-reshaping-transforms.html#why-transform",
    "href": "data-shaping-05-reshaping-transforms.html#why-transform",
    "title": "Reshaping transforms",
    "section": "Why transform?",
    "text": "Why transform?\nWe transform data between blocks and row records to meet specific needs. Most data processing steps, for example, have a preferred format for how data is arranged in rows and columns. Some packages, like ggplot2, require blocks; others, like the likert package, require row records if the survey data is in summary form (frequencies counted) but requires blocks if not summarized, i.e., one row per respondent, one column per question.\nRow records are generally preferred for publishing a data table such as Table 3 and they support analytical tasks as well. For example, the academic program metric “stickiness” is the ratio of the number of graduates from a program to the number ever enrolled in the program. With a data frame df organized like the Table 3 data, computing stickiness requires one line of code operating on values in the same row, e.g.,\n# base R\ndf$stickiness &lt;- df$graduates / df$ever_enrolled\nBlocks, on the other hand, are convenient for grouping and summarizing operations and, as stated earlier, are required for making charts with ggplot2. For example, with a data frame blocks organized like the Table 4 data, the three column names are variables used as arguments in the aes() function that appear in the chart on the horizontal scale (N), the vertical scale (programs), and the legend (peer groups).\n\nlibrary(ggplot2)\nggplot(blocks, aes(x = N, \n                   y = program, \n                   color = peer_group, \n                   shape = peer_group)) +\n  geom_point(size = 3) +\n  theme_light()",
    "crumbs": [
      "Shaping data 3 ways",
      "Reshaping transforms"
    ]
  },
  {
    "objectID": "data-shaping-05-reshaping-transforms.html#setup",
    "href": "data-shaping-05-reshaping-transforms.html#setup",
    "title": "Reshaping transforms",
    "section": "Setup",
    "text": "Setup\nLoad packages.\n\nlibrary(\"midfielddata\")\nlibrary(\"data.table\")\nlibrary(\"dplyr\", warn.conflicts = FALSE)\nlibrary(\"tidyr\")\nlibrary(\"wrapr\")\nlibrary(\"cdata\")\n\nFormat data as described in the Introduction. The case_blocs data set is taken from the midfieldr case study with students from four engineering programs organized in three blocs or peer-groups: starters, ever-enrolled, and graduates.\n\ncase_blocs &lt;- fread(\"data/case_blocs.csv\")\n\n\n# base R\ncase_blocs_df &lt;- data.frame(case_blocs)\n\n\n# data.table\ncase_blocs_dt &lt;- copy(case_blocs)\n\n\n# dplyr\ncase_blocs_tbl &lt;- tibble(case_blocs)\n\n\ncase_blocs_dt\n#&gt;                  mcid    program peer_group\n#&gt;                &lt;char&gt;     &lt;char&gt;     &lt;char&gt;\n#&gt;     1: MCID3111142965 Electrical   starters\n#&gt;     2: MCID3111145102 Electrical   starters\n#&gt;     3: MCID3111150194 Industrial   starters\n#&gt;     4: MCID3111156083 Electrical   starters\n#&gt;     5: MCID3111156325 Electrical   starters\n#&gt;    ---                                     \n#&gt; 12966: MCID3112618553 Mechanical  graduates\n#&gt; 12967: MCID3112618574 Mechanical  graduates\n#&gt; 12968: MCID3112618976 Mechanical  graduates\n#&gt; 12969: MCID3112619484 Electrical  graduates\n#&gt; 12970: MCID3112641535 Mechanical  graduates\n\n\nCount by program and peer group as described in Aggregating transforms. The result is in block-records format.\n\nkey_columns &lt;- c(\"program\", \"peer_group\") \n\n\n# base R\nfreq_table &lt;- table(case_blocs_df$program,\n                    case_blocs_df$peer_group,\n                    dnn = key_columns)\nblocks_df &lt;- as.data.frame(freq_table, \n                         responseName = \"N\",\n                         stringsAsFactors = FALSE)\n\n\n# data.table\nblocks_dt &lt;- case_blocs_dt[, .N, by = key_columns]\nsetorder(blocks_dt, program, -N)\n\n\n# dplyr\nblocks_tbl &lt;- case_blocs_tbl %&gt;%\n count(program, peer_group, name = \"N\")\n\n\nblocks_dt\n#&gt;        program    peer_group     N\n#&gt;         &lt;char&gt;        &lt;char&gt; &lt;int&gt;\n#&gt;  1:      Civil ever_enrolled  1504\n#&gt;  2:      Civil      starters   983\n#&gt;  3:      Civil     graduates   936\n#&gt;  4: Electrical ever_enrolled  1490\n#&gt;  5: Electrical      starters  1080\n#&gt;  6: Electrical     graduates   736\n#&gt;  7: Industrial ever_enrolled   353\n#&gt;  8: Industrial      starters   285\n#&gt;  9: Industrial     graduates   238\n#&gt; 10: Mechanical ever_enrolled  2306\n#&gt; 11: Mechanical      starters  1705\n#&gt; 12: Mechanical     graduates  1354\n\ncheck_equiv_frames(blocks_df, blocks_dt)\n#&gt; [1] TRUE\ncheck_equiv_frames(blocks_dt, blocks_tbl)\n#&gt; [1] TRUE",
    "crumbs": [
      "Shaping data 3 ways",
      "Reshaping transforms"
    ]
  },
  {
    "objectID": "data-shaping-05-reshaping-transforms.html#blocks-to-row-records",
    "href": "data-shaping-05-reshaping-transforms.html#blocks-to-row-records",
    "title": "Reshaping transforms",
    "section": "Blocks to row-records",
    "text": "Blocks to row-records\nIn this transform, we group a set of rows that go together (matching on keys) and combine them into one row by adding columns. The result is in row-records form, with one row per program.\nTask. Transform the three-case_blocss data frame from block-records to row-records format, using program as the primary key.\n\n# data.table\nrowrecs_dt &lt;- dcast(blocks_dt, \n                    program ~ peer_group, \n                    value.var = \"N\")\n                    setkey(rowrecs_dt, NULL)\n\n\n# tidyr\nrowrecs_tbl &lt;- blocks_tbl %&gt;%\n  pivot_wider(id_cols = program, \n              names_from = peer_group, \n              values_from = N)\n\n\n# cdata\nrowrecs_df &lt;- pivot_to_rowrecs(blocks_df,  \n                               rowKeyColumns = \"program\", \n                               columnToTakeKeysFrom = \"peer_group\",\n                               columnToTakeValuesFrom = \"N\")\n\n\nrowrecs_dt\n#&gt;       program ever_enrolled graduates starters\n#&gt;        &lt;char&gt;         &lt;int&gt;     &lt;int&gt;    &lt;int&gt;\n#&gt; 1:      Civil          1504       936      983\n#&gt; 2: Electrical          1490       736     1080\n#&gt; 3: Industrial           353       238      285\n#&gt; 4: Mechanical          2306      1354     1705\n\ncheck_equiv_frames(rowrecs_df, rowrecs_dt)\n#&gt; [1] TRUE\ncheck_equiv_frames(rowrecs_dt, rowrecs_tbl)\n#&gt; [1] TRUE\n\nComments\n\nIn all cases, the same transformation occurs: column program remains a row key column; the values of the peer_group column (ever_enrolled, graduates, starters) become new key column names with values taken from the N column.\ndata.table. dcast() uses a formula LHS ~ RHS\ntidyr pivot_wider(), an updated approach to spread().\ncdata. pivot_to_rowrecs(), a special case of the more general function blocks_to_rowrecs().",
    "crumbs": [
      "Shaping data 3 ways",
      "Reshaping transforms"
    ]
  },
  {
    "objectID": "data-shaping-05-reshaping-transforms.html#row-records-to-blocks",
    "href": "data-shaping-05-reshaping-transforms.html#row-records-to-blocks",
    "title": "Reshaping transforms",
    "section": "Row-records to blocks",
    "text": "Row-records to blocks\nIn this transform—the inverse of blocks to row-records—each row is disassembled and used to make a block of many rows. Each block of records in the new data frame has as many rows per record as there are columns we take measurements from.\nTask. Transform the results from the previous example from row-records to block-records format, using program as the primary key and all other column names collected under a new secondary key column peer_group.\n\n# data.table\nblocks_dt_2 &lt;- melt(\n  rowrecs_dt, \n  measure.vars = c(\"ever_enrolled\", \"graduates\", \"starters\"), \n  variable.name = \"peer_group\", \n  value.name = \"N\", \n  variable.factor = FALSE\n)\nsetorderv(blocks_dt_2, c(\"program\", \"peer_group\"))\n\n\n# tidyr\nblocks_tbl &lt;- rowrecs_tbl %&gt;%\n  pivot_longer(\n  cols = c(\"ever_enrolled\", \"graduates\", \"starters\"),\n  names_to = \"peer_group\", \n  values_to = \"N\"\n)\n\n\n# cdata\nblocks_df &lt;- unpivot_to_blocks(\n  rowrecs_df, \n  columnsToTakeFrom = c(\"ever_enrolled\", \"graduates\", \"starters\"),\n  nameForNewKeyColumn = \"peer_group\", \n  nameForNewValueColumn = \"N\"\n)\n\n\nblocks_dt_2\n#&gt;        program    peer_group     N\n#&gt;         &lt;char&gt;        &lt;char&gt; &lt;int&gt;\n#&gt;  1:      Civil ever_enrolled  1504\n#&gt;  2:      Civil     graduates   936\n#&gt;  3:      Civil      starters   983\n#&gt;  4: Electrical ever_enrolled  1490\n#&gt;  5: Electrical     graduates   736\n#&gt;  6: Electrical      starters  1080\n#&gt;  7: Industrial ever_enrolled   353\n#&gt;  8: Industrial     graduates   238\n#&gt;  9: Industrial      starters   285\n#&gt; 10: Mechanical ever_enrolled  2306\n#&gt; 11: Mechanical     graduates  1354\n#&gt; 12: Mechanical      starters  1705\n\ncheck_equiv_frames(blocks_df, blocks_dt_2)\n#&gt; [1] TRUE\ncheck_equiv_frames(blocks_dt_2, blocks_tbl)\n#&gt; [1] TRUE\n\nComments\n\nIn all cases, the same transformation occurs: column names are identified (ever_enrolled, graduates, starters) and collected in a new key column (peer_group); the values from these columns are collected in a new payload column (N); and column names not selected (program) are treated as keys, copied to each record row in the result.\ndata.table melt()\ntidyr pivot_longer(), an updated approach to gather()\ncdata unpivot_to_blocks() a special case of the more general function rowrecs_to_blocks().\n\nConfirm that the result is equivalent to the original blocks form.\n\ncheck_equiv_frames(blocks_dt, blocks_dt_2)\n#&gt; [1] TRUE",
    "crumbs": [
      "Shaping data 3 ways",
      "Reshaping transforms"
    ]
  },
  {
    "objectID": "data-shaping-05-reshaping-transforms.html#midfield-data-keys",
    "href": "data-shaping-05-reshaping-transforms.html#midfield-data-keys",
    "title": "Reshaping transforms",
    "section": "MIDFIELD data keys",
    "text": "MIDFIELD data keys\nThe previous sections have focused our attention on the importance of keys, that is, variables that alone or in combination uniquely identify a row of data. Here we use wrapr::checkColsFormUniqueKeys() to check if rows of data are uniquely addressable by the columns named. For example, for the Table 3 data in row records form, program is such a key:\n\ncheckColsFormUniqueKeys(rowrecs_dt, c(\"program\"))\n#&gt; [1] TRUE\n\nFor the Table 4 data in blocks form, two columns are required:\n\ncheckColsFormUniqueKeys(blocks_dt, c(\"program\", \"peer_group\"))\n#&gt; [1] TRUE\n\nFor the midfielddata practice data, the keys are:\ndata(student)\ncheckColsFormUniqueKeys(student, c(\"mcid\"))\n#&gt; [1] TRUE\n\ndata(term)\ncheckColsFormUniqueKeys(term, c(\"mcid\", \"term\"))\n#&gt; [1] TRUE\n\ndata(course)\ncheckColsFormUniqueKeys(course, c(\"mcid\", \"term_course\", \"abbrev\", \"number\"))\n#&gt; [1] TRUE\n\ndata(degree)\ncheckColsFormUniqueKeys(degree, c(\"mcid\", \"degree\"))\n#&gt; [1] TRUE",
    "crumbs": [
      "Shaping data 3 ways",
      "Reshaping transforms"
    ]
  },
  {
    "objectID": "data-shaping-05-reshaping-transforms.html#next-steps",
    "href": "data-shaping-05-reshaping-transforms.html#next-steps",
    "title": "Reshaping transforms",
    "section": "Next steps",
    "text": "Next steps\nReshaping transforms can also be applied to more than one column, though we don’t cover that use case here. For those interested:\n\ndata.table’s dcast() allows more complicated transforms, such as casting to multiple variables and aggregations at the same time.\ncdata has simple methods for conversions of many columns at once using blocks_to_rowrecs() and rowrecs_to_blocs() plus a “control table”. See, for example, Faceted graphs with cdata and ggplot2\ntidyr has similar functions, inspired by cdata, using pivot_longer_spec() and pivot_wider_spec(). See Pivot data from long to wide using a spec.",
    "crumbs": [
      "Shaping data 3 ways",
      "Reshaping transforms"
    ]
  },
  {
    "objectID": "data-shaping-05-reshaping-transforms.html#references",
    "href": "data-shaping-05-reshaping-transforms.html#references",
    "title": "Reshaping transforms",
    "section": "References",
    "text": "References\n\n\nMount, J., & Zumel, N. (2019). Coordinatized data: A fluid data specification. Win Vector LLC. http://winvector.github.io/FluidData/RowsAndColumns.html\n\n\nMount, J., & Zumel, N. (2021). Block records and row records. Win Vector LLC. https://winvector.github.io/cdata/articles/blocksrecs.html",
    "crumbs": [
      "Shaping data 3 ways",
      "Reshaping transforms"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome",
    "section": "",
    "text": "2024 MIDFIELD Institute\nLocation: Virtual\nDates: June 11 (office hours)\n\\(\\qquad\\ \\,\\) June 12–14 (workshop)\nTime: 1–5 pm Eastern Time (US)\n\n\n\n\n\n\n\n\n\nRegistration. Click here to email us that you are interested in attending the Institute. If the link fails, email Susan Lord (slord@sandiego.edu) with the subject line Register for 2024 MIDFIELD Institute.\n\n\n\nWe welcome faculty, staff, graduate students, and anyone interested in exploring MIDFIELD.\nOur learning objectives can be categorized in two broad classes: qualitative and computational. Qualitatively, by the end of the workshop participants should be able to:\n\nDescribe the data available in MIDFIELD\n\nDescribe how the MIDFIELD data are organized\n\nDescribe key principles of effective data visualization\nDraft a research question that can be addressed using MIDFIELD\n\nComputationally, participants should be able use midfieldr, an R package specifically designed for use with MIDFIELD, to:\n\nSubset MIDFIELD data to obtain a population to study\n\nClassify student records by desired groupings\n\nSummarize the data by groups and display results\n\n\n\n\n Back to top",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "license.html",
    "href": "license.html",
    "title": "Open source licenses",
    "section": "",
    "text": "Image: License and Registration Please by Thomas Hawk is licensed under CC BY-NC 2.0\n\n\nThe following licenses apply to the text, data, and code in these workshops. Our goal is to minimize legal encumbrances to the dissemination, sharing, use, and re-use of this work.\n\nCC-BY 4.0 for text.\n\nGPL-3 for code.\n\nCC0 for data.\n\nThe existing rights of authors whose text, code, or data are cited are reserved to those authors.\nWhere noted, works adapted under another license are distributed under the same license.\n\n\n\n Back to top",
    "crumbs": [
      "License"
    ]
  },
  {
    "objectID": "r-resources.html",
    "href": "r-resources.html",
    "title": "Resources",
    "section": "",
    "text": "Image: Library by Ming-Yueh Wang is licensed under CC BY-NC-ND 2.0\nIf you happen to come across other resources that you find useful, please let us know and we’ll add them to the list.",
    "crumbs": [
      "Resources"
    ]
  },
  {
    "objectID": "r-resources.html#package-links",
    "href": "r-resources.html#package-links",
    "title": "Resources",
    "section": "Package links",
    "text": "Package links\n\nmidfieldr\nmidfielddata\nggplot2\ndata.table",
    "crumbs": [
      "Resources"
    ]
  },
  {
    "objectID": "r-resources.html#using-r",
    "href": "r-resources.html#using-r",
    "title": "Resources",
    "section": "Using R",
    "text": "Using R\n\natrebas (2019) for doing identical tasks in the data.table and dplyr environments. Very useful if you are familiar with dplyr syntax and want to translate that familiar functionality to data.table syntax.\nDowle & Srinivasan (2022) for the data.table website with vignettes by the package authors\nHoltz (2018) for a gallery of chart designs possible with ggplot2.\nR-bloggers, a searchable aggregator of R blogs.\nStackoverflow Searchable, public platform for coding questions and answers. For R-specific Q&A, add [r] as a search tag. Additional search tags such as [ggplot2] or [data.table] will help narrow your searches involving these packages.\nPosit (2024) (The company “RStudio” was renamed “Posit” in 2022. The ) Links to downloadable help summaries (cheat sheets) for ggplot2 and many other packages. For data.table scroll down to the “Contributed cheatsheets” section.\nZumel & Mount (2020) for data science work with a very good chapter on data manipulation that performs every step three ways: a base R solution, a data.table solution, and a dplyr solution.",
    "crumbs": [
      "Resources"
    ]
  },
  {
    "objectID": "r-resources.html#data-visualization",
    "href": "r-resources.html#data-visualization",
    "title": "Resources",
    "section": "Data visualization",
    "text": "Data visualization\nBooks\n\nCairo (2019) for a data journalist’s approach to avoiding lying to an audience (and to one’s self).\nCleveland (1993) for a detailed look at matching chart design to the types of variables.\nRobbins (2013) for a detailed development of principles and practices for creating effective charts, based largely on Cleveland’s work.\nTufte (1983) One of the best developments of aligning one’s visual rhetoric to one’s verbal rhetoric.\nWainer (1997) Often humorous in presenting do’s and dont’s of data display\nWainer (2014) Using evidence and visualization to improve healthcare.\n\nBlogs\n\nEvergreen (2024) Intentional reporting and data visualization\nFew (2021) Visual business intelligence\nKnaflic (2024) Storytelling with data\nLayton (2024) for Richard’s blog in which several articles illustrate redesigning a published chart in an engineering education article to better align the logic of a display with the logic of the argument.",
    "crumbs": [
      "Resources"
    ]
  },
  {
    "objectID": "r-resources.html#data-visualization-using-r",
    "href": "r-resources.html#data-visualization-using-r",
    "title": "Resources",
    "section": "Data visualization using R",
    "text": "Data visualization using R\n\nHealy (2019) Hands-on introduction to principles and practices of looking at and presenting data using R and ggplot2.\nMachlis (2019) Especially useful for spreadsheet users who want to “graduate” to a reproducible scripted programming language.",
    "crumbs": [
      "Resources"
    ]
  }
]