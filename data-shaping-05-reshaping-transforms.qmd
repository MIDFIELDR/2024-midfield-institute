---
title: "Reshaping transforms"
format:
  html:
    css: styles.css
---

![Image: *SAREC field day 2018* by Univ Wyoming Extension CT is licensed under [CC BY-NC-ND 2.0](https://creativecommons.org/licenses/by-nc-nd/2.0/)](figures/data-shaping-5.png)

```{r}
#| label: setup
#| include: false
knitr::opts_chunk$set(comment = "#>", 
                      collapse = TRUE, 
                      message = FALSE)
```

```{r}
#| echo: false
# prepare two data sets for display
library(data.table)
cohort <- fread("data/three_blocs.csv")
key_columns <- c("program", "peer_group") 
blocks <- cohort[, .N, by = key_columns]
blocks$peer_group <- factor(blocks$peer_group, levels = c("ever_enrolled", "starters", "graduates"))
setorderv(blocks, c("program", "peer_group"))

rowrecs <- dcast(blocks, 
                    program ~ peer_group, 
                    value.var = "N")
                    setkey(rowrecs, NULL)
setcolorder(rowrecs, c("program", "starters", "ever_enrolled", "graduates"))
```


Using **cdata**, **data.table**, and **tidyr** to transform MIDFIELD data as needed for your analysis (no base R transforms in this section). 

- [Introduction](data-shaping-00-introduction.html)
- [Data selection](data-shaping-01-data-selection.html)
- [Basic transforms](data-shaping-02-basic-transforms.html)
- [Aggregating transforms](data-shaping-03-aggregating-transforms.html)
- [Multi-table transforms](data-shaping-04-multi-table-transforms.html)
- [Reshaping transforms](data-shaping-05-reshaping-transforms.html)  &#9665; *You are here.*

In this section, we cover reshaping data frames by moving data between rows and columns, often called *pivoting*. 

## Terminology 

Pivoting operations go by a number of different names, as listed in Table 1 [@Mount+Zumel:2019:fluid-data].   

```{r}
#| echo: false
wrapr::build_frame(
  "System"               , 'Pivot "wider"'  , 'Pivot "longer"' |
    "colloquially called", '"tall to wide"' , '"wide to tall"' |
    "Microsoft Excel"    , "pivot"          , "un-pivot"       |
    "databases"          , "pivot"          , "anti-pivot"     |
    "databases"          , "crosstab"       , "shred"          |
    "R"                  , "unstack"        , "stack"          |
    "reshape, reshape2"  , "cast"           , "melt"           ) |>
knitr::kable(caption = "Table 1: Various names of reshaping operations by system ")
```

<br>

Pivoting is possible in base R but the package versions in data.table,  tidyr, and cdata are significantly better tools. Table 2 lists the reshaping functions we use in this work. 

```{r}
#| echo: false
wrapr::build_frame(
  "R package" , 'Pivot "wider"'       , 'Pivot "longer"'         |
  "data.table", "`dcast()`"           , "`melt()`"               |
  "tidyr"     , "`pivot_wider()`"     , "`pivot_longer()`"       |     
  "cdata"     , "`pivot_to_rowrecs()`", "`unpivot_to_blocks()`") |>
knitr::kable(caption = "Table 2: The reshaping operations we use in this  tutorial.")
```

<br>


[Defining our terms.]{.important} The data set we use in this section is shown below, where "starters" is the number of students starting in an engineering program, "ever enrolled" is the number who were enrolled at least one term in the program, and "graduates" is the number graduating from that program. 

These data are in "wide" format, with one row per program. 

```{r}
#| echo: false
kableExtra::kbl(rowrecs, caption = "Table 3. Row-records example") |>
  kableExtra::kable_styling(full_width = FALSE, 
                            position = "left", 
                            font_size = 12)
```

<br>

Transformed to its "tall" format, the dataset has three rows per program. The names of three columns in Table 3 are now values in the peer-group column in Table 4 and all counts of students are collected in the N column.  
 
```{r}
#| echo: false
kableExtra::kbl(blocks, caption = "Table 4. Block-records example") |>
  kableExtra::kable_styling(full_width = FALSE, 
                            position = "left", 
                            font_size = 12)
```

<br>
 
You can see why "wide" and  "tall" are commonly used to describe these two formats.  Yet "wider" implies having more columns, and (while true here) that is not always the case. 

What *is* always true is that the first format comprises ***row records***, or one row per primary key, and the second format comprises ***block records***, or multiple rows per primary key [@Mount+Zumel:2021:block+row+records].

In our opinion, *block records* and *row records* describe these data formats more memorably than the alternatives, so we use them to define our transforms as well: 

- *blocks to row-records* (i.e., pivoting or "tall to wide")

- *row-records to blocks* (i.e., un-pivoting or "wide to tall")






## Why transform?

We transform data between block records and row records to meet specific needs. For example, one of the first things to do when learning a new graphing package in R is to understand the data shape the package requires---some, like [ggplot2](https://CRAN.R-project.org/package=ggplot2), require block records; others, like the [likert](https://CRAN.R-project.org/package=likert) package, require row records if the survey data is in summary form (frequencies counted) but requires block records if not summarized, i.e., one row per respondent, one column per question.

For row-records, another common application is preparing a data table, as in Table 3. Row records also support analytical tasks. For example, the academic program metric "stickiness" is the ratio of the number of graduates from a program to the number ever enrolled in the program. With a data frame `df` organized like the Table 3 data, computing stickiness requires one line of code operating on values in the same row, e.g., 

```r
# base R
df$stickiness <- df$graduates / df$ever_enrolled
```

Block records, on the other hand, are convenient for grouping and summarizing operations and, as stated earlier, required for making charts with ggplot2. For example, with a data frame `blocks` organized like the Table 4 data, we can graph *N* as a function of program and peer group. The three column names of the block-record formatted data are arguments in the `aes()` function and then appear on the horizontal scale (N), the vertical scale (programs), and the legend (peer groups). 

```{r}
#| echo: false
blocks[, max_N := max(N), by = "program"]
blocks$program <- factor(blocks$program)
blocks[, program := reorder(program, max_N)]
blocks$max_N <- NULL
```


```{r fig.asp = 0.3}
library(ggplot2)
ggplot(blocks, aes(x = N, 
                   y = program, 
                   color = peer_group, 
                   shape = peer_group)) +
  geom_point(size = 3) +
  theme_light()
```






## Data 

[Load packages and format data]{.important} as described in the  [Introduction](data-shaping-00-introduction.html).

```{r}
library("data.table")
library("dplyr", warn.conflicts = FALSE)
library("tidyr")
library("cdata")

cohort <- fread("data/three_blocs.csv")
```

```{r}
#| class: base
# base R
cohort_df <- data.frame(cohort)
```

```{r}
#| class: dtbl
# data.table
cohort_dt <- copy(cohort)
```

```{r}
#| class: dplyr
# dplyr
cohort_tbl <- tibble(cohort)
```

```{r}
cohort_dt
```

<br>

[Count]{.important} by program and peer group as described in [Aggregating transforms](data-shaping-03-aggregating-transforms.html#counting). The result is in block-records format. 

```{r}
key_columns <- c("program", "peer_group") 
```

```{r}
#| class: base
# base R
freq_table <- table(cohort_df$program,
                    cohort_df$peer_group,
                    dnn = key_columns)
blocks_df <- as.data.frame(freq_table, 
                         responseName = "N",
                         stringsAsFactors = FALSE)
```

```{r}
#| class: dtbl
# data.table
blocks_dt <- cohort_dt[, .N, by = key_columns]
setorder(blocks_dt, program, -N)
```

```{r}
#| class: dplyr
# dplyr
blocks_tbl <- cohort_tbl %>%
 count(program, peer_group, name = "N")
```

```{r}
blocks_dt

check_equiv_frames(blocks_df, blocks_dt)
check_equiv_frames(blocks_dt, blocks_tbl)
```



## Blocks to row-records

In this transform, we group a set of rows that go together (matching on keys) and combine them into one row by adding columns. The result is in *row-records* form, with one row per program. 

```{r}
#| class: dtbl
# data.table
rowrecs_dt <- dcast(blocks_dt, 
                    program ~ peer_group, 
                    value.var = "N")
                    setkey(rowrecs_dt, NULL)
```

```{r}
#| class: dplyr
# tidyr
rowrecs_tbl <- blocks_tbl %>%
  pivot_wider(id_cols = program, 
              names_from = peer_group, 
              values_from = N)
```

```{r}
#| class: other
# cdata
rowrecs_df <- pivot_to_rowrecs(blocks_df,  
                               rowKeyColumns = "program", 
                               columnToTakeKeysFrom = "peer_group",
                               columnToTakeValuesFrom = "N")
```

```{r}
rowrecs_dt

check_equiv_frames(rowrecs_df, rowrecs_dt)
check_equiv_frames(rowrecs_dt, rowrecs_tbl)
```

[Comments]{.important} 

- In all cases, the same transformation occurs: column `program` remains a *row key* column; the values of the `peer_group` column (`ever_enrolled`, `graduates`, `starters`) become new key column *names* with *values* taken from the `N` column. 

- *data.table.* `dcast()` uses a formula `LHS ~ RHS`

- *tidyr* `pivot_wider()`, an updated approach to `spread()`. 

- *cdata.* `pivot_to_rowrecs()`, a special case of the more general function `blocks_to_rowrecs()`.





## Row-records to blocks

In this transform---the inverse of  blocks to row-records---each row is disassembled and used to make a block of many rows. Each block of records in the new data frame has as many rows per record as there are columns we take measurements from. 

```{r}
#| class: dtbl
# data.table
blocks_dt <- melt(
  rowrecs_dt, 
  measure.vars = c("ever_enrolled", "graduates", "starters"), 
  variable.name = "peer_group", 
  value.name = "N", 
  variable.factor = FALSE
)
setorderv(blocks_dt, c("program", "peer_group"))
```

```{r}
#| class: dplyr
# tidyr
blocks_tbl <- rowrecs_tbl %>%
  pivot_longer(
  cols = c("ever_enrolled", "graduates", "starters"),
  names_to = "peer_group", 
  values_to = "N"
)
```

```{r}
#| class: other
# cdata
blocks_df <- unpivot_to_blocks(
  rowrecs_df, 
  columnsToTakeFrom = c("ever_enrolled", "graduates", "starters"),
  nameForNewKeyColumn = "peer_group", 
  nameForNewValueColumn = "N"
)
```

```{r}
blocks_dt

check_equiv_frames(blocks_df, blocks_dt)
check_equiv_frames(blocks_dt, blocks_tbl)
```

[Comments]{.important} 

- In all cases, the same transformation occurs: column names are identified (`ever_enrolled`, `graduates`, `starters`) and collected in a new key column (`peer_group`); the values from these columns are collected in a new payload column (`N`); and column names not selected (`program`) are treated as keys, copied to each record row in the result.

- *data.table* `melt()`

- *tidyr* `pivot_longer()`, an updated approach to `gather()`

- *cdata* `unpivot_to_blocks()` a special case of the more general function `rowrecs_to_blocks()`. 




## Next steps

Reshaping transforms can also be applied to more than one column, though we don't cover that use case here. For those interested:  

- data.table's `dcast()` allows more complicated transforms, such as casting to multiple variables and aggregations at the same time.

- cdata has simple methods for conversions of many columns at once using `blocks_to_rowrecs()` and `rowrecs_to_blocs()` plus a "control table".  See, for example, [Faceted graphs with cdata and ggplot2](https://win-vector.com/2018/10/21/faceted-graphs-with-cdata-and-ggplot2/)

- tidyr has similar functions, inspired by cdata, using `pivot_longer_spec()` and `pivot_wider_spec()`. See [Pivot data from long to wide using a spec](https://tidyr.tidyverse.org/reference/pivot_wider_spec.html). 









## References 

<div id="refs"></div>

