{
  "hash": "5f3ea3d1b0f3f322b7f2202d9079cdcf",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Aggregating transforms\"\nformat:\n  html:\n    css: styles.css\n---\n\n\n![Image: *Our daily challenge: Too many to count* by Sue Thompson is licensed under [CC BY-ND 2.0](https://creativecommons.org/licenses/by-nd/2.0/)](figures/data-shaping-3.png)\n\n\n\n\n\nUsing **base R**, **data.table**, and **dplyr** to transform MIDFIELD data as needed for your analysis.\n\n- [Introduction](data-shaping-00-introduction.html)\n- [Data selection](data-shaping-01-data-selection.html)\n- [Basic transforms](data-shaping-02-basic-transforms.html)\n- [Aggregating transforms](data-shaping-03-aggregating-transforms.html)  &#9665; *You are here.*\n- [Multi-table transforms](data-shaping-04-multi-table-transforms.html)\n- [Reshaping transforms](data-shaping-05-reshaping-transforms.html)\n\nIn this section we demonstrate aggregating many observations of a variable into a set of summary observations, typically grouped by one or more grouping variables. Summaries include counts as well as means, medians, quartiles, etc. \n\n[Load packages and format data]{.important} as described in the  [Introduction](data-shaping-00-introduction.html).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"midfielddata\")\nlibrary(\"data.table\")\nlibrary(\"dplyr\", warn.conflicts = FALSE)\nlibrary(\"tidyr\")\nlibrary(\"wrapr\")\n\ndata(student, term)\n```\n:::\n\n::: {.cell class='base'}\n\n```{.r .cell-code}\n# base R\nstudent_df <- data.frame(student)\nterm_df <- data.frame(term)\n```\n:::\n\n::: {.cell class='dtbl'}\n\n```{.r .cell-code}\n# data.table\nstudent_dt <- copy(student)\nterm_dt <- copy(term)\n```\n:::\n\n::: {.cell class='dplyr'}\n\n```{.r .cell-code}\n# dplyr\nstudent_tbl <- tibble(student)\nterm_tbl <- tibble(term)\n```\n:::\n\n\n<br>\n\n## Counting\n\nBase R offers several approaches to the task of counting by groups, for example, `by()`, `aggregate()`, `table()`, `tapply()`, or a split-apply-combine strategy. For counting, I think `table()` requires the least amount of cognitive overhead when the desired result is a data frame. \n\n### With one grouping variable\n\n\n::: {.cell class='base'}\n\n```{.r .cell-code}\n# base R\nfreq_table <- table(student_df$race, dnn = \"race\")\nresult_df <- as.data.frame(freq_table,\n                           responseName = \"N\", \n                           stringsAsFactors = FALSE)\n```\n:::\n\n::: {.cell class='dtbl'}\n\n```{.r .cell-code}\n# data.table\nresult_dt <- student_dt[, .N, by = c(\"race\")]\nsetorderv(result_dt, \"race\")\n```\n:::\n\n::: {.cell class='dplyr'}\n\n```{.r .cell-code}\n# dplyr\nresult_tbl <- student_tbl %>%\n count(race, name = \"N\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nresult_dt\n#>               race     N\n#>             <char> <int>\n#> 1:           Asian  4193\n#> 2:           Black  1860\n#> 3:   International  7354\n#> 4:          Latine  5386\n#> 5: Native American   403\n#> 6:   Other/Unknown  4509\n#> 7:           White 73850\n\ncheck_equiv_frames(result_df, result_dt)\n#> [1] TRUE\ncheck_equiv_frames(result_dt, result_tbl)\n#> [1] TRUE\n```\n:::\n\n\n[Comments]{.important} \n\n- *base R.* `table()` creates a contingency table---counts of every  combination of the grouping variables---that we convert to a data frame. Column names are assigned using the `dnn` and `responseName` arguments.  \n\n- *data.table.* The `.N` function is an integer containing the number of rows in each group, with grouping variables assigned using the `by` argument. `setorderv()` is optional. \n\n- *dplyr.* `count()` counts the number of unique values in a group. The response column name is assigned using the `name` argument (default is lower case `n`).  \n\n### With two or more grouping variables\n\nData.table and dplyr count the frequency of each grouping-variable combination  present in the data;  base R counts the frequencies of all combinations, inserting counts of zero as needed. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrouping_variables <- c(\"institution\", \"sex\", \"transfer\")\n```\n:::\n\n::: {.cell class='base'}\n\n```{.r .cell-code}\n# base R\nfreq_table <- table(student_df$institution,\n                    student_df$sex,\n                    student_df$transfer,\n                    dnn = grouping_variables)\nresult_df <- as.data.frame(freq_table, \n                           responseName = \"N\", \n                           stringsAsFactors = FALSE)\nresult_df <- result_df[result_df$N > 0, , drop = FALSE]\n```\n:::\n\n::: {.cell class='dtbl'}\n\n```{.r .cell-code}\n# data.table\nresult_dt <- student_dt[, .N, by = grouping_variables]\nsetorderv(result_dt, c(\"institution\", \"N\"), order = c(1, -1))\n```\n:::\n\n::: {.cell class='dplyr'}\n\n```{.r .cell-code}\n# dplyr\nresult_tbl <- student_tbl %>%\n count(institution, sex, transfer, name = \"N\") %>%\n arrange(institution, desc(N))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nresult_dt\n#>       institution     sex              transfer     N\n#>            <char>  <char>                <char> <int>\n#>  1: Institution B    Male First-Time in College 16998\n#>  2: Institution B  Female First-Time in College 15689\n#>  3: Institution B    Male   First-Time Transfer  6946\n#>  4: Institution B  Female   First-Time Transfer  6026\n#>  5: Institution B Unknown First-Time in College     1\n#>  6: Institution C  Female First-Time in College  9991\n#>  7: Institution C    Male First-Time in College  8779\n#>  8: Institution C  Female   First-Time Transfer  3978\n#>  9: Institution C    Male   First-Time Transfer  3964\n#> 10: Institution J    Male First-Time in College 12051\n#> 11: Institution J  Female First-Time in College  9180\n#> 12: Institution J    Male   First-Time Transfer  2413\n#> 13: Institution J  Female   First-Time Transfer  1539\n\ncheck_equiv_frames(result_df, result_dt)\n#> [1] TRUE\ncheck_equiv_frames(result_dt, result_tbl)\n#> [1] TRUE\n```\n:::\n\n\n[Comments]{.important} \n\n- *base R.* Similar to the previous case with more grouping variables plus dropping rows with a count of zero to match the other systems' outputs. \n\n- *data.table.* Similar to the previous case with more grouping variables plus ordering rows by ascending institution (`order = 1`) and descending *N* (`order = -1`). \n\n- *dplyr.* Similar to the previous case with more grouping variables plus arranging rows with ascending institution  (default) and descending *N* using `desc()`. \n\n## Summarizing\n\nStatistical summaries are commonly encountered to help describe trends in data, e.g., mean, median, standard deviation, minima, maxima, etc.  \n\nOf the several summarizing options available in base R, `by()` seems the simplest to provide here. It generalizes easily to multiple and different summaries and the only cognitive overhead is the need to know about `do.call()`, `rbind()`, and anonymous functions. \n\n### With one grouping variable\n\n[Task.]{.important} determine the 10% quantile, median, and 90% quantile of term GPA by academic standing (good standing, academic warning, etc.) plus the number of observations used in the summary. In all systems, we use the base R `quanitile()` function to determine the 10% and 90% quantiles. \n\n\n::: {.cell class='base'}\n\n```{.r .cell-code}\n# base R\nDF <- term_df[!is.na(term_df$gpa_term), , drop = FALSE]\nDF_by <- by(DF, list(DF$standing), function(df) {\n  data.frame(standing = unique(df$standing), \n             N = nrow(df), \n             quant_10 = quantile(df$gpa_term, 0.10), \n             median_gpa = median(df$gpa_term), \n             quant_90 = quantile(df$gpa_term, 0.90))\n  })\nresult_df <- do.call(rbind, DF_by)\n```\n:::\n\n::: {.cell class='dtbl'}\n\n```{.r .cell-code}\n# data.table\nDT <- na.omit(term_dt, \"gpa_term\")\nresult_dt <- DT[, .(.N, \n                    quant_10 = quantile(gpa_term, 0.10), \n                    median_gpa = median(gpa_term), \n                    quant_90 = quantile(gpa_term, 0.90)), \n                by = c(\"standing\")]\nsetorder(result_dt, -median_gpa)\n```\n:::\n\n::: {.cell class='dplyr'}\n\n```{.r .cell-code}\n# dplyr\nresult_tbl <- term_tbl %>%\n  drop_na(gpa_term) %>%\n  group_by(standing) %>%\n  summarise(N = n(),\n         quant_10 = quantile(gpa_term, 0.10), \n         median_gpa = median(gpa_term), \n         quant_90 = quantile(gpa_term, 0.90)) %>%\n  arrange(-median_gpa)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nresult_dt\n#>              standing      N quant_10 median_gpa quant_90\n#>                <char>  <int>    <num>      <num>    <num>\n#> 1:      Good Standing 589883     2.33       3.14     3.90\n#> 2: Academic Probation  18489     1.27       1.79     2.30\n#> 3:   Academic Warning  25961     1.14       1.72     1.93\n#> 4: Academic Dismissal   2208     1.00       1.53     1.89\n\ncheck_equiv_frames(result_df, result_dt)\n#> [1] TRUE\ncheck_equiv_frames(result_dt, result_tbl)\n#> [1] TRUE\n```\n:::\n\n\n[Comments]{.important} \n\n- *base R.* `by()` is an implementation of `split() + lapply()` (the first two parts of the well-known split-apply-combine method) that yields a list of data frames, one per each combination the grouping variables. `rbind()` combines those results into a single data frame. `function(df)` is an anonymous function, that is, a function used without assigning it a name in the workspace. \n\n- *data.table.* \n\n- *dplyr.* \n\n\n\n### With two or more grouping variables\n\n\n::: {.cell class='base'}\n\n```{.r .cell-code}\n# base R\nDF <- term_df[!is.na(term_df$gpa_term), , drop = FALSE]\nDF_by <- by(DF, list(DF$standing, DF$level), FUN = function(df) {\n  data.frame(standing = unique(df$standing), \n             level = unique(df$level),\n             N = nrow(df), \n             quant_10 = quantile(df$gpa_term, 0.10), \n             median_gpa = median(df$gpa_term), \n             quant_90 = quantile(df$gpa_term, 0.90))\n  })\nresult_df <- do.call(rbind, DF_by)\norder_index <- order(-result_df$median_gpa, -result_df$quant_90)\nresult_df <- result_df[order_index, , drop = FALSE]\n```\n:::\n\n::: {.cell class='dtbl'}\n\n```{.r .cell-code}\n# data.table\nDT <- na.omit(term_dt, \"gpa_term\")\nresult_dt <- DT[, .(.N, \n                    quant_10 = quantile(gpa_term, 0.10), \n                    median_gpa = median(gpa_term), \n                    quant_90 = quantile(gpa_term, 0.90)), \n                by = c(\"standing\", \"level\")]\nsetorder(result_dt, -median_gpa, -quant_90)\n```\n:::\n\n::: {.cell class='dplyr'}\n\n```{.r .cell-code}\n# dplyr\nresult_tbl <- term_tbl %>%\n  drop_na(gpa_term) %>%\n  group_by(standing, level) %>%\n  summarise(N = n(),\n         quant_10 = quantile(gpa_term, 0.10), \n         median_gpa = median(gpa_term), \n         quant_90 = quantile(gpa_term, 0.90)) %>%\n  arrange(desc(median_gpa), desc(quant_90))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nresult_dt\n#>               standing              level      N quant_10 median_gpa quant_90\n#>                 <char>             <char>  <int>    <num>      <num>    <num>\n#>  1:      Good Standing 05 Fifth-year Plus  38498    2.500       3.35    4.000\n#>  2:      Good Standing     04 Fourth-year 105146    2.440       3.28    3.940\n#>  3:      Good Standing      03 Third-year 140593    2.380       3.18    3.910\n#>  4:      Good Standing     02 Second-year 161786    2.310       3.08    3.850\n#>  5:      Good Standing      01 First-year 143860    2.250       3.00    3.820\n#>  6: Academic Probation      03 Third-year   1030    1.309       2.00    2.670\n#>  7: Academic Probation     04 Fourth-year    226    1.370       1.98    2.870\n#>  8: Academic Probation     02 Second-year   4318    1.300       1.90    2.560\n#>  9: Academic Probation 05 Fifth-year Plus     37    1.442       1.80    3.000\n#> 10: Academic Probation      01 First-year  12878    1.250       1.75    2.080\n#> 11:   Academic Warning      01 First-year   3931    1.260       1.75    1.940\n#> 12:   Academic Warning     02 Second-year   9911    1.200       1.74    1.940\n#> 13:   Academic Warning      03 Third-year   6831    1.030       1.70    1.930\n#> 14:   Academic Warning     04 Fourth-year   4078    1.000       1.70    1.930\n#> 15:   Academic Warning 05 Fifth-year Plus   1210    1.000       1.70    1.920\n#> 16: Academic Dismissal      01 First-year   1671    1.000       1.54    1.900\n#> 17: Academic Dismissal      03 Third-year     75    1.000       1.53    1.866\n#> 18: Academic Dismissal     02 Second-year    440    1.000       1.50    1.860\n#> 19: Academic Dismissal     04 Fourth-year     20    0.700       1.42    1.692\n#> 20: Academic Dismissal 05 Fifth-year Plus      2    1.062       1.31    1.558\n#>               standing              level      N quant_10 median_gpa quant_90\n\nall.equal(result_df, result_dt, check.attributes = FALSE)\n#> [1] TRUE\nall.equal(result_dt, result_tbl, check.attributes = FALSE)\n#> [1] TRUE\n```\n:::\n\n\n[Comments]{.important} \n\n- *base R.* Add the second grouping variable `level` in two places. \n\n- *data.table.* Add a second grouping variable to the `by` argument. Order by descending median GPA with the 90% quantile used to break ties. \n\n- *dplyr.* Add a second grouping variable to `group_by()`. \n\n\n\n\n\n\n\n\n## References \n\n<div id=\"refs\"></div>\n",
    "supporting": [
      "data-shaping-03-aggregating-transforms_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}