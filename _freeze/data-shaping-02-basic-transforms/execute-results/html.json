{
  "hash": "3e5fe841749cb81f127aefc67c2707a4",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Basic transforms\"\nformat:\n  html:\n    css: styles.css\n---\n\n\n![Image: *Transformers* by danjo paluska is licensed under [CC BY 2.0](https://creativecommons.org/licenses/by/2.0/)](figures/data-shaping-2.png)\n\n\n\n\n\nUsing **base R**, **data.table**, and **dplyr** to transform MIDFIELD data as needed for your analysis.\n\n- [Introduction](data-shaping-00-introduction.html) \n- [Data selection](data-shaping-01-data-selection.html) \n- [Basic transforms](data-shaping-02-basic-transforms.html) &#9665; *You are here.*\n- [Aggregating transforms](data-shaping-03-aggregating-transforms.html) \n- [Multitable transforms](data-shaping-04-multitable-transforms.html) \n- [Reshaping transforms](data-shaping-05-reshaping-transforms.html)\n\nIn this section we demonstrate adding and removing columns, editing column names, creating two new columns by splitting a character column, converting the class of a column, and recoding the values in a column. \n\n## Getting started\n\nPackages and datasets, as shown in the  [Introduction](data-shaping-00-introduction.html) to data shaping.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(midfielddata) # datasets\nlibrary(data.table) # data manipulation system\nlibrary(dplyr) # data manipulation system\nlibrary(tidyr) # drop_na()\n\ndata(student, term)\n\nstudent_base <- data.frame(student)\nstudent_DT <- copy(student)\nstudent_dplyr <- tibble(student)\n\nterm_base <- data.frame(term)\nterm_DT <- copy(term)\nterm_dplyr <- tibble(term)\n```\n:::\n\n\n## Adding columns\n\n*Task.* &nbsp; Add a column to the student table for total SAT score. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolumns_we_want <- c(\"mcid\", \"sat_math\", \"sat_verbal\", \"act_comp\")\n```\n:::\n\n::: {.cell class='base'}\n\n```{.r .cell-code}\n# base R\nresult_base <- student_base[, columns_we_want, drop = FALSE]\nresult_base$sat_total <- result_base$sat_math + result_base$sat_verbal\n```\n:::\n\n::: {.cell class='dtbl'}\n\n```{.r .cell-code}\n# data.table\nresult_DT <- student_DT[, ..columns_we_want]\nresult_DT[, sat_total := sat_math + sat_verbal]\n```\n:::\n\n::: {.cell class='dplyr'}\n\n```{.r .cell-code}\n# dplyr\nresult_dplyr <- student_dplyr %>%\n  select(all_of(columns_we_want)) %>%\n  mutate(sat_total = sat_math + sat_verbal)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nresult_DT\n#>                  mcid sat_math sat_verbal act_comp sat_total\n#>                <char>    <num>      <num>    <num>     <num>\n#>     1: MCID3111142225       NA         NA       NA        NA\n#>     2: MCID3111142283      560        230       NA       790\n#>     3: MCID3111142290      510        380       NA       890\n#>     4: MCID3111142294      640        460       NA      1100\n#>     5: MCID3111142299      600        500       NA      1100\n#>    ---                                                      \n#> 97551: MCID3112898886      530        560       29      1090\n#> 97552: MCID3112898890      570        580       25      1150\n#> 97553: MCID3112898894      510        590       24      1100\n#> 97554: MCID3112898895      420        590       32      1010\n#> 97555: MCID3112898940      470        540       32      1010\n\nall.equal(result_DT, data.table(result_base))\n#> [1] TRUE\nall.equal(result_DT, data.table(result_dplyr))\n#> [1] TRUE\n```\n:::\n\n\n*Comments*\n\n- *base R.* `df$new_col` creates the new column.  \n\n- *data.table.* `:=` alters or creates columns \"in place\". The `data.table` at hand gets altered instead of a new one being created.  \n\n- *dplyr.* New columns are created with `mutate()`. \n\n## Removing columns\n\nIn previous examples, when selecting some columns we have implicitly removed every column not selected (if any). Here we explicitly select the columns to be removed.  \n\n*Task.* &nbsp; Using the results from the previous example, remove the SAT math and verbal columns. \n\n\n::: {.cell class='base'}\n\n```{.r .cell-code}\n# base R\nresult_base$sat_math <- NULL\nresult_base$sat_verbal <- NULL\n```\n:::\n\n::: {.cell class='dtbl'}\n\n```{.r .cell-code}\n# data.table\nresult_DT[, c(\"sat_math\", \"sat_verbal\") := NULL]\n```\n:::\n\n::: {.cell class='dplyr'}\n\n```{.r .cell-code}\n# dplyr\nresult_dplyr <- result_dplyr %>%\n  select(-sat_math, -sat_verbal)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nresult_DT\n#>                  mcid act_comp sat_total\n#>                <char>    <num>     <num>\n#>     1: MCID3111142225       NA        NA\n#>     2: MCID3111142283       NA       790\n#>     3: MCID3111142290       NA       890\n#>     4: MCID3111142294       NA      1100\n#>     5: MCID3111142299       NA      1100\n#>    ---                                  \n#> 97551: MCID3112898886       29      1090\n#> 97552: MCID3112898890       25      1150\n#> 97553: MCID3112898894       24      1100\n#> 97554: MCID3112898895       32      1010\n#> 97555: MCID3112898940       32      1010\n\nall.equal(result_DT, data.table(result_base))\n#> [1] TRUE\nall.equal(result_DT, data.table(result_dplyr))\n#> [1] TRUE\n```\n:::\n\n\n*Comments*\n\n- *base R.* \n\n- *data.table.*  Use a vector of column names and `:=` to remove the columns \"in place\". \n\n- *dplyr.* Use `select()` with minus signs. \n\n## Editing column names\n\n*Task.* &nbsp; Using the results from the previous example, rename the columns. \n\nIn each case, we take care to explicitly match old and new names.  \n\n\n::: {.cell class='base'}\n\n```{.r .cell-code}\n# base R\nnames(result_base)[names(result_base) == \"mcid\"] <- \"Student\"\nnames(result_base)[names(result_base) == \"sat_total\"] <- \"SAT\"\nnames(result_base)[names(result_base) == \"act_comp\"] <- \"ACT\"\n```\n:::\n\n::: {.cell class='dtbl'}\n\n```{.r .cell-code}\n# data.table\nsetnames(result_DT,\n  old = c(\"mcid\", \"sat_total\", \"act_comp\"),\n  new = c(\"Student\", \"SAT\", \"ACT\")\n)\n```\n:::\n\n::: {.cell class='dplyr'}\n\n```{.r .cell-code}\n# dplyr\nresult_dplyr <- result_dplyr %>%\n\trename(Student = mcid, SAT = sat_total, ACT = act_comp)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nresult_DT\n#>               Student   ACT   SAT\n#>                <char> <num> <num>\n#>     1: MCID3111142225    NA    NA\n#>     2: MCID3111142283    NA   790\n#>     3: MCID3111142290    NA   890\n#>     4: MCID3111142294    NA  1100\n#>     5: MCID3111142299    NA  1100\n#>    ---                           \n#> 97551: MCID3112898886    29  1090\n#> 97552: MCID3112898890    25  1150\n#> 97553: MCID3112898894    24  1100\n#> 97554: MCID3112898895    32  1010\n#> 97555: MCID3112898940    32  1010\n\nall.equal(result_DT, data.table(result_base))\n#> [1] TRUE\nall.equal(result_DT, data.table(result_dplyr))\n#> [1] TRUE\n```\n:::\n\n\n*Comments*\n\n- *base R.* While other approaches work too, this approach ensures that old and new names are explicitly matched. \n\n- *data.table.*  `setnames()` edits the column names in place. \n\n- *dplyr.* `rename()` uses `new_name = old_name` syntax.  \n\n## Split a character column\n\n*Task.* &nbsp; In the `term` data, create new columns for year `YYYY` and term code `T` by splitting the character `term` column. \n\nIn each system, we use the base R `substr()` function to split the `term` character value into a 4-character year in one new column and a 1-character term-code in a new second column. We also drop rows with missing values (if any). \n \n\n::: {.cell}\n\n```{.r .cell-code}\ncolumns_we_want <- c(\"mcid\", \"term\")\n```\n:::\n\n::: {.cell class='base'}\n\n```{.r .cell-code}\n# base R\nDF <- term_base[, columns_we_want, drop = FALSE]\nDF$year <- substr(DF$term, 1, 4)\nDF$term_code <- substr(DF$term, 5, 5)\nresult_base <- na.omit(DF)\n```\n:::\n\n::: {.cell class='dtbl'}\n\n```{.r .cell-code}\n# data.table\nDT <- term_DT[, ..columns_we_want]\nDT[, c(\"year\", \"term_code\") := .(substr(term, 1, 4), substr(term, 5, 5))]\nresult_DT <- na.omit(DT)\n```\n:::\n\n::: {.cell class='dplyr'}\n\n```{.r .cell-code}\n# dplyr\nresult_dplyr <- term_dplyr %>%\n  select(mcid, term) %>%\n  mutate(year = substr(term, 1, 4), term_code = substr(term, 5, 5)) %>%\n  drop_na()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\noptions(datatable.print.topn = 5)\nresult_DT\n#>                   mcid   term   year term_code\n#>                 <char> <char> <char>    <char>\n#>      1: MCID3111142225  19881   1988         1\n#>      2: MCID3111142283  19881   1988         1\n#>      3: MCID3111142283  19883   1988         3\n#>      4: MCID3111142283  19885   1988         5\n#>      5: MCID3111142283  19891   1989         1\n#>     ---                                       \n#> 639911: MCID3112898886  20181   2018         1\n#> 639912: MCID3112898890  20181   2018         1\n#> 639913: MCID3112898894  20181   2018         1\n#> 639914: MCID3112898895  20181   2018         1\n#> 639915: MCID3112898940  20181   2018         1\n\nall.equal(result_DT, data.table(result_base))\n#> [1] TRUE\nall.equal(result_DT, data.table(result_dplyr))\n#> [1] TRUE\n```\n:::\n\n\n*Comments*\n\n- *base R.* \n\n- *data.table.*  \n\n- *dplyr.* \n\n## Convert column class\n\n*Task.* &nbsp; Using the results from the previous example, convert character year to numerical class.\n\n\n::: {.cell class='base'}\n\n```{.r .cell-code}\n# base R\nresult_base$year <- as.double(result_base$year)\n```\n:::\n\n::: {.cell class='dtbl'}\n\n```{.r .cell-code}\n# data.table\nresult_DT[, year := as.double(year)]\n```\n:::\n\n::: {.cell class='dplyr'}\n\n```{.r .cell-code}\n# dplyr\nresult_dplyr <- result_dplyr %>%\n  mutate(year = as.double(year))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nresult_DT\n#>                   mcid   term  year term_code\n#>                 <char> <char> <num>    <char>\n#>      1: MCID3111142225  19881  1988         1\n#>      2: MCID3111142283  19881  1988         1\n#>      3: MCID3111142283  19883  1988         3\n#>      4: MCID3111142283  19885  1988         5\n#>      5: MCID3111142283  19891  1989         1\n#>     ---                                      \n#> 639911: MCID3112898886  20181  2018         1\n#> 639912: MCID3112898890  20181  2018         1\n#> 639913: MCID3112898894  20181  2018         1\n#> 639914: MCID3112898895  20181  2018         1\n#> 639915: MCID3112898940  20181  2018         1\n\nall.equal(result_DT, data.table(result_base))\n#> [1] TRUE\nall.equal(result_DT, data.table(result_dplyr))\n#> [1] TRUE\n```\n:::\n\n\n*Comments*\n\n- *base R.* \n\n- *data.table.*  \n\n- *dplyr.* \n\n## Recode column values\n\n*Task.* &nbsp; Using the results from the previous example, recode the term-codes from numbers to academic terms \"Fall\", \"Winter\", etc.\n\n\"Recoding\" typically entails replacing existing values in a column with new, recoded values. For the sake of clarity in this example we assign the new encodings to a new column---not strictly necessary but it makes it easier to check the results. The existing column is `term_code`; the new column is `term_name`. \n\n\n::: {.cell class='base'}\n\n```{.r .cell-code}\n# base R\nresult_base <- within(result_base, {\n\tterm_name <- NA\n\tterm_name[term_code == \"1\"] <- \"Fall\"\n\tterm_name[term_code == \"2\"] <- \"Winter\"\n\tterm_name[term_code == \"3\"] <- \"Spring\"\n\tterm_name[term_code == \"4\"] <- \"Summer 1\"\n\tterm_name[term_code == \"5\"] <- \"Summer 2\"\n\tterm_name[term_code == \"6\"] <- \"Summer 3\"\n})\n```\n:::\n\n::: {.cell class='dtbl'}\n\n```{.r .cell-code}\n# data.table\nresult_DT[, term_name := fcase(\n  term_code == \"1\", \"Fall\",\n  term_code == \"2\", \"Winter\",\n  term_code == \"3\", \"Spring\",\n  term_code == \"4\", \"Summer 1\",\n  term_code == \"5\", \"Summer 2\",\n  term_code == \"6\", \"Summer 3\"\n)]\n```\n:::\n\n::: {.cell class='dplyr'}\n\n```{.r .cell-code}\n# dplyr\nresult_dplyr <- result_dplyr %>%\n  mutate(term_name = case_match(\n    term_code,\n    \"1\" ~ \"Fall\",\n    \"2\" ~ \"Winter\",\n    \"3\" ~ \"Spring\",\n    \"4\" ~ \"Summer 1\",\n    \"5\" ~ \"Summer 2\",\n    \"6\" ~ \"Summer 3\"\n  ))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nresult_DT\n#>                   mcid   term  year term_code term_name\n#>                 <char> <char> <num>    <char>    <char>\n#>      1: MCID3111142225  19881  1988         1      Fall\n#>      2: MCID3111142283  19881  1988         1      Fall\n#>      3: MCID3111142283  19883  1988         3    Spring\n#>      4: MCID3111142283  19885  1988         5  Summer 2\n#>      5: MCID3111142283  19891  1989         1      Fall\n#>     ---                                                \n#> 639911: MCID3112898886  20181  2018         1      Fall\n#> 639912: MCID3112898890  20181  2018         1      Fall\n#> 639913: MCID3112898894  20181  2018         1      Fall\n#> 639914: MCID3112898895  20181  2018         1      Fall\n#> 639915: MCID3112898940  20181  2018         1      Fall\n\nall.equal(result_DT, data.table(result_base))\n#> [1] TRUE\nall.equal(result_DT, data.table(result_dplyr))\n#> [1] TRUE\n```\n:::\n\n\n*Comments*\n\n- *base R.* `within()` is similar to `with()` but allows us to modify a data frame. We create the new column with `term_name <- NA` then systematically edit its values based on the values in `term_code`. \n\n- *data.table.* `term_name` is created using `:=` then `fcase()` assigns its  values based on logical expressions operating on `term_code`. \n\n- *dplyr.* `term_name` is created using `mutate()` then `case_match()` assigns its values by finding matches to the `term_code` values. \n\n## References \n\n<div id=\"refs\"></div>\n",
    "supporting": [
      "data-shaping-02-basic-transforms_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}