{
  "hash": "88460e5f7c47be4cb8c291ff9bbcb051",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Data selection\"\n---\n\n\n![Image: *Select* by Mike Lawrence is licensed under [CC BY 2.0](https://creativecommons.org/licenses/by/2.0/)](figures/data-shaping-1.png)\n\n\n\n\n\nUsing **base R**, **data.table**, and **dplyr/tidyr** to transform MIDFIELD data as needed for your analysis.\n\nIn this section we demonstrate subsetting rows and columns in various configurations, removing records with incomplete data, and reordering rows and columns.  \n\n\n## Setup\n\n*Load* packages.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"midfielddata\")\nlibrary(\"data.table\")\nlibrary(\"dplyr\", warn.conflicts = FALSE)\nlibrary(\"tidyr\")\nlibrary(\"wrapr\")\n```\n:::\n\n\n*Format* data as described in the  [Introduction](data-shaping-00-introduction.html).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(student, term)\n```\n:::\n\n::: {.cell class='base'}\n\n```{.r .cell-code}\n# base R\nstudent_df <- data.frame(student)\nterm_df <- data.frame(term)\n```\n:::\n\n::: {.cell class='dtbl'}\n\n```{.r .cell-code}\n# data.table\nstudent_dt <- copy(student)\nterm_dt <- copy(term)\n```\n:::\n\n::: {.cell class='dplyr'}\n\n```{.r .cell-code}\n# dplyr\nstudent_tbl <- tibble(student)\nterm_tbl <- tibble(term)\n```\n:::\n\n\n<br>\n\n\n## Subsetting rows and columns\n\nA common task when working with data is selecting a subset of rows,  columns, or both. \n\n\n\n\n### Indirect indexing\n\nUsing intermediate variables `columns_we_want` and `rows_we_want` that refer to the values used to subset rows and columns.\n\n[Task.]{.important} Prepare data to summarize domestic students by race, sex, and institution.\n\nOur first step might be to subset columns (institution, race, sex, and us_citizen) and subset rows such that US citizenship is true. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# character vector of column names\ncolumns_we_want <- c(\"institution\", \"race\", \"sex\", \"us_citizen\")\n```\n:::\n\n::: {.cell class='base'}\n\n```{.r .cell-code}\n# base R\nrows_we_want <- student_df$us_citizen == \"Yes\"\nresult_df <- student_df[rows_we_want, columns_we_want, drop = FALSE]\n```\n:::\n\n::: {.cell class='dtbl'}\n\n```{.r .cell-code}\n# data.table\nrows_we_want <- student_dt$us_citizen == \"Yes\"\nresult_dt <- student_dt[rows_we_want, ..columns_we_want]\n```\n:::\n\n::: {.cell class='dplyr'}\n\n```{.r .cell-code}\n# dplyr\nrows_we_want <- student_tbl$us_citizen == \"Yes\"\nresult_tbl <- student_tbl %>%\n  select(all_of(columns_we_want)) %>%\n  filter(rows_we_want)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nresult_dt\n#>          institution          race    sex us_citizen\n#>               <char>        <char> <char>     <char>\n#>     1: Institution B         Asian   Male        Yes\n#>     2: Institution J         Asian Female        Yes\n#>     3: Institution J         Asian   Male        Yes\n#>     4: Institution J         Asian   Male        Yes\n#>     5: Institution J         Asian   Male        Yes\n#>    ---                                              \n#> 90387: Institution B         White Female        Yes\n#> 90388: Institution B         White Female        Yes\n#> 90389: Institution B         White Female        Yes\n#> 90390: Institution B         White Female        Yes\n#> 90391: Institution B Other/Unknown   Male        Yes\n\ncheck_equiv_frames(result_df, result_dt)\n#> [1] TRUE\ncheck_equiv_frames(result_dt, result_tbl)\n#> [1] TRUE\n```\n:::\n\n\n[Comments]{.important}\n\n- *base R.* Base R's default behavior when selecting a single column is to return a vector. Thus, when working with `[,]` always add a third argument `drop = FALSE` to ensure a data frame is returned. \n\n- *data.table.* The `..` notation indicates that `columns_we_want` refers to a character vector of column names and is not itself a column name. \n\n- *dplyr.* The added notation `all_of()` in effect serves the same purpose in dplyr as `..` does in data.table. \n\n### Direct indexing\n\nColumn and row selection that is typed directly into the subsetting operators `[,]` or `filter()` and `select()` without using intermediate variables. \n\n[Task.]{.important} Same as previous example. \n\n\n::: {.cell class='base'}\n\n```{.r .cell-code}\n# base R\nresult_df <- student_df[student_df$us_citizen == \"Yes\",\n  c(\"institution\", \"race\", \"sex\", \"us_citizen\"),\n  drop = FALSE\n]\n```\n:::\n\n::: {.cell class='dtbl'}\n\n```{.r .cell-code}\n# data.table\nresult_dt <- student_dt[us_citizen == \"Yes\", .(institution, race, sex, us_citizen)]\n```\n:::\n\n::: {.cell class='dplyr'}\n\n```{.r .cell-code}\n# dplyr\nresult_tbl <- student_tbl %>%\n  select(institution, race, sex, us_citizen) %>%\n  filter(us_citizen == \"Yes\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nresult_dt\n#>          institution          race    sex us_citizen\n#>               <char>        <char> <char>     <char>\n#>     1: Institution B         Asian   Male        Yes\n#>     2: Institution J         Asian Female        Yes\n#>     3: Institution J         Asian   Male        Yes\n#>     4: Institution J         Asian   Male        Yes\n#>     5: Institution J         Asian   Male        Yes\n#>    ---                                              \n#> 90387: Institution B         White Female        Yes\n#> 90388: Institution B         White Female        Yes\n#> 90389: Institution B         White Female        Yes\n#> 90390: Institution B         White Female        Yes\n#> 90391: Institution B Other/Unknown   Male        Yes\n\ncheck_equiv_frames(result_df, result_dt)\n#> [1] TRUE\ncheck_equiv_frames(result_dt, result_tbl)\n#> [1] TRUE\n```\n:::\n\n\n[Comments]{.important}\n\n- *base R.* For direct indexing, intermediate variable names in `[,]` are replaced verbatim by their values. \n\n- *data.table.* The notation `.()` subsets columns by name without quotation marks;  rows are subset without the `$` operator.\n\n- *dplyr.* Similarly, `select()` operates on unquoted column names; rows are subset without the `$` operator. \n\n### Subset rows with multiple conditions\n\nMultiple logical conditions are combined with operators such as & (and), | (or), ! (not), etc.  \n\n[Task.]{.important} Find IDs of transfer students with 15 or more credit hours transferred.   \n\nWhen a variable is overwritten multiple times to get to a result, we will sometimes employ the variable `DF` as an intermediate variable. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolumns_we_want <- c(\"mcid\", \"transfer\", \"hours_transfer\")\n```\n:::\n\n::: {.cell class='base'}\n\n```{.r .cell-code}\n# base R\nrows_we_want <- student_df$transfer == \"First-Time Transfer\" & student_df$hours_transfer >= 15\nDF <- student_df[rows_we_want, columns_we_want, drop = FALSE]\n\n# remove rows with NA in every column\nrows_we_want <- rowSums(is.na(DF)) < ncol(DF)\nresult_df <- DF[rows_we_want, , drop = FALSE]\n```\n:::\n\n::: {.cell class='dtbl'}\n\n```{.r .cell-code}\n# data.table\nresult_dt <- student_dt[transfer == \"First-Time Transfer\" & hours_transfer >= 15, ..columns_we_want]\n```\n:::\n\n::: {.cell class='dplyr'}\n\n```{.r .cell-code}\n# dplyr\nresult_tbl <- student_tbl %>%\n  select(mcid, transfer, hours_transfer) %>%\n  filter(transfer == \"First-Time Transfer\" & hours_transfer >= 15)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nresult_dt\n#>                 mcid            transfer hours_transfer\n#>               <char>              <char>          <num>\n#>    1: MCID3111142840 First-Time Transfer             44\n#>    2: MCID3111142895 First-Time Transfer             16\n#>    3: MCID3111142910 First-Time Transfer             41\n#>    4: MCID3111142914 First-Time Transfer            156\n#>    5: MCID3111142983 First-Time Transfer             24\n#>   ---                                                  \n#> 9458: MCID3112898091 First-Time Transfer            110\n#> 9459: MCID3112898410 First-Time Transfer             71\n#> 9460: MCID3112898411 First-Time Transfer             68\n#> 9461: MCID3112898412 First-Time Transfer             30\n#> 9462: MCID3112898801 First-Time Transfer            218\n\ncheck_equiv_frames(result_df, result_dt)\n#> [1] TRUE\ncheck_equiv_frames(result_dt, result_tbl)\n#> [1] TRUE\n```\n:::\n\n\n[Comments]{.important}\n\n- *base R.* Two steps required. Subset rows by the original logical conditions; then subset to remove rows with NA across all columns. `rowSums()` assigns 1 to TRUE and 0 to FALSE. If the number of NAs in a row is less than the number of columns, then that row contains non-NA data and we keep it.\n\n- *data.table.* Multiple conditions separated by logical AND `&`. Does not generate all-NA rows as in base R.  \n\n- *dplyr.* Similar. \n\n### Subset rows to omit values\n\nSometimes the intention of a row subset is to keep all rows except those that contain a particular value---implemented with a logical NOT (`!`). \n\n[Task.]{.important} Retain all rows of the `student` data except those with an \"unknown\" value (case-insensitive) in the `sex` column. \n\n\n::: {.cell class='base'}\n\n```{.r .cell-code}\n# base R\nrows_we_want <- !grepl(\"unknown\", student_df$sex, ignore.case = TRUE)\nresult_df <- student_df[rows_we_want, , drop = FALSE]\n```\n:::\n\n::: {.cell class='dtbl'}\n\n```{.r .cell-code}\n# data.table\nresult_dt <- student_dt[!sex %ilike% \"unknown\"]\n```\n:::\n\n::: {.cell class='dplyr'}\n\n```{.r .cell-code}\n# dplyr\nresult_tbl <- student_tbl %>%\n  filter(!grepl(\"unknown\", sex, ignore.case = TRUE))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(result_dt)\n#> Rows: 97,554\n#> Columns: 13\n#> $ mcid           <chr> \"MCID3111142225\", \"MCID3111142283\", \"MCID3111142290\", \"…\n#> $ institution    <chr> \"Institution B\", \"Institution J\", \"Institution J\", \"Ins…\n#> $ transfer       <chr> \"First-Time Transfer\", \"First-Time Transfer\", \"First-Ti…\n#> $ hours_transfer <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n#> $ race           <chr> \"Asian\", \"Asian\", \"Asian\", \"Asian\", \"Asian\", \"Asian\", \"…\n#> $ sex            <chr> \"Male\", \"Female\", \"Male\", \"Male\", \"Male\", \"Male\", \"Male…\n#> $ age_desc       <chr> \"Under 25\", \"Under 25\", \"Under 25\", \"Under 25\", \"Under …\n#> $ us_citizen     <chr> \"Yes\", \"Yes\", \"Yes\", \"Yes\", \"Yes\", \"Yes\", \"Yes\", \"Yes\",…\n#> $ home_zip       <chr> NA, \"22020\", \"23233\", \"20853\", \"22003\", \"23234\", \"24148…\n#> $ high_school    <chr> NA, NA, \"471872\", NA, \"470080\", \"471877\", NA, NA, NA, N…\n#> $ sat_math       <dbl> NA, 560, 510, 640, 600, 570, 480, NA, NA, NA, 520, 430,…\n#> $ sat_verbal     <dbl> NA, 230, 380, 460, 500, 530, 530, NA, NA, NA, 490, 490,…\n#> $ act_comp       <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n\ncheck_equiv_frames(result_df, result_dt)\n#> [1] TRUE\ncheck_equiv_frames(result_dt, result_tbl)\n#> [1] TRUE\n```\n:::\n\n\n[Comments]{.important}\n\n- *base R.* Uses `grepl()` \n\n- *data.table.* `%ilike%` is shorthand for `grepl()` with `ignore.case = TRUE`\n\n- *dplyr.* Also uses `grepl()`\n\nConfirm that the correct rows have been deleted. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Before deletions\nsort(unique(student_dt$sex))\n#> [1] \"Female\"  \"Male\"    \"Unknown\"\n# After deletions \nsort(unique(result_dt$sex))\n#> [1] \"Female\" \"Male\"\n```\n:::\n\n\n\n\n\n### Subset rows to retain the first instance\n\nWith student records, we may be interested in a student's first term. For example, we might want to know: \n\n- `level` or `standing` in the first term\n- `cip6` (program or major) in the first term\n\nThe `term` and `course` tables can have more than one \n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n### Subset one column as a vector\n\n[Task.]{.important} Obtain a vector (`vec`) of unique IDs in the `term` dataset.\n\nBecause results are vectors, we compare using `all.equal()` instead of `check_equiv_frames()`. \n\n\n::: {.cell class='base'}\n\n```{.r .cell-code}\n# base R\nvec_base <- term_df[, \"mcid\"]\nvec_base <- unique(vec_base)\n```\n:::\n\n::: {.cell class='dtbl'}\n\n```{.r .cell-code}\n# data.table\nvec_dtbl <- term_dt[, mcid]\nvec_dtbl <- unique(vec_dtbl)\n```\n:::\n\n::: {.cell class='dplyr'}\n\n```{.r .cell-code}\n# dplyr\nvec_dplyr <- term_tbl %>%\n  pull(mcid) %>%\n  unique()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(vec_dtbl)\n#>  chr [1:97555] \"MCID3111142225\" \"MCID3111142283\" \"MCID3111142290\" ...\n\nall.equal(vec_base, vec_dtbl)\n#> [1] TRUE\nall.equal(vec_dtbl, vec_dplyr)\n#> [1] TRUE\n```\n:::\n\n\n[Comments]{.important}\n\n- *base R.* For clarity, we deliberately write these steps in two lines of code. One could just as easily write the single line `result_df <- unique(term_df[, \"mcid\"])`.\n\n- *data.table.* \n\n- *dplyr.* `pull(mcid)` is safe as long as the `mcid` column exists in the data frame from which it is pulled. Safer to use `pull(.data$mcid)` as described in [@Layton:2024]. \n\n\n\n\n\n\n## Removing rows wirh incomplete records\n\nAn important variation of subsetting data is removing rows of data that have missing values. If appropriate, limit the dropped rows to those with missing values in specific columns. \n\n[Task.]{.important} We are asked to compare SAT scores by institution. Before doing any analysis, we first remove rows with missing SAT scores. \n\n### Delete rows with a missing value in any column. \n\n\n::: {.cell class='base'}\n\n```{.r .cell-code}\n# base R\nDF <- student_df[, c(\"institution\", \"sat_math\", \"sat_verbal\"), drop = FALSE]\nresult_df <- na.omit(DF)\n```\n:::\n\n::: {.cell class='dtbl'}\n\n```{.r .cell-code}\n# data.table\nDT <- student_dt[, .(institution, sat_math, sat_verbal)]\nresult_dt <- na.omit(DT)\n```\n:::\n\n::: {.cell class='dplyr'}\n\n```{.r .cell-code}\n# dplyr\nresult_tbl <- student_tbl %>%\n  select(institution, sat_math, sat_verbal) %>%\n  drop_na()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nresult_dt\n#>          institution sat_math sat_verbal\n#>               <char>    <num>      <num>\n#>     1: Institution J      560        230\n#>     2: Institution J      510        380\n#>     3: Institution J      640        460\n#>     4: Institution J      600        500\n#>     5: Institution J      570        530\n#>    ---                                  \n#> 77096: Institution B      530        560\n#> 77097: Institution B      570        580\n#> 77098: Institution B      510        590\n#> 77099: Institution B      420        590\n#> 77100: Institution B      470        540\n\ncheck_equiv_frames(result_df, result_dt)\n#> [1] TRUE\ncheck_equiv_frames(result_dt, result_tbl)\n#> [1] TRUE\n```\n:::\n\n\n[Comments]{.important} \n\n- *base R.* Where before we used the name `columns_we_want` to reference a character vector of column names, here we use the character vector itself. \n\n- *data.table.*  \n\n- *dplyr.* `drop_na()` is from the tidyr package. \n\n### Delete rows with a missing value in specified colums.\n\n[Task.]{.important} \n\n\n::: {.cell class='base'}\n\n```{.r .cell-code}\n# base R\nrows_we_want <- !(is.na(student_df$institution) |\n  is.na(student_df$sat_math) |\n  is.na(student_df$sat_verbal))\nresult_df <- student_df[rows_we_want, , drop = FALSE]\n```\n:::\n\n::: {.cell class='dtbl'}\n\n```{.r .cell-code}\n# data.table\nresult_dt <- na.omit(student_dt, cols = c(\"institution\", \"sat_math\", \"sat_verbal\"))\n```\n:::\n\n::: {.cell class='dplyr'}\n\n```{.r .cell-code}\n# dplyr\nresult_tbl <- student_tbl %>%\n  drop_na(institution, sat_math, sat_verbal)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nresult_dt\n#>                  mcid   institution              transfer hours_transfer\n#>                <char>        <char>                <char>          <num>\n#>     1: MCID3111142283 Institution J   First-Time Transfer             NA\n#>     2: MCID3111142290 Institution J   First-Time Transfer             NA\n#>     3: MCID3111142294 Institution J   First-Time Transfer             NA\n#>     4: MCID3111142299 Institution J   First-Time Transfer             NA\n#>     5: MCID3111142303 Institution J   First-Time Transfer             NA\n#>    ---                                                                  \n#> 77096: MCID3112898886 Institution B First-Time in College             NA\n#> 77097: MCID3112898890 Institution B First-Time in College             NA\n#> 77098: MCID3112898894 Institution B First-Time in College             NA\n#> 77099: MCID3112898895 Institution B First-Time in College             NA\n#> 77100: MCID3112898940 Institution B First-Time in College             NA\n#>                 race    sex age_desc us_citizen home_zip high_school sat_math\n#>               <char> <char>   <char>     <char>   <char>      <char>    <num>\n#>     1:         Asian Female Under 25        Yes    22020        <NA>      560\n#>     2:         Asian   Male Under 25        Yes    23233      471872      510\n#>     3:         Asian   Male Under 25        Yes    20853        <NA>      640\n#>     4:         Asian   Male Under 25        Yes    22003      470080      600\n#>     5:         Asian   Male Under 25        Yes    23234      471877      570\n#>    ---                                                                       \n#> 77096:         White Female Under 25        Yes    53711      501165      530\n#> 77097:         White Female Under 25        Yes    54956      501275      570\n#> 77098:         White Female Under 25        Yes    53716      501160      510\n#> 77099:         White Female Under 25        Yes    53029      500853      420\n#> 77100: Other/Unknown   Male Under 25        Yes    20016      090073      470\n#>        sat_verbal act_comp\n#>             <num>    <num>\n#>     1:        230       NA\n#>     2:        380       NA\n#>     3:        460       NA\n#>     4:        500       NA\n#>     5:        530       NA\n#>    ---                    \n#> 77096:        560       29\n#> 77097:        580       25\n#> 77098:        590       24\n#> 77099:        590       32\n#> 77100:        540       32\n\ncheck_equiv_frames(result_df, result_dt)\n#> [1] TRUE\ncheck_equiv_frames(result_dt, result_tbl)\n#> [1] TRUE\n```\n:::\n\n\n[Comments]{.important} \n\n- *base R.* Using logical operators `!` NOT and `|` OR to create a logical vector used as a row index. \n\n- *data.table.* The same function name `na.omit()` as base R but with an argument to drops rows with missing values in specified columns. Retains all columns. \n\n- *dplyr.* Similarly, `drop_na()` drops rows with missing values in  specified columns, retaining all columns. \n\n\n## Ordering rows or columns\n\nWe sometimes using the intermediate variables `order_index` (integer vector) or `order_cols` (character vector) to emphasize the steps of the ordering process. \n\n### Ascending rows\n\nIn all three systems, the default sort order is increasing (ascending) from rows 1 to *N*. \n\n[Task.]{.important} Suppose we want to know a student's level and declared major in their first term at their institution. We use the `term` dataset.  \nWe decide to order the rows first by institution, then by ID, then by term. In each case, we select columns in a separate operation so we can highlight the row-ordering operation.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolumns_we_want <- c(\"institution\", \"mcid\", \"term\", \"level\", \"cip6\")\n```\n:::\n\n::: {.cell class='base'}\n\n```{.r .cell-code}\n# base R\nDF <- term_df[, columns_we_want, drop = FALSE]\norder_index <- with(DF, order(institution, mcid, term))\nresult_df <- DF[order_index, , drop = FALSE]\n```\n:::\n\n::: {.cell class='dtbl'}\n\n```{.r .cell-code}\n# data.table\nresult_dt <- term_dt[, ..columns_we_want]\norder_cols <- c(\"institution\", \"mcid\", \"term\")\nsetorderv(result_dt, order_cols)\n```\n:::\n\n::: {.cell class='dplyr'}\n\n```{.r .cell-code}\n# dplyr\nresult_tbl <- term_tbl %>%\n  select(institution, mcid, term, level, cip6) %>%\n  arrange(institution, mcid, term)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nresult_dt\n#>           institution           mcid   term         level   cip6\n#>                <char>         <char> <char>        <char> <char>\n#>      1: Institution B MCID3111142225  19881 01 First-year 140901\n#>      2: Institution B MCID3111142689  19883 01 First-year 090401\n#>      3: Institution B MCID3111142729  19881 01 First-year 141901\n#>      4: Institution B MCID3111142729  19883 01 First-year 141901\n#>      5: Institution B MCID3111142819  19881 01 First-year 230101\n#>     ---                                                         \n#> 639911: Institution J MCID3112447745  20096 01 First-year 040201\n#> 639912: Institution J MCID3112447746  20096 01 First-year 190501\n#> 639913: Institution J MCID3112447751  20096 01 First-year 240102\n#> 639914: Institution J MCID3112447753  20096 01 First-year 520201\n#> 639915: Institution J MCID3112447754  20096 01 First-year 240102\n\nall.equal(result_df, result_dt, check.attributes = FALSE)\n#> [1] TRUE\nall.equal(result_dt, result_tbl, check.attributes = FALSE)\n#> [1] TRUE\n```\n:::\n\n\n[Comments]{.important} \n\n- *base R.* Using `with()`, we can list the variables to order by without using the `$` operator. \n\n- *data.table.* `setorderv()` reorders data in place---hence no assignment operator `<-` is required---and it operates on a character vector of column names.  \n\n- *dplyr.* `arrange()` orders the rows of a data frame by the values of selected columns. \n\n\n\n\n\n### Descending rows \n\nWhen we want a decreasing (descending) row order, it is typically  needed for some but not all of our columns. \n\n[Task.]{.important}  Sort students by institution and descending transfer hours. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolumns_we_want <- c(\"institution\", \"mcid\", \"hours_transfer\")\n```\n:::\n\n::: {.cell class='base'}\n\n```{.r .cell-code}\n# base R\nDF <- student_df[, columns_we_want, drop = FALSE]\nDF <- na.omit(DF)\norder_index <- with(DF, order(institution, -hours_transfer, mcid))\nresult_df <- DF[order_index, , drop = FALSE]\n```\n:::\n\n::: {.cell class='dtbl'}\n\n```{.r .cell-code}\n# data.table\nDT <- student_dt[, ..columns_we_want]\nresult_dt <- na.omit(DT)\norder_cols <- c(\"institution\", \"hours_transfer\", \"mcid\")\nsetorderv(result_dt, order_cols, order = c(1, -1, 1))\n```\n:::\n\n::: {.cell class='dplyr'}\n\n```{.r .cell-code}\n# dplyr\nresult_tbl <- student_tbl %>%\n  select(institution, mcid, hours_transfer) %>%\n  drop_na() %>%\n  arrange(institution, desc(hours_transfer), mcid)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nresult_dt\n#>          institution           mcid hours_transfer\n#>               <char>         <char>          <num>\n#>     1: Institution B MCID3112694097            278\n#>     2: Institution B MCID3112788655            271\n#>     3: Institution B MCID3112693474            238\n#>     4: Institution B MCID3112500991            229\n#>     5: Institution B MCID3112879516            228\n#>    ---                                            \n#> 13925: Institution C MCID3112785098              1\n#> 13926: Institution C MCID3112785144              1\n#> 13927: Institution C MCID3112785478              1\n#> 13928: Institution C MCID3112785480              1\n#> 13929: Institution C MCID3112785484              1\n\nall.equal(result_df, result_dt, check.attributes = FALSE)\n#> [1] TRUE\nall.equal(result_dt, result_tbl, check.attributes = FALSE)\n#> [1] TRUE\n```\n:::\n\n\n[Comments]{.important} \n\n- *base R.* Base R does not provide a general way to sort individual variables in descending order, but a minus sign works with numerical variables. The `decreasing` argument, if used, applies to all variables. \n\n- *data.table.* In `setorderv()`, add the `order` argument with `1` for ascending and `-1` for descending. \n\n- *dplyr.* In `arrange()` apply `desc()` to the descending variable. \n\n### Ordering columns\n\nWhenever we've subset columns using indirect or direct indexing, the placement of column names implicitly orders those columns. For example, using \n\n        columns_we_want <- c(\"institution\", \"race\", \"sex\", \"us_citizen\")\n\nas a column index yields a data frame with the columns in the order given. Sometimes however we want to move one or more columns to the left in a data frame. \n\n[Task.]{.important} Using the result from the previous example, move transfer hours to the leftmost column followed by ID. \n\n\n::: {.cell class='base'}\n\n```{.r .cell-code}\n# base R\ncolumn_order <- union(c(\"hours_transfer\", \"mcid\"), names(result_df))\nresult_df <- result_df[, column_order, drop = FALSE]\n```\n:::\n\n::: {.cell class='dtbl'}\n\n```{.r .cell-code}\n# data.table\nsetcolorder(result_dt, c(\"hours_transfer\", \"mcid\"))\n```\n:::\n\n::: {.cell class='dplyr'}\n\n```{.r .cell-code}\n# dplyr\nresult_tbl <- result_tbl %>%\n  relocate(hours_transfer, mcid)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nresult_dt\n#>        hours_transfer           mcid   institution\n#>                 <num>         <char>        <char>\n#>     1:            278 MCID3112694097 Institution B\n#>     2:            271 MCID3112788655 Institution B\n#>     3:            238 MCID3112693474 Institution B\n#>     4:            229 MCID3112500991 Institution B\n#>     5:            228 MCID3112879516 Institution B\n#>    ---                                            \n#> 13925:              1 MCID3112785098 Institution C\n#> 13926:              1 MCID3112785144 Institution C\n#> 13927:              1 MCID3112785478 Institution C\n#> 13928:              1 MCID3112785480 Institution C\n#> 13929:              1 MCID3112785484 Institution C\n\nall.equal(result_df, result_dt, check.attributes = FALSE)\n#> [1] TRUE\nall.equal(result_dt, result_tbl, check.attributes = FALSE)\n#> [1] TRUE\n```\n:::\n\n\n[Comments]{.important}\n\n- *base R.* `union()` is a set operation that discards duplicated values. The resulting character vector contains all the column names, reordered, and sorting is performed by `[`.   \n\n- *data.table.* `setcolorder()` changes the position of columns in a data frame, by reference, moving the specified columns to the \"front\". \n\n- *dplyr.*  `relocate()` changes the position of columns in a data frame moving the specified columns to the \"front\". \n\n\n## References \n\n<div id=\"refs\"></div>\n\n",
    "supporting": [
      "data-shaping-01-data-selection_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}