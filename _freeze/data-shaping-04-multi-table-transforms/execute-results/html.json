{
  "hash": "6e4adc86ea1f0d7b974955e0709c80ff",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Multi-table transforms\"\nformat:\n  html:\n    css: styles.css\n---\n\n\n![Image: *Merge* by Steve Walser is licensed under [CC BY-NC-ND 2.0](https://creativecommons.org/licenses/by-nc-nd/2.0/)](figures/data-shaping-4.png)\n\n\n\n\n\nUsing **base R**, **data.table**, and **dplyr** to transform MIDFIELD data as needed for your analysis.\n\n- [Introduction](data-shaping-00-introduction.html)\n- [Data selection](data-shaping-01-data-selection.html)\n- [Basic transforms](data-shaping-02-basic-transforms.html)\n- [Aggregating transforms](data-shaping-03-aggregating-transforms.html)\n- [Multi-table transforms](data-shaping-04-multi-table-transforms.html)  &#9665; *You are here.*\n- [Reshaping transforms](data-shaping-05-reshaping-transforms.html)\n\nIn this section, we split a data frame into a family of data frames, we concatenate tables row-wise, and we join tables.  \n\n\n\n[Load packages and format data]{.important} as described in the  [Introduction](data-shaping-00-introduction.html).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"midfielddata\")\nlibrary(\"data.table\")\nlibrary(\"dplyr\", warn.conflicts = FALSE)\nlibrary(\"wrapr\")\n\ndata(student, degree)\ncohort <- fread(\"data/three_blocs.csv\")\n```\n:::\n\n\nA quick look at the cohort data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncohort\n#>                  mcid    program peer_group\n#>                <char>     <char>     <char>\n#>     1: MCID3111142965 Electrical   starters\n#>     2: MCID3111145102 Electrical   starters\n#>     3: MCID3111150194 Industrial   starters\n#>     4: MCID3111156083 Electrical   starters\n#>     5: MCID3111156325 Electrical   starters\n#>    ---                                     \n#> 12966: MCID3112618553 Mechanical  graduates\n#> 12967: MCID3112618574 Mechanical  graduates\n#> 12968: MCID3112618976 Mechanical  graduates\n#> 12969: MCID3112619484 Electrical  graduates\n#> 12970: MCID3112641535 Mechanical  graduates\n```\n:::\n\n::: {.cell class='base'}\n\n```{.r .cell-code}\n# base R\nstudent_df <- data.frame(student)\ndegree_df <- data.frame(degree)\ncohort_df <- data.frame(cohort)\n```\n:::\n\n::: {.cell class='dtbl'}\n\n```{.r .cell-code}\n# data.table\nstudent_dt <- copy(student)\ndegree_dt <- copy(degree)\ncohort_dt <- copy(cohort)\n```\n:::\n\n::: {.cell class='dplyr'}\n\n```{.r .cell-code}\n# dplyr\nstudent_tbl <- tibble(student)\ndegree_tbl <- tibble(degree)\ncohort_tbl <- tibble(cohort)\n```\n:::\n\n\n<br>\n\n\n\n## Splitting tables\n\n*Splitting* is an operation that separates a data frame row-wise based on values in specified columns. Splitting is an inherent part of the grouping and summarizing operations described in [Aggregating transforms: Summarizing](data-shaping-03-aggregating-transforms.html#summarizing) such as base R `by()`, data.table `[, , by]`, and dplyr `group_by()`. \n\nHowever, splitting can be performed as a stand-alone operation as well. Base R `split()` creates a list of data frames and wrapr `unpack()` can be used to extract the data frames from the list and bind a variable name to each. \n\n[Task.]{.important} Split the `cohort` data frame by peer groups.  \n\n\n::: {.cell class='base'}\n\n```{.r .cell-code}\n# base R\nDF_split <- split(cohort_df, cohort_df$peer_group)\nstart_df <- DF_split$starters\never_df <- DF_split$ever_enrolled\ngrad_df <- DF_split$graduates\n```\n:::\n\n::: {.cell class='dtbl'}\n\n```{.r .cell-code}\n# data.table\nDT_split <- split(cohort_dt, by = \"peer_group\")\nwrapr::unpack(DT_split, \n              start_dt = starters,\n              ever_dt = ever_enrolled,\n              grad_dt = graduates)\n```\n:::\n\n::: {.cell class='dplyr'}\n\n```{.r .cell-code}\n# dplyr\nTBL_split <- split(cohort_tbl, cohort_tbl$peer_group)\nwrapr::unpack(TBL_split, \n              start_tbl = starters,\n              ever_tbl = ever_enrolled,\n              grad_tbl = graduates)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Display/check one representative result\nstart_dt\n#>                 mcid    program peer_group\n#>               <char>     <char>     <char>\n#>    1: MCID3111142965 Electrical   starters\n#>    2: MCID3111145102 Electrical   starters\n#>    3: MCID3111150194 Industrial   starters\n#>    4: MCID3111156083 Electrical   starters\n#>    5: MCID3111156325 Electrical   starters\n#>   ---                                     \n#> 4049: MCID3112618572 Mechanical   starters\n#> 4050: MCID3112618976 Mechanical   starters\n#> 4051: MCID3112619118 Electrical   starters\n#> 4052: MCID3112619484 Electrical   starters\n#> 4053: MCID3112619666 Mechanical   starters\n\ncheck_equiv_frames(start_df, start_dt)\n#> [1] TRUE\ncheck_equiv_frames(start_dt, start_tbl)\n#> [1] TRUE\n```\n:::\n\n\n\n[Comments]{.important} \n\n- *base R.*  The data frames are extracted from the `DF_split` list using `$`. \n\n- *data.table.* `split()` has a method for data.tables using the `by` argument. \n\n- *dplyr* does not have its own splitting function, though tidyr `nest()` is similar---but requires additional housekeeping to unpack the resulting data frames. It seems easier in this case to use base R `split()` and wrapr `unpack()`.\n\n\n\n\n\n\n## Appending rows\n\nAppending rows is the inverse of splitting a data frame. \n\nIf two or more data frames have the same number of columns, with the same names, in the same order, one set of rows is easily appended to the other. We confirm that both objects are data frames and then verify the column names and positions.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(start_df)\n#> [1] \"data.frame\"\nclass(ever_df)\n#> [1] \"data.frame\"\nclass(grad_df)\n#> [1] \"data.frame\"\n\n\ncolnames(start_df)\n#> [1] \"mcid\"       \"program\"    \"peer_group\"\ncolnames(ever_df)\n#> [1] \"mcid\"       \"program\"    \"peer_group\"\ncolnames(grad_df)\n#> [1] \"mcid\"       \"program\"    \"peer_group\"\n```\n:::\n\n::: {.cell class='base'}\n\n```{.r .cell-code}\n# base R\nresult_df <- rbind(start_df, ever_df, grad_df)\n```\n:::\n\n::: {.cell class='dtbl'}\n\n```{.r .cell-code}\n# data.table\nresult_dt <- rbindlist(list(start_df, ever_dt, grad_dt))\n```\n:::\n\n::: {.cell class='dplyr'}\n\n```{.r .cell-code}\n# dplyr\nresult_tbl <- bind_rows(start_tbl, ever_tbl, grad_tbl)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nresult_dt\n#>                  mcid    program peer_group\n#>                <char>     <char>     <char>\n#>     1: MCID3111142965 Electrical   starters\n#>     2: MCID3111145102 Electrical   starters\n#>     3: MCID3111150194 Industrial   starters\n#>     4: MCID3111156083 Electrical   starters\n#>     5: MCID3111156325 Electrical   starters\n#>    ---                                     \n#> 12966: MCID3112618553 Mechanical  graduates\n#> 12967: MCID3112618574 Mechanical  graduates\n#> 12968: MCID3112618976 Mechanical  graduates\n#> 12969: MCID3112619484 Electrical  graduates\n#> 12970: MCID3112641535 Mechanical  graduates\n \ncheck_equiv_frames(result_df, result_dt)\n#> [1] TRUE\ncheck_equiv_frames(result_dt, result_tbl)\n#> [1] TRUE\n```\n:::\n\n\n[Comments]{.important} \n\n- *base R.* `rbind()` acts on the data frames listed.\n\n- *data.table.*  `rbindlist()`, argument must be a *list* of data frames.\n\n- *dplyr.* `bind_rows()` acts on the data frames listed. Can be a list of data frames. \n\n\n\n\n\n\n\n\n\n\n\n\n\n## Appending columns \n\nColumns can be appended to a data frame using `cbind()` and `bind_cols()`---the column-wise equivalents to `rbind()` and `bind_rows()`---but we rarely use them. Instead, appending new columns is nearly always accomplished in our work using [joins]{.important}. The most common joins in midfieldr work are the *left join* and the *inner join*, described next. \n\n\n\n\n\n\n## Left join\n\nA *left join* is a merge operation between two data frames that returns all observations (rows) of the “left” data frame `x` and all the matching rows in the “right” data frame `y`. \n\nThe general forms of the left join are:\n\n```r\n  # base R\n  merge(x, y, by, all.x = TRUE)\n\n  # data.table\n  y[x, j, on]\n\n  # dplyr\n  left_join(x, y, by)\n```\n\nwhere \n\n- `x` is the “left” data frame, all rows returned\n- `y` is the “right” data frame, matching rows returned\n- `by` and `on` are the vectors of shared column names to merge by\n- `j` (if used) selects columns from the joined data frame to retain \n\n[Task.]{.important} Join student race and sex to the data frame of graduates by ID. \n\nWe use intermediate variables `x` and `y` in each system to help clarify the join operation. \n\n\n::: {.cell class='base'}\n\n```{.r .cell-code}\n# base R\nx <- grad_df[, c(\"mcid\", \"program\"), drop = FALSE]\ny <- student_df[, c(\"mcid\", \"race\", \"sex\"), drop = FALSE]\nresult_df <- merge(x, y, by = c(\"mcid\"), all.x = TRUE)\n```\n:::\n\n::: {.cell class='dtbl'}\n\n```{.r .cell-code}\n# data.table\nx <- grad_dt[, .(mcid, program)]\ny <- student_dt[, .(mcid, race, sex)]\nresult_dt <- y[x, , on = c(\"mcid\")]\n```\n:::\n\n::: {.cell class='dplyr'}\n\n```{.r .cell-code}\n# dplyr\nx <- select(grad_tbl, mcid, program)\ny <- select(student_tbl, mcid, race, sex)\nresult_tbl <- left_join(x, y, by = c(\"mcid\"))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nresult_dt\n#>                 mcid          race    sex    program\n#>               <char>        <char> <char>     <char>\n#>    1: MCID3111142965 International   Male Electrical\n#>    2: MCID3111145102         White   Male Electrical\n#>    3: MCID3111146537         Asian Female Electrical\n#>    4: MCID3111146674         Asian   Male Electrical\n#>    5: MCID3111150194         Black   Male Industrial\n#>   ---                                               \n#> 3260: MCID3112618553 International   Male Mechanical\n#> 3261: MCID3112618574 International   Male Mechanical\n#> 3262: MCID3112618976         White   Male Mechanical\n#> 3263: MCID3112619484         White   Male Electrical\n#> 3264: MCID3112641535         White   Male Mechanical\n\ncheck_equiv_frames(result_df, result_dt)\n#> [1] TRUE\ncheck_equiv_frames(result_dt, result_tbl)\n#> [1] TRUE\n```\n:::\n\n\n\n\n\n\n## Inner join \n\nAn *inner join* is a merge operation between two data frames that returns all observations (rows) from two data frames that match specified conditions in both. \n\nThe general forms of the inner join are:\n\n```r\n  # base R\n  merge(x, y, by, all = FALSE)\n\n  # data.table\n  y[x, j, on, nomatch = NULL]\n\n  # dplyr\n  inner_join(x, y, by)\n```\n\nwhere \n\n- `x` is a data frame, matching rows returned\n- `y` is a data frame, matching rows returned\n- `by` and `on` are the vectors of shared column names to merge by\n- `j` (if used) selects columns from the joined data frame to retain \n\n[Task.]{.important} Join the CIP column from the `degree` data to the ever-enrolled dataset by ID, retaining only those students who completed a degree, i.e., IDs common to both data sets (inner join).\n\n\n::: {.cell class='base'}\n\n```{.r .cell-code}\n# base R\nx <- ever_df[, c(\"mcid\"), drop = FALSE]\nx <- unique(x)\ny <- degree_df[, c(\"mcid\", \"cip6\"), drop = FALSE]\nnames(y)[names(y) == \"cip6\"] <- \"degree_CIP\"\nresult_df <- merge(x, y, by = c(\"mcid\"), all = FALSE)\n```\n:::\n\n::: {.cell class='dtbl'}\n\n```{.r .cell-code}\n# data.table\nx <- ever_dt[, .(mcid)]\nx <- unique(x)\ny <- degree_dt[, .(mcid, degree_CIP = cip6)]\nresult_dt <- y[x, , on = \"mcid\", nomatch = NULL]\n```\n:::\n\n::: {.cell class='dplyr'}\n\n```{.r .cell-code}\n# dplyr\nx <- select(ever_tbl, mcid) %>%\n  distinct()\ny <- select(degree_tbl, mcid, cip6) %>%\n  rename(degree_CIP = cip6)\nresult_tbl <- inner_join(x, y, by = join_by(mcid))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nresult_dt\n#>                 mcid degree_CIP\n#>               <char>     <char>\n#>    1: MCID3111142965     141001\n#>    2: MCID3111145102     141001\n#>    3: MCID3111146537     141001\n#>    4: MCID3111146674     141001\n#>    5: MCID3111150194     143501\n#>   ---                          \n#> 4194: MCID3112618976     141901\n#> 4195: MCID3112619484     141001\n#> 4196: MCID3112641399     270301\n#> 4197: MCID3112641535     141901\n#> 4198: MCID3112698681     110701\n\ncheck_equiv_frames(result_df, result_dt)\n#> [1] TRUE\ncheck_equiv_frames(result_dt, result_tbl)\n#> [1] TRUE\n```\n:::\n\n\n\n\n\n\n## References \n\n<div id=\"refs\"></div>\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}