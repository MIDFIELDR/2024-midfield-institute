{
  "hash": "224f81770912423a7af3799bdadc8c3d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Going further\"\n---\n\n\n\n\n![Image: *From the bottom uo* by Jusitn Kern is licensed under [CC BY-NC-ND 2.0](https://creativecommons.org/licenses/by-nc-nd/2.0/)](figures/data-shaping-6.png)\n\n\n\n\n\n\n\n\n\n\nUsing **base R**, **data.table**, and **dplyr/tidyr** to transform MIDFIELD data as needed for your analysis.\n\nIn this section we demonstrate ...\n\n\n## Setup\n\n*Load* packages.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"midfielddata\")\nlibrary(\"data.table\")\nlibrary(\"dplyr\", warn.conflicts = FALSE)\nlibrary(\"tidyr\")\nlibrary(\"wrapr\")\n```\n:::\n\n\n\n\n*Load* datasets from midfielddata. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(student, term, degree)\n```\n:::\n\n\n\n\n*Recode* strings in `degree` for output readability as described in [Basic Transforms](data-shaping-02-basic-transforms.html#recode-column-values).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndegree[, degree := gsub(\" of\", \"\", degree)]\ndegree[, degree := sub(\"Bachelor Science\", \"BS\", degree)]\ndegree[, degree := sub(\"Bachelor Arts\", \"BA\", degree)]\ndegree[, degree := sub(\"Bachelor Fine Arts\", \"BFA\", degree)]\n```\n:::\n\n\n\n\n*Format* data as described in the  [Introduction](data-shaping-00-introduction.html).\n\n\n\n\n::: {.cell class='base'}\n\n```{.r .cell-code}\n# base R\nstudent_df <- data.frame(student)\nterm_df <- data.frame(term)\ndegree_df <- data.frame(degree)\n```\n:::\n\n::: {.cell class='dtbl'}\n\n```{.r .cell-code}\n# data.table\nstudent_dt <- copy(student)\nterm_dt <- copy(term)\ndegree_dt <- copy(degree)\n```\n:::\n\n::: {.cell class='dplyr'}\n\n```{.r .cell-code}\n# dplyr\nstudent_tbl <- tibble(student)\nterm_tbl <- tibble(term)\ndegree_tbl <- tibble(degree)\n```\n:::\n\n\n\n\n<br>\n\n\n\n\n\n\n\n\n\n## Advanced row-subsetting by groups \n\n### When a specific instance yields a block of rows \n\nWhen subsetting rows for a specific instance of one variable (first, last, etc.) by group or key variable, we may need to allow for the possible return of more than one row per key.  \n\nFor example, from the `degree` data table, subsetting for the first degree-term for the following student should return two rows, one each for Electrical Engineering and Mechanical Engineering.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nid_1 <- \"MCID3112353622\"\ndegree[mcid == id_1]\n#>              mcid   institution term_degree   cip6                       degree\n#>            <char>        <char>      <char> <char>                       <char>\n#> 1: MCID3112353622 Institution C       20133 141001 BS in Electrical Engineering\n#> 2: MCID3112353622 Institution C       20133 141901 BS in Mechanical Engineering\n```\n:::\n\n\n\n\nIn contrast, subsetting for the first term by ID for this next student should return one row for their degree in Economics (Summer 2003) and drop the row for their degree in History (Fall 2006). \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nid_2 <- \"MCID3111600469\"\ndegree[mcid == id_2]\n#>              mcid   institution term_degree   cip6          degree\n#>            <char>        <char>      <char> <char>          <char>\n#> 1: MCID3111600469 Institution C       20024 450601 BA in Economics\n#> 2: MCID3111600469 Institution C       20061 540101   BA in History\n```\n:::\n\n\n\n\n[Task.]{.important} Retain all rows of the earliest term in which students earn one or more degrees. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkey_columns <- c(\"mcid\", \"term_degree\")\ncolumns_we_want <- c(key_columns, \"degree\")\n```\n:::\n\n::: {.cell class='base'}\n\n```{.r .cell-code}\n# base R\nDF <- degree_df[, key_columns, drop = FALSE]\norder_index <- with(DF, order(mcid, term_degree))\nDF <- DF[order_index, , drop = FALSE]\nDF_by <- by(DF, DF$mcid, function(x) \n            data.frame(mcid = unique(x$mcid),\n                       term_degree = x$term_degree[1]))\nDF_combine <- do.call(rbind, DF_by)\nDF <- degree_df[, columns_we_want, drop = FALSE]\nresult_df <- merge(DF_combine, DF, by = key_columns, all.x = TRUE)\nrownames(result_df) <- NULL\n```\n:::\n\n::: {.cell class='dtbl'}\n\n```{.r .cell-code}\n# data.table\nDT <- degree_dt[, ..columns_we_want]\nsetkeyv(DT, key_columns)\nresult_dt <- DT[, .SD[term_degree == term_degree[1]], by = c(\"mcid\")]\nsetkey(result_dt, NULL)\n```\n:::\n\n::: {.cell class='dplyr'}\n\n```{.r .cell-code}\n# dplyr\nresult_tbl <- degree_tbl %>%\n  select(all_of(columns_we_want)) %>% \n  arrange(mcid, term_degree) %>%\n  group_by(mcid) %>%\n  filter(term_degree == term_degree[1]) %>%\n  ungroup()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nresult_dt\n#>                  mcid term_degree                                  degree\n#>                <char>      <char>                                  <char>\n#>     1: MCID3111142225       19881            BS in Electrical Engineering\n#>     2: MCID3111142290       19921            BS in Electrical Engineering\n#>     3: MCID3111142294       19903            BS in Electrical Engineering\n#>     4: MCID3111142299       19921            BS in Electrical Engineering\n#>     5: MCID3111142689       19913                        BA in Journalism\n#>    ---                                                                   \n#> 49614: MCID3112829602       20173  BA in Political Science and Government\n#> 49615: MCID3112831015       20181                         BA in Geography\n#> 49616: MCID3112839623       20181                       BS in Linguistics\n#> 49617: MCID3112845220       20181                       BS in Mathematics\n#> 49618: MCID3112845673       20174 BS in Speech Communication and Rhetoric\n\ncheck_equiv_frames(result_df, result_dt)\n#> [1] TRUE\ncheck_equiv_frames(result_dt, result_tbl)\n#> [1] TRUE\n```\n:::\n\n\n\n\n\n[Comments]{.important} \n\n- *base R.* Order rows by ID and term; use `by()` for a split-apply-combine strategy to create a data frame with two columns: ID and first degree-term; and left-join using `merge()` to recover the matching degree data, including rows with more than one degree per student ID.  \n\n- *data.table.* `setkeyv()` orders the rows and `.SD[...]` subsets for the earliest term `by` ID, including any multiple rows. \n\n- *dplyr.* `arrange()` orders the rows, `group_by()` sets ID as the key, and `filter()` subsets for the earliest term, including any multiple rows.  \n\n\n\n[Check]{.important} that we subset the relevant rows.  The result for `id_1` (from the earlier example) correctly includes two degrees in the same term. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresult_dt[mcid == id_1]\n#>              mcid term_degree                       degree\n#>            <char>      <char>                       <char>\n#> 1: MCID3112353622       20133 BS in Electrical Engineering\n#> 2: MCID3112353622       20133 BS in Mechanical Engineering\n```\n:::\n\n\n\n\nThe result for `id_2`correctly includes their first degree in Economics and drops their subsequent degree in History. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresult_dt[mcid == id_2]\n#>              mcid term_degree          degree\n#>            <char>      <char>          <char>\n#> 1: MCID3111600469       20024 BA in Economics\n```\n:::\n\n\n\n\n\n\n\n\n\n\n\n### When a specific instance yields one row\n\nIn contrast to the previous case, there are times when we expect subsetting for a specific instance by group to yield one row only. \n\nFor example, suppose we want to identify the first term in which a student's cumulative GPA dropped below 2.0. By definition, the result should yield only one row (or none) per ID. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolumns_we_want <- c(\"mcid\", \"term\", \"standing\", \"gpa_cumul\")\nkey_columns <- c(\"mcid\", \"term\")\n```\n:::\n\n::: {.cell class='base'}\n\n```{.r .cell-code}\n# base R\nrows_we_want <- term_df$gpa_cumul < 2.0\nDF <- term_df[rows_we_want, columns_we_want, drop = FALSE]\norder_index <- with(DF, order(mcid, term))\nDF <- DF[order_index, , drop = FALSE]\nDF_by <- by(DF, DF$mcid, function(x) \n            data.frame(mcid = x$mcid[1],\n                       term = x$term[1],\n                       standing = x$standing[1],\n                       gpa_cumul = x$gpa_cumul[1]))\nresult_df <- do.call(rbind, DF_by)\nrownames(result_df) <- NULL\n```\n:::\n\n::: {.cell class='dtbl'}\n\n```{.r .cell-code}\n# data.table\nrows_we_want <- term_dt$gpa_cumul < 2.0\nDT <- term_dt[rows_we_want, ..columns_we_want]\nresult_dt <- DT[, .SD[which.min(term)], by = c(\"mcid\")]\n```\n:::\n\n::: {.cell class='dplyr'}\n\n```{.r .cell-code}\n# dplyr\nresult_tbl <- term_tbl %>%\n  filter(gpa_cumul < 2.0) %>%\n  select(all_of(columns_we_want)) %>%\n  arrange(mcid, term) %>%\n  group_by(mcid) %>%\n  slice(1L) %>%\n  ungroup()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nresult_dt\n#>                  mcid   term           standing gpa_cumul\n#>                <char> <char>             <char>     <num>\n#>     1: MCID3111142283  19881 Academic Probation      1.85\n#>     2: MCID3111142633  19883 Academic Probation      1.96\n#>     3: MCID3111142784  19883 Academic Probation      1.81\n#>     4: MCID3111142895  19881 Academic Probation      1.81\n#>     5: MCID3111142982  19896 Academic Probation      1.97\n#>    ---                                                   \n#> 11675: MCID3112897319  20181 Academic Dismissal      1.77\n#> 11676: MCID3112897359  20181 Academic Dismissal      1.97\n#> 11677: MCID3112897470  20181 Academic Dismissal      1.36\n#> 11678: MCID3112897505  20181 Academic Dismissal      1.57\n#> 11679: MCID3112898068  20181 Academic Dismissal      1.45\n\ncheck_equiv_frames(result_df, result_dt)\n#> [1] TRUE\ncheck_equiv_frames(result_dt, result_tbl)\n#> [1] TRUE\n```\n:::\n\n\n\n\n\n\n\n[Comments]{.important} \n\n- *base R.* Subset for rows with GPA < 2.0. Like we did above, order rows by ID and term use `by()` to split-apply-combine operate on all four columns, but retain the first instance (one row) only by ID. \n\n- *data.table.* Subset rows and columns; `setkeyv()` orders the rows and `.SD[1]` subsets for the first instance only (one row). \n\n- *dplyr.*  Subset rows and columns; order rows; use `slice(1L)` to subset the first row by ID.  \n\n\n\n\n\n\n\n\n\n\n\n\n[Check]{.important} that we have one row per ID as expected.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(n_mcid <- length(unique(result_dt$mcid)))\n#> [1] 11679\n(n_observation <- nrow(result_dt))\n#> [1] 11679\nall.equal(n_mcid, n_observation)\n#> [1] TRUE\n```\n:::\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## References \n\n<div id=\"refs\"></div>\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}